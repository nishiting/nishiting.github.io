<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>距离计算</title>
    <link href="/2023/06/08/%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/06/08/%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="经纬度"><a href="#经纬度" class="headerlink" title="经纬度"></a>经纬度</h1><h2 id="纬线与纬度"><a href="#纬线与纬度" class="headerlink" title="纬线与纬度"></a>纬线与纬度</h2><p><img src="/img/content/distance/%E7%BA%AC%E5%BA%A6.png" alt="纬度.png"><br>所有纬线自成一个圆圈，被称为纬线圈，纬线圈的长度不等，最长的是赤道，由赤道向两极逐渐缩短，到两极缩成一个点。纬线指示东西方向，所有的纬线都平行，赤道把地球平分为南北两个半球。<br>纬度从赤道算起，把赤道定为0度，由赤道到北极和南极各分作90度，赤道以北是北纬，代号是Ｎ；以南是南纬，代号是Ｓ，北纬90度是北极，南纬90度是南极。南纬和北纬的分界线是赤道。<br><strong>特殊的纬线：</strong><br><strong>0度</strong>纬线：即赤道，是最长的纬线，南北半球的分界线。<br><strong>30度</strong>纬线：低、中纬度的分界线。<br><strong>60度</strong>纬线：中、高纬度的分界线。<br><strong>90度</strong>纬线：即南北极点，北纬90度是北极点，南纬90度是南极点。<br><strong>23.5度</strong>纬线：回归线，是热带和温带的分界线，有无太阳直射现象的分界线。北纬23.5度是北回归线，南纬 23.5度是南回归线。<br><strong>66.5度</strong>纬线：极圈，是温带和寒带的分界线，有无极昼和极夜现象的分界线。北纬66.5度是北极圈，南纬66.5度是南极圈。<br>地球是自西向东转的，箭头的方向是东，相反的方向是西。面对地图，上北下南，左西右东。</p><h2 id="经线与经度"><a href="#经线与经度" class="headerlink" title="经线与经度"></a>经线与经度</h2><p><img src="/img/content/distance/%E7%BA%AC%E5%BA%A6.png" alt="纬度.png"><br>所有经线都是半圆形，经线长度都相等，经线指示南北方向，所有的经线都在南北两极点处相交，两条正对的经线组成一个经线圈，它们的度数和是180度，任何一个经线圈都可以把地球平分为两个半球。<br>国际上规定，把通过英国伦敦格林尼治天文台原址的那一条经线定为0度经线，也叫本初子午线。从本初子午线向东、向西，各分作180度，以东的180度属于东经，以西的180度属于西经，经度最大是180度，180度经线只有一条。东西经的分界线是0度经线和180度经线。<br><strong>特殊的经线：</strong><br><strong>0度</strong>经线：即本初子午线，是东西经的分界线，以东是东经，以西是西经。<br><strong>180度</strong>经线：是东西经的分界线，以东是西经，以西为东经。<br><strong>西经20度</strong>经线：东西半球的分界线，以东是东半球，以西是西半球。<br><strong>东经160度</strong>经线：东西半球的分界线，以东是西半球，以西是东半球。</p><h1 id="地理位置应用"><a href="#地理位置应用" class="headerlink" title="地理位置应用"></a>地理位置应用</h1><p>1.查询一段距离内的位置<br><img src="/img/content/distance/%E9%99%84%E8%BF%91.png" alt="附近"><br>2.根据距离排序且显示所有距离<br><img src="/img/content/distance/%E6%8C%89%E8%B7%9D%E7%A6%BB%E6%8E%92%E5%BA%8F.png" alt="按距离排序.png"></p><h1 id="地理位置算法"><a href="#地理位置算法" class="headerlink" title="地理位置算法"></a>地理位置算法</h1><h2 id="GeoHash算法"><a href="#GeoHash算法" class="headerlink" title="GeoHash算法"></a>GeoHash算法</h2><h3 id="划分区域至二进制"><a href="#划分区域至二进制" class="headerlink" title="划分区域至二进制"></a>划分区域至二进制</h3><h4 id="经纬度划分"><a href="#经纬度划分" class="headerlink" title="经纬度划分"></a>经纬度划分</h4><p>GeoHash算法可以将一个二维的经纬度坐标转换成一个可比较的字符串信息，也就是一个降维的过程。具体的实现过程如下：<br>谷歌地图：39.1785816935,117.4612203712 (不同地图供应商所提供定位信息有差异)<br>纬度 <strong>latitude</strong> ：39.1785816935<br>经度 <strong>longitude</strong>：117.4612203712<br>将经纬度进行二分法的形式落于相对应的区间中，步骤如下图：39.17858169坐落于0-90的区间内，坐落于0-45的区间内，坐落于22.5-45的区间内，层层二分，数据分的越细，获取到的精度越准确；</p><table><thead><tr><th>纬度范围</th><th>划分区间0</th><th>划分区间1</th><th>39.1785816935</th></tr></thead><tbody><tr><td>（-90，90）</td><td>（-90,0]</td><td>(0,90]</td><td>1</td></tr><tr><td>(0,90)</td><td>(0,45]</td><td>(45,90]</td><td>0</td></tr><tr><td>(0,45)</td><td>(0,22.5]</td><td>(22.5,45]</td><td>1</td></tr><tr><td>(22.5,45)</td><td>(22.5,37.5]</td><td>(37.5,45]</td><td>1</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><table><thead><tr><th>经度范围</th><th>划分区间0</th><th>划分区间1</th><th>117.4612203712</th></tr></thead><tbody><tr><td>（-180，180）</td><td>（-180,0]</td><td>(0,180]</td><td>1</td></tr><tr><td>（0，180）</td><td>（0,90]</td><td>(90，180]</td><td>1</td></tr><tr><td>(90，180)</td><td>(90,135]</td><td>(135,180]</td><td>0</td></tr><tr><td>(90,135)</td><td>(90,112.5]</td><td>(112.5,135]</td><td>1</td></tr><tr><td>(112.5,135)</td><td>(112.5,123.75]</td><td>(123.75,135]</td><td>0</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>最终获得纬度的二进制：101101…<br>经度的二进制：11010…<br>将经纬度的二进制数进行组合，<strong>以奇数为纬度，偶数为经度组合；</strong><br>经纬度组合后：111001110001…</p><h4 id="Redis-GEO"><a href="#Redis-GEO" class="headerlink" title="Redis GEO"></a>Redis GEO</h4><h5 id="将三维转为二维"><a href="#将三维转为二维" class="headerlink" title="将三维转为二维"></a>将三维转为二维</h5><p>地球纬度区间是[-90,90],经度区间是[-180,180]。 将它展开想象长一个矩形为<br><img src="/img/content/distance/%E4%B8%89%E7%BB%B4%E8%BD%AC%E4%BA%8C%E7%BB%B4.png" alt="三维转二维.png"></p><h5 id="将二维转为一维"><a href="#将二维转为一维" class="headerlink" title="将二维转为一维"></a>将二维转为一维</h5><p>通过刚才的方法，我们能够将地球的表面转换成二维空间的平面。那接下来要将二维转变成一维。如果切割二维空间，可以切割出很多正方形。如何表示这个正方形呢？最简单的方法是在平面上进行遍历。每遍历到一个点，就给它标注一个值，比如00、01、10、11，随着二进制数字增加，相当于遍历面上不同的位置。<br><img src="/img/content/distance/%E4%BA%8C%E7%BB%B4%E5%8F%98%E4%B8%80%E7%BB%B4.png" alt="二维变一维.png"><br>当将空间划分为四块时候，编码的顺序分别是左下角00，左上角01，右下脚10，右上角11，也就是类似于Z的曲线。<br>当我们递归的将各个块分解成更小的子块时可以标识更小的空间范围（如上图二中所示），如从0000开始到1111结束编码的顺序是自相似的（分形），每一个子快也形成Z曲线，这种类型的曲线被称为Peano空间填充曲线。</p><h3 id="将二进制编码"><a href="#将二进制编码" class="headerlink" title="将二进制编码"></a>将二进制编码</h3><p>在开发中，Base32、Base64加密解密相信大家都有遇到过和了解过，GeoHash将二维经纬度转换成可比较字符串的过程也就是一个转Base32的过程，Base32是由数据0~9及26个英文字母(减去<strong>’a’ , ’i’ , ’l’ , ’o’</strong>四个字符)</p><h4 id="Base32"><a href="#Base32" class="headerlink" title="Base32"></a>Base32</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] toBase64 = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>,<br>    <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>,<br>    <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span> <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] toBase64 = &#123;<br>    <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>,<br>    <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>,<br>    <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>,<br>    <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>,<br>    <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Base32对应的二进制序列是5位，Base64对应的二进制序列是6位，我们需要将这个经纬度二进制序列转换成Base32的形式输出，将二进制序列每5位一组进行拆分得到：<br>11100 11100 01…..<br>11100转换成十进制得到 1<em>2^4 + 1</em>2^3 + 1*2^2 = 16 + 8 + 4 = 28 将28转换成Base32得到“W”<br>所以上面的这个二进制序列可以得到的字符串是 ww,所表示的区域范围是：<br><img src="/img/content/distance/geohash.png" alt="geohash.png"><br>将经纬度转换成二进制序列的过程中，转换的次数越多，所表示的精度越细，标识的范围越小，我们日常生活中所描述的用户定位，在宏观上形容的并不是一个点，而是表示的一块区域信息，我们位于某一个区域范围内。</p><h3 id="编码表示距离远近"><a href="#编码表示距离远近" class="headerlink" title="编码表示距离远近"></a>编码表示距离远近</h3><p><a href="https://en.wikipedia.org/wiki/Geohash">GeoHash</a>的位数表示距离的远近，比如，1km<br><img src="/img/content/distance/geo%E9%95%BF%E5%BA%A6%E8%8C%83%E5%9B%B4.png" alt="geo长度范围.png"><br>如要查询1000m,可以使用5位编码。过滤掉大部分的人，然后再进行距离计算。</p><h3 id="GeoHash算法问题"><a href="#GeoHash算法问题" class="headerlink" title="GeoHash算法问题"></a>GeoHash算法问题</h3><p>如下图所示，根据可比较字符串来划分区域，会存在一个边界问题；<br><img src="/img/content/distance/geo%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="geo算法比较.png"><br>解决的思路很简单，我们查询时，除了使用定位点的GeoHash编码进行匹配外，还使用周围8个区域的GeoHash编码，这样可以避免这个问题。</p><h2 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h2><h3 id="Haversine公式"><a href="#Haversine公式" class="headerlink" title="Haversine公式"></a>Haversine公式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distHaversineRAD</span><span class="hljs-params">(<span class="hljs-type">double</span> lat1, <span class="hljs-type">double</span> lon1, <span class="hljs-type">double</span> lat2, <span class="hljs-type">double</span> lon2)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">hsinX</span> <span class="hljs-operator">=</span> Math.sin((lon1 - lon2) * <span class="hljs-number">0.5</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">hsinY</span> <span class="hljs-operator">=</span> Math.sin((lat1 - lat2) * <span class="hljs-number">0.5</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hsinY * hsinY +<br>                (Math.cos(lat1) * Math.cos(lat2) * hsinX * hsinX);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * Math.atan2(Math.sqrt(h), Math.sqrt(<span class="hljs-number">1</span> - h)) * <span class="hljs-number">6367000</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>目前北京地区在线服务有5w个POI，计算一遍距离需要7ms。现在数据增长特别快，未来北京地区POI数目增大到100w时，我们筛选服务仅计算距离这一项就需要消耗144多ms，性能十分堪忧。（注：本文测试环境的处理器为2.9GHz Intel Core i7，内存为8GB 1600 MHz DDR3，操作系统为OS X10.8.3，实验在单线程环境下运行）</p><table><thead><tr><th><strong>POI数目</strong></th><th><strong>耗时（ms）</strong></th></tr></thead><tbody><tr><td>5w</td><td>7</td></tr><tr><td>10w</td><td>14</td></tr><tr><td>100w</td><td>144</td></tr></tbody></table><h3 id="简化算法"><a href="#简化算法" class="headerlink" title="简化算法"></a>简化算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distanceSimplify</span><span class="hljs-params">(<span class="hljs-type">double</span> lat1, <span class="hljs-type">double</span> lng1, <span class="hljs-type">double</span> lat2, <span class="hljs-type">double</span> lng2, <span class="hljs-type">double</span>[] a)</span> &#123;<br>     <span class="hljs-type">double</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> lng1 - lng2; <span class="hljs-comment">// 经度差值</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> lat1 - lat2; <span class="hljs-comment">// 纬度差值</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (lat1 + lat2) / <span class="hljs-number">2.0</span>; <span class="hljs-comment">// 平均纬度</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">Lx</span> <span class="hljs-operator">=</span> toRadians(dx) * <span class="hljs-number">6367000.0</span>* Math.cos(toRadians(b)); <span class="hljs-comment">// 东西距离</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">Ly</span> <span class="hljs-operator">=</span> <span class="hljs-number">6367000.0</span> * toRadians(dy); <span class="hljs-comment">// 南北距离</span><br>     <span class="hljs-keyword">return</span> Math.sqrt(Lx * Lx + Ly * Ly);  <span class="hljs-comment">// 用平面的矩形对角距离公式计算总距离</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>POI数目</strong></th><th><strong>耗时（ms）</strong></th></tr></thead><tbody><tr><td>5w</td><td>0.5</td></tr><tr><td>10w</td><td>1.1</td></tr><tr><td>100w</td><td>11</td></tr></tbody></table><h3 id="进一步简化算法"><a href="#进一步简化算法" class="headerlink" title="进一步简化算法"></a>进一步简化算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span>[] trainPolyFit(<span class="hljs-type">int</span> degree, <span class="hljs-type">int</span> Length)&#123;<br>    <span class="hljs-type">PolynomialCurveFitter</span> <span class="hljs-variable">polynomialCurveFitter</span> <span class="hljs-operator">=</span> PolynomialCurveFitter.create(degree);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">minLat</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.0</span>; <span class="hljs-comment">//中国最低纬度</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">maxLat</span> <span class="hljs-operator">=</span> <span class="hljs-number">60.0</span>; <span class="hljs-comment">//中国最高纬度</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">interv</span> <span class="hljs-operator">=</span> (maxLat - minLat) / (<span class="hljs-type">double</span>)Length;<br>    List&lt;WeightedObservedPoint&gt; weightedObservedPoints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;WeightedObservedPoint&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Length; i++) &#123;<br>        <span class="hljs-type">WeightedObservedPoint</span> <span class="hljs-variable">weightedObservedPoint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeightedObservedPoint</span>(<span class="hljs-number">1</span>,  minLat + (<span class="hljs-type">double</span>)i*interv, Math.cos(toRadians(x[i])));<br>        weightedObservedPoints.add(weightedObservedPoint); <br>    &#125;<br>    <span class="hljs-keyword">return</span> polynomialCurveFitter.fit(weightedObservedPoints);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distanceSimplifyMore</span><span class="hljs-params">(<span class="hljs-type">double</span> lat1, <span class="hljs-type">double</span> lng1, <span class="hljs-type">double</span> lat2, <span class="hljs-type">double</span> lng2, <span class="hljs-type">double</span>[] a)</span> &#123;<br>     <span class="hljs-comment">//1) 计算三个参数</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> lng1 - lng2; <span class="hljs-comment">// 经度差值</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> lat1 - lat2; <span class="hljs-comment">// 纬度差值</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (lat1 + lat2) / <span class="hljs-number">2.0</span>; <span class="hljs-comment">// 平均纬度</span><br>     <span class="hljs-comment">//2) 计算东西方向距离和南北方向距离(单位：米)，东西距离采用三阶多项式</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">Lx</span> <span class="hljs-operator">=</span> (a[<span class="hljs-number">3</span>] * b*b*b  + a[<span class="hljs-number">2</span>]* b*b  +a[<span class="hljs-number">1</span>] * b + a[<span class="hljs-number">0</span>] ) * toRadians(dx) * <span class="hljs-number">6367000.0</span>; <span class="hljs-comment">// 东西距离</span><br>     <span class="hljs-type">double</span> <span class="hljs-variable">Ly</span> <span class="hljs-operator">=</span> <span class="hljs-number">6367000.0</span> * toRadians(dy); <span class="hljs-comment">// 南北距离</span><br>     <span class="hljs-comment">//3) 用平面的矩形对角距离公式计算总距离</span><br>     <span class="hljs-keyword">return</span> Math.sqrt(Lx * Lx + Ly * Ly);<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>POI数目</strong></th><th><strong>耗时（ms）</strong></th></tr></thead><tbody><tr><td>5w</td><td>0.1</td></tr><tr><td>10w</td><td>0.3</td></tr><tr><td>100w</td><td>4</td></tr></tbody></table><p><strong>##</strong></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GeoHash</tag>
      
      <tag>RedisGeo</tag>
      
      <tag>Haversine公式</tag>
      
      <tag>经纬度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的机制</title>
    <link href="/2023/06/07/%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/07/%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>如内存与零拷贝技术一文所示。CPU读取数据进行计算的内存全景如下:<br><img src="/img/content/lock/%E5%86%85%E5%AD%98%E5%85%A8%E6%99%AF%E5%9B%BE.png" alt="内存全景图.png"><br>我们可以看到，数据可能发生不一致的地方就是缓存不共用的地方，这是缓存不共用的地方主要有两处，一是CPU高速缓存不一致。二是Java线程中的工作内存。</p><h1 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h1><h2 id="单核"><a href="#单核" class="headerlink" title="单核"></a>单核</h2><p>单个 CPU 对于每个任务的执行，都只执行一小段时间，不断的在多个任务之间快速的切换。多进程和多线程是一种提高 CPU 使用率的方案，即并发。<br>CPU 在任务执行过程中，本身是感知不到时间片存在。在晶振产生的时钟周期驱动下，CPU 会不间断的根据 PC 寄存器里的地址进行取址译码执行。晶振是一个中断，中断的频率越高，CPU 执行的速度也就越快。而时间片一切，PC 寄存器的地址改变，CPU 就被动的在多个任务之间切换执行。<br>时间片切换有两个来源，一个是操作系统控制的并发，一个是软硬件中断。并发本身也是通过晶振中断来实现的，因为由操作系统控制，额外增加了优先级队列等一系列控制，所以单独作为一个来源来分析比较清晰。<br>所以现在就通过并发和中断，来分析时间片切换可能会导致的共享数据安全问题。</p><h3 id="非原子操作"><a href="#非原子操作" class="headerlink" title="非原子操作"></a>非原子操作</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>就是大家都知道的，我们写的代码如果在多线程场景下，如果有共享数据，那么共享数据会不安全，会产生数据紊乱。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>  flag++;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码，flag 是共享数据，threads 被并发执行。当 threads 函数被 1000 个线程并发执行的时候，最后 flag 的值 &lt; 1000，极小概率 = 1000。因为 flag++ 需要最少三条指令才能运行完毕，分别是读内存、寄存器赋值、写内存。这里就会出现 a 线程执行了读内存指令后，时间片切到了 b 线程，b 线程完成了读、赋值、写指令，又切回到 a 线程，a 继续完成赋值和写指令。因为 a、b 读到的内存值是一样的，最后写入的也就是一样的，所以 flag 相当于少了一次 + 1 操作。时间片轮转对于指令执行流程来说是随机的，所以 a 和 b 的三个指令完全有可能任意交叉执行。详见下表：<br><img src="/img/content/lock/%E5%8D%95%E6%A0%B8_%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C_%E5%B9%B6%E5%8F%91.jpg" alt="单核_非原子操作_并发.jpg"></p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>上面也说到，并发是根据晶振中断实现的。除了晶振中断，还有其他的软硬件中断会改变 CPU 的执行流程。如果改写了中断向量表的中断指向或者我们在监控到中断到来时执行特定函数，一样会遇到和上面的并发一样的数据安全问题，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">int flag = 0;<br>void <span class="hljs-function"><span class="hljs-title">interrupt_run</span></span>() &#123;<br>  flag++;<br>&#125;<br>void thread_run(void) &#123;<br>  flag++;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们假设 thread_run 函数是单线程执行的，因为中断时机是未知的，完全有可能 interrupt_run 和 thread_run 的执行时机会出现上面并发场景下的情况，这个时候 flag 也不再数据安全。和并发一样，详见下表：<br><img src="/img/content/lock/%E5%8D%95%E6%A0%B8_%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C_%E4%B8%AD%E6%96%AD.jpg" alt="单核_非原子操作_中断.jpg"><br>非原子操作，即任务执行过程中可能会因为时间片轮转发生执行中断情况的操作。如果非原子操作中出现共享数据，则共享数据不在安全，可能会产生紊乱。<br>这里有两个前提，即非原子操作和共享数据。如果没有共享数据，相当于 1 个 CPU 的两条任务线独立执行，是没有问题的。那如果是原子操作呢？</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>对于原子操作，即执行周期内不会被打断的指令。该指令可能需要多个时钟周期才能运行完毕，因为有取址、译码、执行一套动作，最少也需要 1 个时钟周期，全过程称为执行周期。在执行周期内，该指令一定有头有尾的被执行完毕，即要么不执行，要么全执行。<br>当一个任务不会被时间片轮转后中途暂停执行，那么这个任务在单核场景下就是安全的。<br>其实 CPU 提供的指令集基本都是原子操作的，比如读写内存的 “load xxx” 和 “store xxx”，这些指令在单核下都是安全的。如果我们都写汇编并且实际任务运算都可以通过原子操作完成，那么在单核分时机制下就不会有数据安全问题。但实际上，即使我们都写汇编，但我们真实执行的任务都不是原子操作可以完成的，即我们需要解决的任务需要 N 个原子操作配合才能够完成。只要 &gt;= 2 个原子操作配合的任务流，都有可能在时间片轮转的情况下被中断执行，中断过程中共享数据就有可能被其他任务修改，不在数据安全。</p><h4 id="CPU原子操作指令"><a href="#CPU原子操作指令" class="headerlink" title="CPU原子操作指令"></a>CPU原子操作指令</h4><h5 id="xchg-原子操作"><a href="#xchg-原子操作" class="headerlink" title="xchg 原子操作"></a>xchg 原子操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">// xchg 内存交换指令<br><br>*lock = 0;<br>mov ax, 1;<br><br>void threads(void) &#123;<br>  xchg ax, &amp;lock;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，xchg 是 x86 提供的内存交换指令，即将一个寄存器值和一个内存地址中的值进行原子操作交换。比如上面例子，lock 内存地址默认值为 0，ax 寄存器默认值为 1。在 threads 执行一次后，lock 内存地址中的值会变成 1，ax 寄存器中值会变成 0。再执行一次，则因为 ax 寄存器中值为 0，所以再次互换后，就回到了初始的默认状态，即 lock 为 0，ax 为 1。</p><h5 id="cmpxchg-原子操作"><a href="#cmpxchg-原子操作" class="headerlink" title="cmpxchg 原子操作"></a>cmpxchg 原子操作</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// <span class="hljs-keyword">cmpxchg</span> 比较交换指令<br><br>*<span class="hljs-keyword">lock</span> = <span class="hljs-number">0</span><span class="hljs-comment">;// 或者初始化为 1，代表 cmpxchg 指令的首操作数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">1</span><span class="hljs-comment">;// 代表 cmpxchg 指令的比较值</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">0</span><span class="hljs-comment">; // 或者初始化为 1，代表 cmpxchg 指令的首操作数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">2</span><span class="hljs-comment">;// 代表 cmpxchg 指令的源操作数</span><br><br>void threads(void) &#123;<br>  <span class="hljs-keyword">cmpxchg</span> &amp;<span class="hljs-keyword">lock</span>, <span class="hljs-built_in">cx</span><span class="hljs-comment">;</span><br>  // 或 <span class="hljs-keyword">cmpxchg</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">cx</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，cmpxchg 是 x86 提供的比较交换指令，共需要 2 个寄存器和 1 个寄存器或者内存地址。<br>首先需要有一个用于比较的值，这个值需要在寄存器中，上面我们用 ax 存储。<br>还需要一个 “首操作数”，即 cmpxchg 指令后面的第一个操作数，这个操作数可以是寄存器或者内存地址，上面我们用 bx 或者 &amp;lock 表示。<br>最后还需要 “源操作数”，即 cmpxchg 指令后面的第二个操作数，这个操作数需要在寄存器中，上面我们用 cx 存储。<br>cmpxchg 就是让比较值和首操作数比大小，如果相等，则首操作数赋值为源操作数。如果不想等，则比较值赋值为源操作数。<br>我们分析 cmpxchg &amp;lock, cx; 这种场景，因为 ax 为 1，lock 内存地址值为 0，两者不想等，所以 cmpxchg 指令执行完成后，lock 没有变化，ax 寄存器变成了 2。如果按照上面注释里面 lock 初始化为 1，则 ax 和 lock 内存地址值都是 1，两者想等，这个时候 lock 内存地址值会变成 2。</p><h2 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h2><h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>随着时间的推移，CPU 和内存的访问性能相差越来越大，于是就在 CPU 内部嵌入了 CPU Cache（高速缓存），CPU Cache 离 CPU 核心相当近，因此它的访问速度是很快的，于是它充当了 CPU 与内存之间的缓存角色。<br>CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度也快，但是存储容量相对就会越小。其中，在多核心的 CPU 里，每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/img/content/lock/cpu_cache.png" alt="cpu_cache.png"></h3><h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><p>那什么是缓存一致性呢？我们拿一个有两个核心的 CPU，来看一下。你可以看这里这张图，我们结合图来说。<br><img src="/img/content/lock/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.png" alt="缓存一致性问题.png"><br>比方说，iPhone 降价了，我们要把 iPhone 最新的价格更新到内存里。为了性能问题，它采用了上一讲我们说的写回策略，先把数据写入到 L2 Cache 里面，然后把 Cache Block 标记成脏的。这个时候，数据其实并没有被同步到 L3 Cache 或者主内存里。1 号核心希望在这个 Cache Block 要被交换出去的时候，数据才写入到主内存里。<br>如果我们的 CPU 只有 1 号核心这一个 CPU 核，那这其实是没有问题的。不过，我们旁边还有一个 2 号核心呢！这个时候，2 号核心尝试从内存里面去读取 iPhone 的价格，结果读到的是一个错误的价格。这是因为，iPhone 的价格刚刚被 1 号核心更新过。但是这个更新的信息，只出现在 1 号核心的 L2 Cache 里，而没有出现在 2 号核心的 L2 Cache 或者主内存里面。<strong>这个问题，就是所谓的缓存一致性问题，1 号核心和 2 号核心的缓存，在这个时候是不一致的。</strong><br>为了解决这个缓存不一致的问题，我们就需要有一种机制，来同步两个不同核心里面的缓存数据。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。<br>第一点叫<strong>写传播</strong>（Write Propagation）。写传播是说，在一个 CPU 核心里，我们的 Cache 数据更新，必须能够传播到其他的对应节点的 Cache Line 里。<br>第二点叫<strong>事务的串行化</strong>（Transaction Serialization），事务串行化是说，我们在一个 CPU 核心里面的读取和写入，在其他的节点看起来，顺序是一样的。<br>第一点写传播很容易理解。既然我们数据写完了，自然要同步到其他 CPU 核的 Cache 里。但是第二点事务的串行化，可能没那么好理解，我这里仔细解释一下。<br>我们还拿刚才修改 iPhone 的价格来解释。这一次，我们找一个有 4 个核心的 CPU。1 号核心呢，先把 iPhone 的价格改成了 5000 块。差不多在同一个时间，2 号核心把 iPhone 的价格改成了 6000 块。这里两个修改，都会传播到 3 号核心和 4 号核心。<br><img src="/img/content/lock/%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%B2%E8%A1%8C%E5%8C%96.png" alt="事务的串行化.png"><br>然而这里有个问题，3 号核心先收到了 2 号核心的写传播，再收到 1 号核心的写传播。所以 3 号核心看到的 iPhone 价格是先变成了 6000 块，再变成了 5000 块。而 4 号核心呢，是反过来的，先看到变成了 5000 块，再变成 6000 块。虽然写传播是做到了，但是各个 Cache 里面的数据，是不一致的。<br>事实上，我们需要的是，从 1 号到 4 号核心，都能看到相同顺序的数据变化。比如说，都是先变成了 5000 块，再变成了 6000 块。这样，我们才能称之为实现了事务的串行化。<br>事务的串行化，不仅仅是缓存一致性中所必须的。比如，我们平时所用到的系统当中，最需要保障事务串行化的就是数据库。多个不同的连接去访问数据库的时候，我们必须保障事务的串行化，做不到事务的串行化的数据库，根本没法作为可靠的商业数据库来使用。<br>而在 CPU Cache 里做到事务串行化，需要做到两点，第一点是一个 CPU 核心对于数据的操作，需要同步通信给到其他 CPU 核心。第二点是，如果两个 CPU 核心里有同一个数据的 Cache，那么对于这个 Cache 数据的更新，需要有一个“锁”的概念。只有拿到了对应 Cache Block 的“锁”之后，才能进行对应的数据更新。</p><h3 id="非原子性"><a href="#非原子性" class="headerlink" title="非原子性"></a>非原子性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">int flag = 0;<br><br>void cores(void) &#123;<br>  flag++;<br>&#125;<br></code></pre></td></tr></table></figure><p>非原子操作在单核下因为执行过程被打断，会出现数据紊乱。在并行也是下一样的，只是执行过程被打断的原因不是因为时间片轮转，而是同时操作。<br>core1 拿到 flag 为 0，core2 拿到 flag 也为 0。两个核心执行完毕后，flag 没有变成 2，而是 1。<br>和并发 &amp; 中断相比，现象是一样的，原因的本质也是一样的，只是原因的表现有些不同。所以非原子操作在多核下，并发 &amp; 中断 &amp; 并行 一起导致了数据不安全。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子操作在单核下是安全的，但是在多核下原子操作就不在安全了。拿 cmpxchg 举例子来说</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">// cmpxchg 比较交换指令<br><br>*lock = 0;// 或者初始化为 1，代表 cmpxchg 指令的首操作数<br>mov ax, 1;// 代表 cmpxchg 指令的比较值<br>mov bx, 0; // 或者初始化为 1，代表 cmpxchg 指令的首操作数<br>mov cx, 2;// 代表 cmpxchg 指令的源操作数<br><br>void threads(void) &#123;<br>  cmpxchg &amp;lock, cx;<br>  // 或 cmpxchg bx, cx;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>前面说到 cmpxchg 的执行需要很多个时钟周期，包含内存写、寄存器读等多个操作，但是 cmpxchg 的执行流程不会被时间片轮转所打算，从开头到结尾一鼓作气执行完毕，所以在单核场景下是数据安全的原子操作。<br>但是在多核场景下，有可能会出现一个 CPU 核心把 “首操作数” 取值完毕，另一个 CPU 核心同时把 lock 内存地址的值给改了。因为 cmpxchg 需要好几个任务流程，需要很多时钟周期，很难说执行过程中会不会有另一个 CPU 也对共享内存值做了其他的操作。这时候就有可能出现 ax 寄存器值和 “首操作数” 开始的时候不一样，cx 被赋值到 ax 寄存器。可是指令执行结束后，发现 lock 内存地址的值和当时 cx 寄存器值却是一样的，这就产生了问题。所以 cmpxchg 没有死于 时间片轮转，却死在了并行上。</p><h2 id="共享数据不一致原因总结"><a href="#共享数据不一致原因总结" class="headerlink" title="共享数据不一致原因总结"></a>共享数据不一致原因总结</h2><p>原子性、可见性有序性三个重要的问题，其实这就是共享数据安全的三大核心。<br>这三个原因都会导致共享数据不再安全，使得我们写的代码稍不注意就会有错误风险。<br>如果要解决共享数据安全问题，就可以从这三个方面找切入点。而且这三个核心因素之间还有一层间接的联系，即三大核心的包含关系。<br><img src="/img/content/lock/%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E5%8E%9F%E5%9B%A0.jpg" alt="共享数据不一致原因.jpg"></p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>也没啥特效药。编译器或者解释器，都会提供一些前缀给开发人员。开发人员只要觉得一个问题能够单纯通过有序性来解决，那就可以这么做。<br>比如 C/CPP 中，可以通过下面禁用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#pragma GCC push_options</span><br><span class="hljs-comment">#pragma GCC optimize(&quot;O0&quot;)</span><br>void <span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<br>&#125;<br><span class="hljs-comment">#pragma GCC pop_options</span><br><br></code></pre></td></tr></table></figure><p>C/CPP 中还提供了 volatile 描述符，该描述符可以停止编译器优化，也可以直接用。Java 中也提供了 volatile，比 C 的 volatile 含义要丰富很多，也可以停止编译器优化。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="高速缓存内存一致性-总线嗅探机制和-MESI-协议"><a href="#高速缓存内存一致性-总线嗅探机制和-MESI-协议" class="headerlink" title="高速缓存内存一致性-总线嗅探机制和 MESI 协议"></a>高速缓存内存一致性-总线嗅探机制和 MESI 协议</h4><p>要解决缓存一致性问题，首先要解决的是多个 CPU 核心之间的数据传播问题。最常见的一种解决方案呢，叫作<strong>总线嗅探</strong>（Bus Snooping）。这个名字听起来，你多半会很陌生，但是其实特很好理解。<br>这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。<br>总线本身就是一个特别适合广播进行数据传输的机制，所以总线嗅探这个办法也是我们日常使用的 Intel CPU 进行缓存一致性处理的解决方案。关于总线这个知识点，我们会放在后面的 I/O 部分更深入地进行讲解，这里你只需要了解就可以了。<br>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议。不过其中最常用的，就是今天我们要讲的 MESI 协议。和很多现代的 CPU 技术一样，MESI 协议也是在 Pentium 时代，被引入到 Intel CPU 中的。<br>MESI 协议，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 Cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。<br>相对于写失效协议，还有一种叫作<strong>写广播</strong>（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的 CPU 核心，同时更新各个核心里的 Cache。<br>写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的 CPU 核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他 CPU 核心。<br><img src="/img/content/lock/%E5%86%99%E5%A4%B1%E6%95%88%E5%86%99%E4%BC%A0%E6%92%AD.png" alt="写失效写传播.png"><br> MESI 协议的由来呢，来自于我们对 Cache Line 的四个不同的标记，分别是：</p><ul><li>M：代表已修改（Modified）</li><li>E：代表独占（Exclusive）</li><li>S：代表共享（Shared）</li><li>I：代表已失效（Invalidated）</li></ul><p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。所谓的“已修改”，就是我们上一讲所说的“脏”的 Cache Block。Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面。而所谓的“已失效“，自然是这个 Cache Block 里面的数据已经失效了，我们不可以相信这个 Cache Block 里面的数据。<br>然后，我们再来看“独占”和“共享”这两个状态。这就是 MESI 协议的精华所在了。无论是独占状态还是共享状态，缓存里面的数据都是“干净”的。这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，Cache Block 里面的数据和主内存里面的数据是一致的。<br>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，在独占状态下，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。<br>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，它就会变成共享状态。这个共享状态是因为，这个时候，另外一个 CPU 核心，也把对应的 Cache Block，从内存里面加载到了自己的 Cache 里来。<br>而在共享状态下，因为同样的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，都变成无效的状态，然后再更新当前 Cache 里面的数据。这个广播操作，一般叫作 RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权。<br>有没有觉得这个操作有点儿像我们在多线程里面用到的读写锁。在共享状态下，大家都可以并行去读对应的数据。但是如果要写，我们就需要通过一个锁，获取当前写入位置的所有权。<br>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。<br><img src="/img/content/lock/mesi.png" alt="mesi.png"></p><h4 id="Java线程可见性"><a href="#Java线程可见性" class="headerlink" title="Java线程可见性"></a>Java线程可见性</h4><p><img src="/img/content/lock/%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98.png" alt="线程内存.png"><br>先介绍一下Java内存模型中定义的8种工作内存与主内存之间的原子操作</p><ul><li>lock( 锁定 )：作用于主内存的变量，把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，把一个处于锁定的变量释放出来，释放变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存种的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的值放入主内存的变量中。</li></ul><p>volatile变量对对象的操作有严格要求：</p><ul><li>use之前不能被read&amp;load</li><li>assign之后必须紧跟store&amp;write</li></ul><p><strong>也就是说 read-load-use 和 assign-store-write成为了两个不可分割的原子操作。这样就保证了assign的值会直接写到主存中。</strong><br><img src="/img/content/lock/volatile%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt="volatile可见性.png"><br>尽管这时候在use和assign之间依然有一段真空期，有可能变量会被其他线程读取，但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如自增。 那么依靠可见性的特点volatile可以用在哪些地方呢？ 《Java虚拟机》提到：<br>运算结果并不依赖变量的当前值（即结果对产生中间结果不依赖），或者能够确保只有单一的线程修改变量的值<br>通常volatile用做保存某个状态的boolean值。</p><h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><h4 id="硬件层面支持指令原子性安全"><a href="#硬件层面支持指令原子性安全" class="headerlink" title="硬件层面支持指令原子性安全"></a>硬件层面支持指令原子性安全</h4><p>在单核的时候，我们提到的原子性指令都是安全的，但是在多核并行的时候，就不再安全了。在并行 - 原子操作那节，我们用 cmpxchg 做为示例说明了原子指令的不安全。<br>所以原子性解决方案里面，第一步就是如何把那些 CPU 的原子性指令变得安全。因为这些指令不安全，那到底是用不是不用呢？不用感觉可惜，他们是很强大的指令，用吧就不安全。所以这个问题必须要解决。<br>解决原子性问题的方案有两种，一种是 Bus 总线锁，一种是高速缓存行锁。但具体使用那个锁，是由硬件决定的，我们要做的仅仅是加锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// xchg 内存交换指令<br><br>*lock = 0;<br>mov ax, 1;<br><br>void threads(void) &#123;<br>  __asm__ __volatile__  <span class="hljs-string">&quot;lock; xchg ax, &amp;lock&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的 volatile 是为了防止编译器优化，为了防止有序性和可见性问题。lock 则是 xchg 的锁。<br>如果是总线锁，则 core0 开始执行 xchg 的时候，会将整个 bus 总线锁住，其他的任何总线操作都不允许执行。这样的性能开销非常大，所以出现了缓存锁。<br>缓存锁即对于 &amp;lock 的缓存行加锁。如果 core0 加了缓存锁，那么其他核在访问 &amp;lock 的时候，因为不同的高速缓存的 &amp;lock 缓存行均被锁住，所以其他核心无法执行。只有当 core0 的 xchg 指令执行完毕，解开了缓存锁，其他指令才会继续执行下去。<br>所以通过总线锁或者缓存锁，就可以使得 xchg 和 cmpxchg 这些原子指令在多核并行场景下也能够正常执行。</p><h5 id="总线锁还是缓存锁"><a href="#总线锁还是缓存锁" class="headerlink" title="总线锁还是缓存锁"></a>总线锁还是缓存锁</h5><p>x86汇编中，如果对一个指令加“lock”前缀，对于Lock指令区分两种实现方法。对于早期的CPU，总是采用的是锁总线的方式。具体方法是，一旦遇到了Lock指令，就由仲裁器选择一个核心独占总线。其余的CPU核心不能再通过总线与内存通讯。从而达到“原子性”的目的。<br>具体做法是，某一个核心触发总线的“Lock#”那根线，让总线仲裁器工作，把总线完全分给某个核心。<br>这种方式的确能解决问题，但是非常不高效。为了个原子性结果搞得其他CPU都不能干活了。因此从Intel P6 CPU开始就做了一个优化，改用Ringbus + MESI协议，也就是文档里说的cache conherence机制。这种技术被Intel称为“Cache Locking”。<br>根据文档原文：如果是P6后的CPU，并且数据已经被CPU缓存了，并且是要写回到主存的，则可以用cache locking处理问题。否则还是得锁总线。因此，lock到底用锁总线，还是用cache locking，完全是看当时的情况。当然能用后者的就肯定用后者。<br>Intel P6是Intel第6代架构的CPU，其实也很老了，差不多1995年出的…… 比如Pentium Pro，Pentium II，Pentium III都隶属于P6架构。</p><h4 id="Java原子性安全"><a href="#Java原子性安全" class="headerlink" title="Java原子性安全"></a>Java原子性安全</h4><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>我们通过 Java 中的 AtomicInteger类中的 getAndIncrement()来看下 CAS 底层是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它是调用的Unsafe类的getAndAddInt方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">do</span> &#123;<br>        value= <span class="hljs-built_in">this</span>.getIntVolatile(obj, offset);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(obj, offset, value, value + delta));<br><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到该方法内部是先获取到该对象的偏移量对应的值(value)，然后调用 compareAndSwapInt 方法通过对比来修改该值，如果这个值和value一样，说明此过程中间没有 人修改该数据，此时可以将该地址的值改为 value+delta, 返回true,结束循环。否则，说明有人修改该地址处的值，返回false，继续下一次循环。 那么是怎么保证 compareAndSwapInt(CAS)的原子性呢？这个就由操作系统底层来提供了，要不然就无限套娃了。<br>compareAndSwapInt 是一个 native 方法， 我们看下 Hotspot 源码中 对 compareAndSwapInt的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  UnsafeWrapper(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  <span class="hljs-type">oop</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> JNIHandles::resolve(obj);<br>  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);<br>  <span class="hljs-keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;<br>UNSAFE_END<br></code></pre></td></tr></table></figure><p>可以看到这里最后调用了Atomic::cmpxchg方法，我们来看下linux下atomic_linux_x86.inline.hpp这个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">inline jint  Atomic::cmpxchg    (jint     exchange_value, <span class="hljs-keyword">volatile</span> jint*     dest, jint     compare_value) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mp</span> <span class="hljs-operator">=</span> os::is_MP();<br>        __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>)</span> <span class="hljs-string">&quot;cmpxchgl %1,(%3)&quot;</span><br>        : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)<br>        : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp) <span class="hljs-comment">// 入参</span><br>        : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>);<br>        <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure><p>is_MP() 是判断是否有多个CPU，如果是多个CPU返回1，单个CPU返回0<br>可以看下 LOCK_IF_MP 方法， LOCK_IF_MP(%4) 入参是第四个参数，<br>“r” (exchange_value),// 第一个参数<br>“a” (compare_value), // 第二个参数<br>“r” (dest), // 第三个参数<br>“r” (mp) // 第四个参数<br>#define LOCK_IF_MP(mp) “cmp $0, “ #mp “; je 1f; lock; 1: “<br>可以看到 如果 mp 不为0，这里加了 lock 指令，根据CPU不同，lock 指令会对总线或者缓存加锁，其他CPU的请求将被阻塞，当前CPU是可以独占共享内存的。<br>CAS虽然很高效地解决了原子操作，但是CAS仍然存在三 大问题。ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作。 </p><ol><li>ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化 则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它 的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面 追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。从 Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个 类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是 否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li><li>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第 一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间 取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候 因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而 提高CPU的执行效率。</li><li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作<h2 id="单机锁机制"><a href="#单机锁机制" class="headerlink" title="单机锁机制"></a>单机锁机制</h2><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3>在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 1 修饰非静态方法</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 临界区</span><br>    &#125;<br>    <span class="hljs-comment">// 2 修饰非静态方法</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 临界区</span><br>    &#125;<br>    <span class="hljs-comment">// 3 修饰非静态方法</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 临界区</span><br>    &#125;<br>    <span class="hljs-comment">// 4 修饰静态方法</span><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 临界区</span><br>    &#125;<br>    <span class="hljs-comment">// 5 修饰代码块</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()；<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">baz</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(obj) &#123;<br>            <span class="hljs-comment">// 临界区</span><br>        &#125;<br>    &#125;<br>&#125;  <br><br></code></pre></td></tr></table></figure>上面总共定义了三把锁，分别保护三个资源。 1、2、3 是同一把锁，保护当前 Person 的每一个实例对象。 4 是一把锁，保护当前 Person.class 类。5 也是一把锁，保护 obj 局部对象。<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4>自旋锁是其他锁的基石，基于内存交换指令的 CPU 原子性安全指令 lock; xchg 实现。xchg 和 lock 已经在 “单核 - xchg 原子操作” 和 “原子性解决方案 - 硬件支持” 两趴说明过了。下面看看自旋锁如何实现。<br>自旋锁的原理是首先读取锁变量，判断其值是否已经加锁，如果未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续判断其值是否已经加锁不断循环，因而得名自旋锁。<br><img src="/img/content/lock/%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁.png"><br>使用自旋锁，会产生非常大的性能消耗。因为在没有拿到锁的时候，会一直循环尝试获取锁，会使得 CPU 的使用率飙升，但只要上一把锁还没有释放，飙升的 CPU 使用率都是徒劳的。<br>但是自旋锁却又是最高效的，因为下一把等待锁的线程一直在尝试加锁，所以只要上一把锁被释放，下一把锁就会立刻响应。<br>毫不夸张的说，除了硬件层面的 lock 锁，自旋锁的所有锁中效率最高的。因为其他锁都是依靠自旋锁不断加临界区的判断条件，不可能效率上比得过自旋锁。<br>所以，目前对于自旋锁的使用都很谨慎，主要是担心过大的性能消耗。比较好的办法呢，是即使用自旋锁的高效率，又让自旋锁仅仅执行非常少的时间，这样就可以低消耗、高性能的使用自旋锁。所以操作系统和高级语言就依靠以自旋锁为底层实现，依靠银弹 “中间层” 这个神器，群魔乱舞了。介绍其他妖魔之前，再说一下自旋锁的优先级反转问题。<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4>如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。<br>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。<br>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。<br>顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅_将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功_，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。<h3 id="Lock与AQS"><a href="#Lock与AQS" class="headerlink" title="Lock与AQS"></a>Lock与AQS</h3>Java的ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore等都是基于AQS来实现的。<br>AQS中 维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。<br>这里volatile能够保证多线程下的可见性，当state=1则代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个FIFO的等待队列中，比列会被UNSAFE.park()操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。<br>另外state的操作都是通过CAS来保证其并发修改的安全性。<br>具体原理我们可以用一张图来简单概括：<br><img src="/img/content/lock/aqs.png" alt="aqs.png"><br>AQS 中提供了很多关于锁的实现方法，</li></ol><ul><li>getState()：获取锁的标志 state 值</li><li>setState()：设置锁的标志 state 值</li><li>tryAcquire(int)：独占方式获取锁。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式释放锁。尝试释放资源，成功则返回 true，失败则返回 false。</li></ul><p>假设我们现在有三个线程，此时线程一抢占锁成功，线程二和线程三抢占锁失败，具体执行流程如下：<br><img src="/img/content/lock/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%8A%A2%E5%8D%A0.png" alt="三个线程抢占.png"><br>线程一抢占成功，AQS的state设置为1。线程二线程三加入到FIFO队列。此时AQS的内部数据为:<br><img src="/img/content/lock/AQS%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE.png" alt="AQS内部数据.png"><br>线程二、线程三加锁失败：<br><img src="/img/content/lock/%E7%BA%BF%E7%A8%8B%E4%BA%8C%E4%B8%89%E5%8A%A0%E9%94%81%E5%A4%B1%E8%B4%A5.png" alt="线程二三加锁失败.png"><br>线程一释放锁之后，唤醒Head的下一个节点，尝试加锁。这时如果有线程四过来也尝试加锁，并且加锁成功，则线程二等待了很久之后，却被线程四抢了先，这就是非公平锁。<br><img src="/img/content/lock/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="非公平锁.png"><br>那要实现公平锁，线程四尝试加锁之前会先判断FIFO队列中是否有等待线程。如果有的话则加入到FIFO队列中。<br><img src="/img/content/lock/%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="公平锁.png"></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h2><h3 id="使用-SETNX-指令"><a href="#使用-SETNX-指令" class="headerlink" title="使用 SETNX 指令"></a>使用 SETNX 指令</h3><p>最简单的加锁方式就是直接使用 Redis 的 SETNX 指令，该指令只在 key 不存在的情况下，将 key 的值设置为 value，若 key 已经存在，则 SETNX 命令不做任何动作。key 是锁的唯一标识，可以按照业务需要锁定的资源来命名。<br>比如在某商城的秒杀活动中对某一商品加锁，那么 key 可以设置为  lock_resource_id ，value 可以设置为任意值，在资源使用完成后，使用 DEL 删除该 key 对锁进行释放，整个过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">SETNX lock_resource_id lock_value #加锁<br><span class="hljs-keyword">do</span> something<br>DEL lock_resource_id #释放<br></code></pre></td></tr></table></figure><p>很显然，这种获取锁的方式很简单，但也存在一个问题，就是我们上面提到的分布式锁三个核心要素之一的锁超时问题，即如果获得锁的进程在业务逻辑处理过程中出现了异常，可能会导致 DEL 指令一直无法执行，导致锁无法释放，该资源将会永远被锁住。<br>所以，在使用 SETNX 拿到锁以后，必须给 key 设置一个过期时间，以保证即使没有被显式释放，在获取锁达到一定时间后也要自动释放，防止资源被长时间独占。由于 SETNX 不支持设置过期时间，所以需要额外的 EXPIRE 指令，整个过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SETNX lock_resource_id lock_value #加锁<br>EXPIRE lock_resource_id <span class="hljs-number">10</span><br><span class="hljs-keyword">do</span> something<br>DEL lock_resource_id<br></code></pre></td></tr></table></figure><p>这样实现的分布式锁仍然存在一个严重的问题，由于 SETNX 和 EXPIRE 这两个操作是非原子性的， 如果进程在执行 SETNX 和 EXPIRE 之间发生异常，SETNX 执行成功，但 EXPIRE 没有执行，导致这把锁变得“长生不老”，这种情况就可能出现前文提到的锁超时问题，其他进程无法正常获取锁。</p><h3 id="使用-SET-扩展指令"><a href="#使用-SET-扩展指令" class="headerlink" title="使用 SET 扩展指令"></a>使用 SET 扩展指令</h3><p>为了解决 SETNX 和 EXPIRE 两个操作非原子性的问题，可以使用 Redis 的 SET 指令的扩展参数，使得 SETNX 和 EXPIRE 这两个操作可以原子执行，整个过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">SET lock_resource_id lock_value NX EX <span class="hljs-number">10</span> #加锁<br><span class="hljs-keyword">do</span> something<br>DEL lock_resource_id<br></code></pre></td></tr></table></figure><p>但是这种方式仍然不能彻底解决分布式锁超时问题：</p><ul><li>锁被提前释放。假如线程 A 在加锁和释放锁之间的逻辑执行的时间过长（或者线程 A 执行过程中被堵塞），以至于超出了锁的过期时间后进行了释放，但线程 A 在临界区的逻辑还没有执行完，那么这时候线程 B 就可以提前重新获取这把锁，导致临界区代码不能严格的串行执行。</li><li>锁被误删。假如以上情形中的线程 A 执行完后，它并不知道此时的锁持有者是线程 B，线程 A 会继续执行 DEL 指令来释放锁，如果线程 B 在临界区的逻辑还没有执行完，线程 A 实际上释放了线程 B 的锁。</li></ul><p>为了避免以上情况，建议不要在执行时间过长的场景中使用 Redis 分布式锁，同时一个比较安全的做法是在执行 DEL 释放锁之前对锁进行判断，验证当前锁的持有者是否是自己。<br>具体实现就是在加锁时将 value 设置为一个唯一的随机数（或者线程 ID ），释放锁时先判断随机数是否一致，然后再执行释放操作，确保不会错误地释放其它线程持有的锁，除非是锁过期了被服务器自动释放，整个过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SET lock_resource_id lock_value NX EX <span class="hljs-number">10</span> #加锁<br><span class="hljs-keyword">do</span> something<br><span class="hljs-type">if</span> <span class="hljs-variable">random_value</span> <span class="hljs-operator">=</span>= lock_resource_id.value<br>DEL lock_resource_id<br></code></pre></td></tr></table></figure><p>但判断 value 和删除 key 是两个独立的操作，并不是原子性的，所以这个地方需要使用 Lua 脚本进行处理，因为 Lua 脚本可以保证连续多个指令的原子性执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] then<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure><p>基于 Redis 单节点的分布式锁基本完成了，但是这并不是一个完美的方案，只是相对完全一点，因为它并没有完全解决当前线程执行超时锁被提前释放后，其它线程乘虚而入的问题。</p><h3 id="使用-Redisson-的分布式锁"><a href="#使用-Redisson-的分布式锁" class="headerlink" title="使用 Redisson 的分布式锁"></a>使用 Redisson 的分布式锁</h3><p>怎么能解决锁被提前释放这个问题呢？<br>可以利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。<br>当然业务要实现这个守护进程的逻辑还是比较复杂的，可能还会出现一些未知的问题。<br>目前互联网公司在生产环境用的比较广泛的开源框架 Redisson 很好地解决了这个问题，非常的简便易用，且支持 Redis 单实例、Redis M-S、Redis Sentinel、Redis Cluster 等多种部署架构。<br><img src="/img/content/lock/redis%E7%9C%8B%E9%97%A8%E7%8B%97.png" alt="redis看门狗.png"></p><h2 id="ZooKeeper分布式锁机制"><a href="#ZooKeeper分布式锁机制" class="headerlink" title="ZooKeeper分布式锁机制"></a>ZooKeeper分布式锁机制</h2><p>zk里有一把锁，这个锁就是zk上的一个节点，假设有两个客户端，都要来获取这个锁，具体是怎么来获取呢？<br>咱们就假设客户端A抢先一步，对zk发起了加分布式锁的请求，这个加锁请求是用到了zk中的一个特殊的概念，叫做“临时顺序节点”。<br>简单来说，就是直接在”my_lock”这个锁节点下，创建一个顺序节点，这个顺序节点有zk内部自行维护的一个节点序号。<br>比如说，第一个客户端来搞一个顺序节点，zk内部会给起个名字叫做：xxx-000001。然后第二个客户端来搞一个顺序节点，zk可能会起个名字叫做：xxx-000002。大家注意一下，最后一个数字都是依次递增的，从1开始逐次递增。zk会维护这个顺序。<br>后来的客户端如果发现不是第一个客户端，会通过ZK的API对他的顺序节点的上一个顺序节点加一个监听器。zk天然就可以实现对某个节点的监听。<br>删除了节点之后，zk会负责通知监听这个节点的监听器，也就是下一个客户端加的那个监听器，说：兄弟，你监听的那个节点被删除了，有人释放了锁。<br>此时后一个客户端的监听器感知到了上一个顺序节点被删除，也就是排在他之前的某个客户端释放了锁。<br>此时，就会通知后一个客户端重新尝试去获取锁。<br><img src="/img/content/lock/zk%E5%8A%A0%E9%94%81.png" alt="zk加锁.png"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/AQS%20%E4%B8%87%E5%AD%97%E5%9B%BE%E6%96%87%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90.md">AQS 万字图文全面解析</a><br><a href="https://juejin.cn/post/6844903729406148622">七张图彻底讲清楚ZooKeeper分布式锁的实现原理</a><br><a href="https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce">浅析 Redis 分布式锁解决方案</a><br><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">CPU 缓存一致性</a><br><a href="https://www.yigegongjiang.com/2022/%E9%94%81%20-%20%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%8C%87%E2%86%91/#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93">锁 - 共享数据安全指↑</a><br><a href="https://www.mdnice.com/writing/11cc416644b44b42b0903e31c3dbdc70">CAS真的无锁吗</a><br><a href="https://cloud.tencent.com/developer/article/1707875">每日一个知识点：Volatile 和 CAS 的弊端之总线风暴原创</a><br><a href="https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html">聊聊CPU的LOCK指令</a><br><a href="https://zhuanlan.zhihu.com/p/45231073">Java并发编程-volatile可见性的介绍</a><br><a href="https://zhuanlan.zhihu.com/p/491092182">MESI协议：如何让多核CPU的高速缓存保持一致？</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>synchronized</tag>
      
      <tag>reentrantLock</tag>
      
      <tag>zookeeper</tag>
      
      <tag>mesi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存与零拷贝技术</title>
    <link href="/2023/06/01/%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/06/01/%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="CPU是怎么读取数据的"><a href="#CPU是怎么读取数据的" class="headerlink" title="CPU是怎么读取数据的"></a>CPU是怎么读取数据的</h2><p><img src="/img/content/ram/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="计算机工作原理.png"></p><h3 id="数据存在哪里"><a href="#数据存在哪里" class="headerlink" title="数据存在哪里"></a>数据存在哪里</h3><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>我们的程序和数据都是存储在内存，存储的区域是线性的。<br>在计算机数据存储中，存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。<br>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p><h3 id="CPU怎么找到数据"><a href="#CPU怎么找到数据" class="headerlink" title="CPU怎么找到数据"></a>CPU怎么找到数据</h3><p>现在常用的CPU有32位与64位两种，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p><ul><li>32 位 CPU 一次可以计算 4 个字节；</li><li>64 位 CPU 一次可以计算 8 个字节；</li></ul><p>这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。<br>之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 0~255 范围内的数值，这样就无法一次完成计算 10000 * 500 ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 4294967295。<br>CPU 内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。<br>CPU 中的寄存器主要作用是存储计算时的数据，你可能好奇为什么有了内存还需要寄存器？原因很简单，因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。<br>常见的寄存器种类：</p><ul><li><p><strong>通用寄存器</strong>:用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</p></li><li><p>**程序计数器:**用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。</p></li><li><p>**指令寄存器:**用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</p><h4 id="直接访问物理内存的弊端"><a href="#直接访问物理内存的弊端" class="headerlink" title="直接访问物理内存的弊端"></a>直接访问物理内存的弊端</h4><p>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。<br>单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。<br>另外，单片机的 CPU 是直接操作内存的「物理地址」。<br><img src="/img/content/ram/CPU%E8%AE%BF%E9%97%AE%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.png" alt="CPU访问物理内存.png"><br>在这种情况下，要想在内存中同时运行两个程序是不可能的。因为是直接操作物理内存，这就意味着一个程序可以操作内存中的所有地址，如果有恶意程序修改了其他程序在用的地址中的数据，这就可能导致其他程序崩溃。比如第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。<br><img src="/img/content/ram/%E7%9B%B4%E6%8E%A5%E8%AF%BB%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%86%B2%E7%AA%81.png" alt="直接读物理内存冲突.png"><br>另外，如何为每个程度指定内存地址空间来避免同时修改一处，这种模式下，必然要求程序员手动对数据进行布局，那么内存不够用怎么办呢？而且，每个进程分配多少内存、如何保证指令中访存地址的正确性，这些问题都全部要程序员来负责。这是难以忍受的。<br>基于局部性原理，CPU 为程序员虚拟化了一层内存，我们只需要与虚拟内存打交道就可以了。所以接下来，我们就来讨论局部性原理说的是什么，聪明的 CPU 设计人员又是如何将这个原理完美应用的。</p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>在绝大多数程序的运行过程中，当前指令大概率都会引用最近访问过的数据。也就是说，程序的数据访问会表现出明显的倾向性。这种倾向性，我们就称之为局部性原理 (Principle of locality)。我们可以从两个方面来理解局部性原理。<br>第一个方面是时间局部性，也就是说被访问过一次的内存位置很可能在不远的将来会被再次访问；另一方面是空间局部性，说的是如果一个内存位置被引用过，那么它邻近的位置在不远的将来也有很大概率会被访问。<br>基于这个原理，我们可以做出一个合理的推论：无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的。在这个推论的基础上，CPU 为每个进程只需要保留很少的物理内存就可以保证进程的正常执行了。<br>而且，为了让程序员编程方便，CPU 和操作系统还联手编织了一个假象：每个进程都独享 128T 的虚拟内存空间，并且每个进程的地址空间都是相互隔离的。什么意思呢？比如说，现在进程 A 中有个变量 a，它的地址是 0x100，但是进程 B 中也有个变量 b，它的地址也是 0x100。但这并不会造成冲突，因为进程 A 的地址空间与进程 B 的地址空间是独立的，相互不影响。</p><h4 id="虚拟内存与程序局部性原理"><a href="#虚拟内存与程序局部性原理" class="headerlink" title="虚拟内存与程序局部性原理"></a>虚拟内存与程序局部性原理</h4><p>CPU 充分利用程序局部性原理，提出了虚拟内存和物理内存的映射 (Mapping) 机制。<br>操作系统管理着这种映射关系，所以你在写代码的时候，就不用再操心物理内存的使用情况了，你看到的内存就是虚拟内存。这种映射关系是以页为单位的。<br>看看下面这张图就很好理解了，多个进程的虚拟内存中的页都被映射到物理内存页上。<br><img src="/img/content/ram/%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%BA%94.png" alt="虚拟空间与物理空间对应.png"><br>我们可以从图中看到这两点。第一，虽然虚拟内存提供了很大的空间，但实际上进程启动之后，这些空间并不是全部都能使用的。开发者必须要使用 malloc 等分配内存的接口才能将内存从待分配状态变成已分配状态。<br>在你得到一块虚拟内存以后，这块内存就是未映射状态，因为它并没有被映射到相应的物理内存，直到对该块内存进行读写时，操作系统才会真正地为它分配物理内存。然后这个页面才能成为正常页面。<br>第二，在虚拟内存中连续的页面，在物理内存中不必是连续的。只要维护好从虚拟内存页到物理内存页的映射关系，你就能正确地使用内存了。这种映射关系是操作系统通过页表来自动维护的，不必你操心。<br>不过你还要注意一点，计算机的虚拟内存大小是不一样的。虚拟地址空间往往与机器字宽有关系。例如 32 位机器上，指向内存的指针是 32 位的，所以它的虚拟地址空间是 2 的 32 次方，也就是 4G。在 64 位机器上，指向内存的指针就是 64 位的，但在 64 位系统里只使用了低 48 位，所以它的虚拟地址空间是 2 的 48 次方，也就是 256T。</p><h4 id="虚拟内存与物理内存的映射"><a href="#虚拟内存与物理内存的映射" class="headerlink" title="虚拟内存与物理内存的映射"></a>虚拟内存与物理内存的映射</h4><p>虚拟内存与物理内存映射的过程，是由 CPU 的内存管理单元 (Memory Management Unit, MMU) 自动完成的，但它依赖操作系统设置的页表。<br><img src="/img/content/ram/%E8%99%9A%E6%8B%9F%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E7%89%A9%E7%90%86.png" alt="虚拟页表映射物理.png"><br>页表的本质是页表项 (Page Table Entry, PTE) 的数组，一般一页大小是4k,一个页表项是4字节，一张表上1024个页表项。一个页表项对应一个实际的物理页，大小是4k,一张4k的页表就代表了4M大小的实际物理页<br>虚拟空间中的每一页在页表中都有一个页表项与之对应<br>页表项会记录虚拟页所对应的实际物理页的起始地址。<br><img src="/img/content/ram/pageDirectory.png" alt="pageDirectory.png"></p><h4 id="CPU怎么找到真实的物理地址"><a href="#CPU怎么找到真实的物理地址" class="headerlink" title="CPU怎么找到真实的物理地址"></a>CPU怎么找到真实的物理地址</h4><p>一个 CPU 要通过虚拟地址，找到物理地址需要几个步骤呢？大概是下面这四个。<br><img src="/img/content/ram/CPU%E6%89%BE%E5%AF%BB%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt="CPU找寻物理地址.png"><br>第一步是确定页目录基址。每个 CPU 都有一个页目录基址寄存器，最高级页表的基地址就存在这个寄存器里。在 X86 上，这个寄存器是 CR3。每一次计算物理地址时，MMU 都会从 CR3 寄存器中取出页目录所在的物理地址。<br>第二步是定位页目录项（PDE）。一个 32 位的虚拟地址可以拆成 10 位，10 位和 12 位三段，上一步找到的页目录表基址加上高 10 位的值乘以 4，就是页目录项的位置。这是因为，一个页目录项正好是 4 字节，所以 1024 个页目录项共占据 4096 字节，刚好组成一页，而 1024 个页目录项需要 10 位进行编码。这样，我们就可以通过最高 10 位找到该地址所对应的 PDE 了。<br>第三步是定位页表项（PTE）。页目录项里记录着页表的位置，CPU 通过页目录项找到页表的位置以后，再用中间 10 位计算页表中的偏移，可以找到该虚拟地址所对应的页表项了。页表项也是 4 字节的，所以一页之内刚好也是 1024 项，用 10 位进行编码。所以计算公式与上一步相似，用页表基址加上中间 10 位乘以 4，可以得到页表项的地址。最后一步是确定真实的物理地址。上一步 CPU 已经找到页表项了，这里存储着物理地址，这才真正找到该虚拟地址所对应的物理页。虚拟地址的低 12 位，刚好可以对一页内的所有字节进行编码，所以我们用低 12 位来代表页内偏移。计算的公式是物理页的地址直接加上低 12 位。<br>前面我们分析的是 32 位操作系统，那对于 64 位机器是不是有点不同呢？在 64 位的机器上，使用了 48 位的虚拟地址，所以它需要使用 4 级页表。它的结构与 32 位的 3 级页表是相似的，只是多了一级页目录，定位的过程也从 32 位的 4 步变成了 5 步。</p><h4 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h4><p>不过我们前面也说到，由于程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性。那对于那些没有被经常使用到的内存，我们可以把它换出到主存之外，比如硬盘上的 swap 区域。所谓 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。新的虚拟内存页可以被映射到刚腾出来的这个物理页。这就涉及到了页面换入换出的调度问题。我们举个例子来说明一下。假如进程 A 一开始将虚拟内存的 0 至 4K，映射到物理内存的 0 至 4K 空间。基于局部性原理，4K 以后的虚拟地址大概率是不会被访问的，我们可以让程序一直运行。直到程序开始访问 4K ~ 8K 之间的虚拟地址了，我们就可以将现在的物理地址里的内容换出到磁盘的 swap 区域，然后再将虚拟内存的 4K ~ 8K 这一个区域映射到 0~4K 的这一块物理内存。在理想情况下，虽然进程 A 的虚拟内存非常大，比如 256T，但 CPU 只需要一个 4K 大小的物理内存页就能满足它的需求了。当然在实际情况中肯定不会这么理想，所以一个进程所占用的物理内存不可能只有一个页。从效率的角度看，当物理内存足够时，操作系统也会尽量让尽可能多的页驻留在物理内存中。毕竟将内存中的数据写到磁盘里是非常耗时的操作。</p><h3 id="怎么读取数据"><a href="#怎么读取数据" class="headerlink" title="怎么读取数据"></a>怎么读取数据</h3><p>总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：</p></li><li><p><strong>地址总线:</strong> 用于指定 CPU 将要操作的内存地址；</p></li><li><p><strong>数据总线:</strong> 用于读写内存的数据；</p></li><li><p><strong>控制总线:</strong> 用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</p></li></ul><p>当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：</p><ul><li><p>首先要通过「地址总线」来指定内存的地址；</p></li><li><p>然后通过「控制总线」控制是读或写命令；</p></li><li><p>最后通过「数据总线」来传输数据；</p><h2 id="Linux与进程内存模型"><a href="#Linux与进程内存模型" class="headerlink" title="Linux与进程内存模型"></a>Linux与进程内存模型</h2><h3 id="抽像内存布局"><a href="#抽像内存布局" class="headerlink" title="抽像内存布局"></a>抽像内存布局</h3><p>我们知道，CPU 运行一个程序，实质就是在顺序执行该程序的机器码。一个程序的机器码会被组织到同一个地方，这个地方就是代码段。<br>另外，程序在运行过程中必然要操作数据。这其中，对于有初值的变量，它的初始值会存放在程序的二进制文件中，而且，这些数据部分也会被装载到内存中，即程序的数据段。数据段存放的是程序中已经初始化且不为 0 的全局变量和静态变量。<br>对于未初始化的全局变量和静态变量，因为编译器知道它们的初始值都是 0，因此便不需要再在程序的二进制映像中存放这么多 0 了，只需要记录他们的大小即可，这便是 BSS 段。BSS 段这个缩写名字是 Block Started by Symbol，但很多人可能更喜欢把它记作 Better Save Space 的缩写。<br>数据段和 BSS 段里存放的数据也只能是部分数据，主要是全局变量和静态变量，但程序在运行过程中，仍然需要记录大量的临时变量，以及运行时生成的变量，这里就需要新的内存区域了，即程序的堆空间跟栈空间。与代码段以及数据段不同的是，堆和栈并不是从磁盘中加载，它们都是由程序在运行的过程中申请，在程序运行结束后释放。<br>总的来说，一个程序想要运行起来所需要的几块基本内存区域：代码段、数据段、BSS 段、堆空间和栈空间。下面就是内存布局的示意图：<br><img src="/img/content/ram/%E6%8A%BD%E5%83%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="抽像内存布局.png"><br>除了上面所讲的基本内存区域外，现代应用程序中还会包含其他的一些内存区域，主要有以下几类：</p></li><li><p>存放加载的共享库的内存空间：如果一个进程依赖共享库，那对应的，该共享库的代码段、数据段、BSS 段也需要被加载到这个进程的地址空间中。</p></li><li><p>共享内存段：我们可以通过系统调用映射一块匿名区域作为共享内存，用来进行进程间通信。</p></li><li><p>内存映射文件：我们也可以将磁盘的文件映射到内存中，用来进行文件编辑或者是类似共享内存的方式进行进程通信。</p><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><h4 id="IA-32-机器上的-Linux-进程内存布局"><a href="#IA-32-机器上的-Linux-进程内存布局" class="headerlink" title="IA-32 机器上的 Linux 进程内存布局"></a>IA-32 机器上的 Linux 进程内存布局</h4><p>在 32 位机器上，每个进程都具有 4GB 的寻址能力。Linux 系统会默认将高地址的 1GB 空间分配给内核，剩余的低 3GB 是用户可以使用的用户空间。下图是 32 位机器上 Linux 进程的一个典型的内存布局。在实践中，我们可以通过cat /proc/pid/maps来查看某个进程的实际虚拟内存布局。<br><img src="/img/content/ram/32%E4%BD%8D%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="32位内存布局.png"></p><h4 id="Intel-64-机器上的-Linux-进程内存布局"><a href="#Intel-64-机器上的-Linux-进程内存布局" class="headerlink" title="Intel 64 机器上的 Linux 进程内存布局"></a>Intel 64 机器上的 Linux 进程内存布局</h4><p>目前的 64 系统下的寻址空间是 2^48，即 256TB。而且根据 canonical address 的划分，地址空间天然地被分割成两个区间，分别是 0x0 - 0x00007fffffffffff 和 0xffff800000000000 - 0xffffffffffffffff。这样就直接将低 128T 的空间划分为用户空间，高 128T 划分为内核空间。下面这张图展示了 Intel 64 机器上的 Linux 进程内存布局：<br><img src="/img/content/ram/64%E4%BD%8D%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="64位内存布局.png"><br>从图中你可以看到，在用户空间和内核空间之间有一个巨大的内存空洞。这块空间之所以用更深颜色来区分，是因为这块空间的不可访问是由 CPU 来保证的（这里的地址都不满足 Intel 64 的 Canonical form）。<br>对于 64 位的程序，你在查看 /proc/pid/maps 的过程中，会发现代码段跟数据段的中间还有一段不可以读写的保护段，它的作用也是防止程序在读写数据段的时候越界访问到代码段，这个保护段可以让越界访问行为直接崩溃，防止它继续往下运行。</p><h4 id="进程的内存模型"><a href="#进程的内存模型" class="headerlink" title="进程的内存模型"></a>进程的内存模型</h4><p>在 Linux 中，进程是我们非常熟悉的东东了，哪怕是只写过一天代码的人也都用过它。JVM就是一个进程。在 Linux 中，是用一个 task_struct 来实现 Linux 进程的。每一个进程都有一个进程 id 的概念。在 task_struct 中有两个相关的字段，分别是 pid 和 tgid。<br>对于用户进程来讲，内存描述符 mm_struct( mm 代表的是 memory descriptor)是非常核心的数据结构。整个进程的虚拟地址空间部分都是由它来表示的。<br>进程在运行的时候，在用户态其所需要的代码，全局变量数据，以及 mmap 内存映射等全部都是通过 mm_struct 来进行内存查找和寻址的。这个数据结构的定义位于 include/linux/mm_types.h 文件下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//file:include/linux/mm_types.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">mmap</span>;</span>  <span class="hljs-comment">/* list of VMAs */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">mm_rb</span>;</span><br><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;  <span class="hljs-comment">/* base of mmap area */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size;  <span class="hljs-comment">/* size of task vm space */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 start_code、end_code 分别指向代码段的开始与结尾、start_data 和 end_data 共同决定数据段的区域、start_brk 和 brk 中间是堆内存的位置、start_stack 是用户态堆栈的起始地址。整个 mm_struct 和地址空间、页表、物理内存的关系如下图。<br><img src="/img/content/ram/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="进程地址空间.png"></p><h4 id="网络包内核空间区域"><a href="#网络包内核空间区域" class="headerlink" title="网络包内核空间区域"></a>网络包内核空间区域</h4><p><img src="/img/content/ram/%E7%BD%91%E7%BB%9C%E5%88%B0%E5%8C%85%E5%86%85%E6%A0%B8.png" alt="网络包到内核"><br>对于一个网卡的结构，会有一根线缆连接到外面的世界。网卡会检查线缆上的电信号，并将电信号转换成packet。网卡会接入到一个主机上，主机会带有网卡的驱动软件。我们需要将网卡解码出来的packet传递给主机的内存，这样软件才能解析packet。<br>E1000网卡会监听网线上的电信号，但是当收到packet的时候，网卡内部并没有太多的缓存，所以网卡会直接将packet拷贝到主机的内存中，而内存中的packet会等待驱动来读取自己。所以，网卡需要事先知道它应该将packet拷贝到主机内存中的哪个位置。<br>当位于主机的驱动初始化网卡的时候，它会分配一定数量，例如16个1500字节长度的packet buffer，然后再创建一个16个指针的数组。就是ring buffer。为什么叫ring呢？因为在这个数组中，如果用到了最后一个buffer，下一次又会使用第一个buffer。主机上的驱动软件会告诉网卡DMA ring在内存中的地址，这样网卡就可以将packet拷贝到内存中的对应位置。<br>传输完成之后，网卡会将内部的记录的指针指向DMA ring的下一个位置，这样就可以拷贝下一个packet。<br>DMA把数据拷贝到ring buffer后，会发起一个硬中断通知CPU。CPU发起一个软中断，ksoftirqd进程处理软中断，将数据帧从ringbuffer上接下来，保存为一个skb。放到socket中。<br><img src="/img/content/ram/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8E%A5%E6%94%B6%E8%B7%AF%E5%BE%84.jpeg" alt="数据包接收路径.jpeg"></p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>深入理解Java虚拟机（第2版）》中的描述是下面这个样子的：<br><img src="/img/content/ram/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="jvm内存模型.jpg"><br>JVM的内存结构大概分为：</p></li><li><p>堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。</p></li><li><p>方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。</p></li><li><p>方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。</p></li><li><p>本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。</p></li><li><p>程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。</p><h2 id="JVM内存与进程内存对应关系"><a href="#JVM内存与进程内存对应关系" class="headerlink" title="JVM内存与进程内存对应关系"></a>JVM内存与进程内存对应关系</h2><p><img src="/img/content/ram/jvm%E5%86%85%E5%AD%98%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="jvm内存与进程内存对应关系.png"><br>未使用区是分配新内存空间的预备区域。对于普通进程来说，这个区域被可用于堆和栈空间的申请及释放，每次堆内存分配都会使用这个区 域，因此大小变动频繁；对于JVM进程来说，调整堆大小及线程栈时会使用该区域，而堆大小一般较少调整，因此大小相对稳定。操作系统会动态调整这个区域的 大小，并且这个区域通常并没有被分配实际的物理内存，只是允许进程在这个区域申请堆或栈空间。</p><h2 id="线程工作内存与主存"><a href="#线程工作内存与主存" class="headerlink" title="线程工作内存与主存"></a>线程工作内存与主存</h2><p>Java内存模型规定了所有的变量存储在JVM的<strong>主内存</strong>中。每条线程还有自己的<strong>工作内存</strong>（类比高速缓存）。线程工作内存中保存了被该线程使用到的变量的主内存副本拷贝，<strong>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</strong>。不同线程之间的工作内存也是相互独立的，<strong>线程间变量值传递均需要主内存完成</strong>。线程、主内存、工作内存之间的关系如下图所示：<br><img src="/img/content/ram/%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98.png" alt="线程内存.png"></p><h2 id="CPU计算缓存"><a href="#CPU计算缓存" class="headerlink" title="CPU计算缓存"></a>CPU计算缓存</h2><p><img src="/img/content/ram/CPU%E7%BC%93%E5%AD%98.png" alt="CPU缓存.png"><br>其实在286之前的时代的CPU本是没有缓存的，因为当时的CPU和内存速度差异没有现在这么大,CPU直接访问内存。但是到386时代，CPU和内存的速度不匹配了，第一次出现了缓存。而且最早的缓存并没有放在CPU模块里，而是放在主板上的。再往后CPU越来越快，现在CPU的速度比内存要快百倍以上，所以就逐步演化出了L1、L2、L3三级缓存结构，而且都集成到的CPU芯片里，以进一步提高访问速度。<br>L1最接近于CPU，速度也最快，但是容量最小。一般现代CPU的L1会分成两个，一个用来cache data，一个用来cache code，这是因为code和data的更新策略并不相同，而且因为CISC的变长指令，code cache要做特殊优化。 一般每个核都有自己独立的data L1和code L1。<br>越往下，速度越慢，容量越大。L2一般也可以做到每个核一个独立的。但是L3一般就是整颗CPU共享的了。<br>CPU进行计算时，先将数据加载到高速缓存中，不同的核加载到的高速缓存可能不一致。</p><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>如果在 JVM 内部执行 I/O 操作时，必须将数据拷贝到堆外内存，才能执行系统调用。<br>问题：为什么操作系统不能直接使用 JVM 堆内存进行 I/O 的读写呢？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">原因有二：<br>操作系统并不感知 <span class="hljs-keyword">JVM </span>的堆内存，而且 <span class="hljs-keyword">JVM </span>的内存布局与操作系统所分配的是不一样的，操作系统并不会按照 <span class="hljs-keyword">JVM </span>的行为来读写数据。<br>同一个对象的内存地址随着 <span class="hljs-keyword">JVM </span>GC 的执行可能会随时发生变化，例如 <span class="hljs-keyword">JVM </span>GC 的过程中会通过压缩来减少内存碎片，这就涉及对象移动的问题了。<br></code></pre></td></tr></table></figure><p>平时开发时，会使用 NIO 的 DirectBuffer 来创建堆外内存。DirectBuffer底层是使用mmap来实现的。<br>前面我们介绍进程时说过进程的地址空间结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> * <span class="hljs-title">mmap</span>;</span>  <span class="hljs-comment">/* list of VMAs */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">mm_rb</span>;</span><br><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;  <span class="hljs-comment">/* base of mmap area */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> task_size;  <span class="hljs-comment">/* size of task vm space */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中mmap对应了一个mmap区域。<br>mmap 系统调用可以将用户空间的虚拟内存地址与文件进行映射（绑定），对映射后的虚拟内存地址进行读写操作就如同对文件进行读写操作一样。原理如图 2 所示：<br><img src="/img/content/ram/mmap.png" alt="mmap.png"><br>当多个进程映射到同一个文件地址，那么，可以实现进程间数据共享。</p><h2 id="内存总结"><a href="#内存总结" class="headerlink" title="内存总结"></a>内存总结</h2><p><img src="/img/content/ram/%E5%86%85%E5%AD%98%E5%85%A8%E6%99%AF%E5%9B%BE.png" alt="内存全景图.png"></p><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。<br>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。<br>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">read</span>(file, tmp_buf, <span class="hljs-built_in">len</span>);<br><span class="hljs-built_in">write</span>(socket, tmp_buf, <span class="hljs-built_in">len</span>);<br></code></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。<br><img src="/img/content/ram/%E9%9D%9E%E9%9B%B6%E6%8B%B7%E8%B4%9D.jpg" alt="非零拷贝.jpg"><br>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。<br>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。<br>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p></li><li><p>_第一次拷贝_，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</p></li><li><p>_第二次拷贝_，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</p></li><li><p>_第三次拷贝_，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</p></li><li><p>_第四次拷贝_，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</p></li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。<br>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><h3 id="如何实现零拷贝"><a href="#如何实现零拷贝" class="headerlink" title="如何实现零拷贝"></a>如何实现零拷贝</h3><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li>mmap + write</li><li>sendfile</li></ul><p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><p>在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">buf = mmap(file, len);<br>write(sockfd, buf, len);<br></code></pre></td></tr></table></figure><p>mmap() 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。<br><img src="/img/content/ram/mma_write.jpg" alt="mma_write.jpg"><br>具体过程如下：</p><ul><li>应用进程调用了 mmap() 后，应用进程跟操作系统内核「共享」这个缓冲区；在用户空间中的修改都会反应中内核缓冲区中。数据没必要拷贝到用户空间中。</li><li>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。<br>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。<br>首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。<br>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：<br><img src="/img/content/ram/sendfile.jpg" alt="sendfile.jpg"><br>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（_The Scatter-Gather Direct Memory Access_）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。<br>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ethtool -k eth0 | grep <span class="hljs-keyword">scatter</span>-gather<br><span class="hljs-keyword">scatter</span>-gather: <span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure><p>于是，从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：<br><img src="/img/content/ram/sendfile_scanner.jpg" alt="sendfile_scanner.jpg"><br>这就是所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。。<br>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。<br>所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。</p><h2 id="中间件零拷贝案例"><a href="#中间件零拷贝案例" class="headerlink" title="中间件零拷贝案例"></a>中间件零拷贝案例</h2><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>介绍完传统 Linux 的零拷贝技术之后，我们再来学习下 Netty 中的零拷贝如何实现。Netty 中的零拷贝和传统 Linux 的零拷贝不太一样。Netty 中的零拷贝技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：</p><ul><li>堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。</li><li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li><li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li><li>ByteBuf.slice 操作与 Unpooled.wrappedBuffer 相反，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li><li>Netty 使用 FileRegion 实现文件传输，FileRegion 底层封装了 FileChannel#transferTo() 方法，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝，这属于操作系统级别的零拷贝。<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3>Kafka 中存在大量的网络数据持久化到磁盘（Producer 到 Broker）和磁盘文件通过网络发送（Broker 到 Consumer）的过程。这一过程的性能直接影响 Kafka 的整体吞吐量。<br>我们把 Kafka 的生产和消费简化成如下两个过程来看[2]：</li></ul><ol><li>网络数据持久化到磁盘 (Producer 到 Broker)</li><li>磁盘文件通过网络发送（Broker 到 Consumer）<h4 id="网络数据持久化到磁盘-Producer-到-Broker"><a href="#网络数据持久化到磁盘-Producer-到-Broker" class="headerlink" title="网络数据持久化到磁盘 (Producer 到 Broker)"></a>网络数据持久化到磁盘 (Producer 到 Broker)</h4>对于 kafka 来说，Producer 生产的数据存到 broker，这个过程读取到 socket buffer 的网络数据，其实可以直接在内核空间完成落盘。并没有必要将 socket buffer 的网络数据，读取到应用进程缓冲区；在这里应用进程缓冲区其实就是 broker，broker 收到生产者的数据，就是为了持久化。<br>在此特殊场景下：接收来自 socket buffer 的网络数据，应用进程不需要中间处理、直接进行持久化时。可以使用 mmap 内存文件映射。<br>它的工作原理是直接利用操作系统的 Page 来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上。<br>使用这种方式可以获取很大的 I/O 提升，省去了用户空间到内核空间复制的开销。<br>mmap 也有一个很明显的缺陷——不可靠，写到 mmap 中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。Kafka 提供了一个参数——producer.type 来控制是不是主动 flush；如果 Kafka 写入到 mmap 之后就立即 flush 然后再返回 Producer 叫同步(sync)；写入 mmap 之后立即返回 Producer 不调用 flush 就叫异步(async)，默认是 sync。<h4 id="磁盘文件通过网络发送（Broker-到-Consumer）"><a href="#磁盘文件通过网络发送（Broker-到-Consumer）" class="headerlink" title="磁盘文件通过网络发送（Broker 到 Consumer）"></a>磁盘文件通过网络发送（Broker 到 Consumer）</h4>Kafka 采用的方案是通过 NIO 的 transferTo/transferFrom 调用操作系统的 sendfile 实现零拷贝，与Netty一致。<br>sendfile 系统调用，提供了零拷贝。数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer，无需 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件 - 网络发送由一个 sendfile 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3>Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">http &#123;<br>...<br>sendfile on<br>...<br>&#125;<br></code></pre></td></tr></table></figure>sendfile 配置的具体意思:</li></ol><ul><li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li><li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li></ul><p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>Kafka</tag>
      
      <tag>Nginx</tag>
      
      <tag>MMAP</tag>
      
      <tag>SendFile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表与红黑树</title>
    <link href="/2023/05/25/%E8%B7%B3%E8%A1%A8%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2023/05/25/%E8%B7%B3%E8%A1%A8%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>假设我们有某个班级所有学生的数学成绩，需要设计一个系统，可以满足以下几个操作<br>1.统计、查询区间范围。(统计80到90分的学生个数、查询90分到100分的学生名单)<br>2.查询单个学生成绩<br>3.学生成绩会频繁的更新与添加<br>4.满足高性能读取这些需求。<br>我们知道，Redis 的 zset 结构无疑是比较好的选择。Redis 提供了丰富的 API。示例：<br><img src="/img/content/rb/redis1.png" alt="存储学生成绩"><br>以 math 为 key 分别存储了 studentA 到 studentE 共计 5 名学生的分数，我们可以查询任一学生的成绩<br><img src="/img/content/rb/redis2.png" alt="查询任一学生的成绩"><br>以升序查询成绩落后的学生<br><img src="/img/content/rb/redis3.png" alt="查询成绩落后的学生"><br>按分数查询学生成绩<br><img src="/img/content/rb/redis4.png" alt="按分数查询学生"><br>统计分数区间的学生人数。<br><img src="/img/content/rb/redis5.png" alt="统计分数区间的学生人数"><br>倘若我们不用Redis的zset。单从数据结构上来讲。在数据量比较大的情况下:<br>1.统计、查询区间范围，我们知道，排序好的链表是一个比较的好选择，但要借助于索引，比如Mysql B+树底层链表加索引结构。<br>2.查询单个学生成绩，数组是一个查询比较快的结构，效率为O(1)，但数组只能以下标查询，我们知道学生名字是字符串，所以map是一个比较好的查询结构，效率为O(1)。平衡二叉树是次选。<br>3.学生成绩会频繁的更新与添加,对于频繁的更新与添加，我们知道，链表是一个比较好的选择。同时，平衡二叉树是次选。<br>分析完了，我们可以得到，我们需要一个map来进行单个元素定位。同时我们需要一个链表来进行范围查询与频繁更新。同时，我们需要为链表建立一个优秀的索引。Redis就是这么做的。当然，当数据量比较小的情况下，遍历的效率其实也是可观的。这时，内存优化属于比较重要的点。</p><h1 id="Redis-zset数据结构"><a href="#Redis-zset数据结构" class="headerlink" title="Redis zset数据结构"></a>Redis zset数据结构</h1><p>我们从zadd来看数据是怎么存储的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">zsetAdd</span><span class="hljs-params">(robj *zobj, <span class="hljs-type">double</span> score, sds ele, <span class="hljs-type">int</span> in_flags, <span class="hljs-type">int</span> *out_flags, <span class="hljs-type">double</span> *newscore)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Update the sorted set according to its encoding. */</span><br>    <span class="hljs-keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;<br>        zset *zs = zobj-&gt;ptr;<br>        zskiplistNode *znode;<br>        dictEntry *de;<br><br>        de = dictFind(zs-&gt;dict,ele);<br>        <span class="hljs-keyword">if</span> (de != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// 已经存在</span><br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xx) &#123;<br>            <span class="hljs-comment">// 不存在，插入</span><br>            ele = sdsdup(ele);<br>            znode = zslInsert(zs-&gt;zsl,score,ele);<br>            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);<br>            *out_flags |= ZADD_OUT_ADDED;<br>            <span class="hljs-keyword">if</span> (newscore) *newscore = score;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            *out_flags |= ZADD_OUT_NOP;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码中我们可以看到 zset 的底层实现，其实也是有两种，一种是ziplist，一种是skiplist，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist，两个条件如下：</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ul><p>ziplist我们暂时不谈，先聊一下zset。</p><h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><p><img src="/img/content/rb/zset.png" alt="zset结构图"><br>zset 对象在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。<br>zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a>什么是跳表</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。<br><img src="/img/content/rb/skiplist1.png" alt="单链表"><br>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作<strong>索引</strong>或<strong>索引层</strong>。<br><img src="/img/content/rb/skiplist2.png" alt="跳表第一级索引"><br>如果我们现在要查找某个结点，比如 22。我们可以先在索引层遍历，当遍历到索引层中值为 19 的结点时，我们发现下一个结点是 26，那要查找的结点 22 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 1个结点，就可以找到值等于 22 的这个结点了。这样，原来如果要查找 22，需要遍历 5 个结点，现在只需要遍历 3 个结点。<br>从这个例子里，我们看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。那如果我们再加一级索引呢？效率会不会提升更多呢？<br><img src="/img/content/rb/skiplist3.png" alt="跳表第二级索引"><br>我举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让你能真切地感受索引提升查询效率。我画了一个包含 64 个结点的链表，按照前面讲的这种思路，建立了五级索引。<br><img src="/img/content/rb/skiplist%E7%B4%A2%E5%BC%95.jpg" alt="skiplist索引.jpg"><br>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后，查找效率的提升就会非常明显。<br>前面讲的<strong>这种链表加多级索引的结构，就是跳表</strong>。我通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰地知道，跳表确实是可以提高查询效率的。接下来，我会定量地分析一下，用跳表查询到底有多快。</p><h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>前面我讲过，算法的执行效率可以通过时间复杂度来度量，这里依旧可以用。我们知道，在一个单链表中查询某个数据的时间复杂度是 O(n)。那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？<br>这个时间复杂度的分析方法比较难想到。我把问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？<br>按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2k)。</strong><br>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。<br>那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，为什么是 3 呢？我来解释一下。<br>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。<br><img src="/img/content/rb/skiplist_search.jpg" alt="跳表查询"><br>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇？不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，也就是空间换时间的设计思路。</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。<br><img src="/img/content/rb/skiplist_node.jpg" alt="跳表所占空间"><br>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。那我们有没有办法降低索引占用的内存空间呢？我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，就不用那么多索引结点。通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。<br>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表长什么样子我想你应该已经很清楚了，它的查找操作我们刚才也讲过了。实际上，跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。<br>我们现在来看下， 如何在跳表中插入一个数据，以及它是如何做到 O(logn) 的时间复杂度的？<br>我们知道，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。<br>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。我画了一张图，你可以很清晰地看到插入的过程。<br><img src="/img/content/rb/add_del.jpg" alt="高效动态插入和删除"><br>好了，我们再来看删除操作。/img/content/rb/<br>如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。<br><img src="/img/content/rb/update.jpg" alt="索引动态更新"><br>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。<br>解决方法是通过随机函数来维护前面提到的“平衡性”。<br>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。<br><img src="/img/content/rb/insert.png" alt="跳表随机插入"></p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>从上面的分析我们知道，不管是查询，频繁更新。树结构都能有不错的性能。二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。而不理想的情况下树会退化成链表。<br>能保持好O(logn)的查找效率，就得实现平衡二叉查找树，让二叉树自旋转。平衡二叉查找树其实有很多，比如，AVL、Splay Tree（伸展树）、Treap（树堆）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树。<br>Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。<br>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。<br>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。<br>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p><h1 id="跳表、红黑树对比"><a href="#跳表、红黑树对比" class="headerlink" title="跳表、红黑树对比"></a>跳表、红黑树对比</h1><p>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表我们后面才会讲到，所以我们现在暂且忽略这部分。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li>插入一个数据；</li><li>删除一个数据；</li><li>查找一个数据；</li><li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；</li><li>迭代输出有序序列。</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。<br>对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。<br>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。<br>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
      <tag>红黑树</tag>
      
      <tag>Redis</tag>
      
      <tag>SkipList</tag>
      
      <tag>RedBlack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单点登录</title>
    <link href="/2023/05/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <url>/2023/05/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="登录态"><a href="#登录态" class="headerlink" title="登录态"></a>登录态</h1><p>大家都知道，HTTP是一个无状态的协议，我们站在服务器这一端，一个用户请求过来怎么判断他有没有登录呢？<br>在验证用户名和密码之后，我们可以发给客户端一个凭证(isLogin = true)，如果请求中有这个凭证，那么他就是登陆之后的用户。 cookie和session的区别在于，凭证的存储位置。换言之，如果凭证存储在客户端，那就是cookie。如果凭证存储在服务端，那就是session。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie其实是HTTP头部的一个字段，本质上可以存储任何信息，早年用于实现登录态，所以有了一层别的含义——客户端存储。把凭证存储到cookie中，每次浏览器的请求会自动带上cookie里的凭证，方便服务端校验，就像下面这样：<br><img src="/img/content/login/cookie.png" alt="cookie.png"><br>客户端请求调用<code>/login</code>接口，服务端验证通过后给客户端颁发的登录凭证<code>isLogin=true</code><br>但是这样面临的问题是：<br>用户本人可以通过修改document.cookie=”isLogin = true”伪造登陆凭证。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session本意是指客户端与服务器的会话状态，由于凭证存储到了服务端，后来也把这些存在服务端的信息称为session。<br>现在服务器决定自己维护登录状态，仅发给客户端一个key，然后在自己维护一个key-value表，如果请求中有key，并且在表中可以找到对应的value，则视为合法：<br><img src="/img/content/login/session.png" alt="session.png"><br>sessionid是一个会话的key，客户端请求调用<code>/login</code>接口服务器端生成一个session，有一个sessionid和它对应。tomcat生成的sessionid叫做jsessionid。<br>session在访问tomcat服务器HttpServletRequest的getSession(true)的时候创建，tomcat的ManagerBase类提供创建sessionid的方法：随机数+时间+jvmid；<br>存储在服务器的内存中，tomcat的StandardManager类将session存储在内存中，也可以持久化到file，数据库，memcache，redis等。<br>服务端将seesion-id返回到客户端，客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。<br>这样即使客户端自行修改了sessionID，在服务端那里没有对应的记录，也无法获取数据。<br>session是一个好的解决方案，但是他的问题是：如果存在多个服务器如负载均衡时，每个服务器的状态表必须同步，默认保存在内存中，负载均衡每分配到一个新机器就得重新登录。解决方法就是抽离出来统一管理，如使用Redis等服务。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>cookie方法不需要服务器存储，但是凭证容易被伪造，那有什么办法判断凭证是否伪造呢？<br>和HTTPS一样，我们可以使用签名的方式帮助服务器校验凭证。<br>JSON Web Token（简称JWT）是以JSON格式存储信息的Token，其结构图如下：<br><img src="/img/content/login/jwt.png" alt="jwt.png"><br>JWT由3部分构成：头部，负载和签名。<br>根据<a href="https://jwt.io/introduction/">官网介绍</a>：</p><ol><li>头部存储Token的类型和签名算法（上图中，类型是jwt，加密算法是HS256）</li><li>负载是Token要存储的信息（上图中，存储了用户姓名和昵称信息）</li><li>签名是由指定的算法，将转义后的头部和负载，加上密钥一同加密得到的。</li></ol><p>最后将这三部分用.号连接，就可以得到了一个Token了。<br>使用JWT维护登陆态，服务器不再需要维护状态表，他仅给客户端发送一个加密的数据token，每次请求都带上这个加密的数据，再解密验证是否合法即可。由于是加密的数据，即使用户可以修改，命中几率也很小。<br><img src="/img/content/login/token.png" alt="token.png"><br>客户端如何存储token呢？</p><ol><li>存在cookie中，虽然设置HttpOnly可以有效防止XSS攻击中token被窃取，但是也就意味着客户端无法获取token来设置CORS头部。</li><li>存在sessionStorage或者localStorage中，可以设置头部解决跨域资源共享问题，同时也可以防止CSRF，但是就需要考虑XSS的问题防止凭证泄露。<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1>举个场景，假设我们的系统被切割为N个部分：商城、论坛、直播、社交…… 如果用户每访问一个模块都要登录一次，那么用户将会疯掉， 为了优化用户体验，我们急需一套机制将这N个系统的认证授权互通共享，让用户在一个系统登录之后，便可以畅通无阻的访问其它所有系统。<br>单点登录——就是为了解决这个问题而生！<br>简而言之，单点登录可以做到：在多个互相信任的系统中，用户只需登录一次，就可以访问所有系统。<h2 id="共享cookie同步会话"><a href="#共享cookie同步会话" class="headerlink" title="共享cookie同步会话"></a>共享cookie同步会话</h2></li></ol><p>首先我们分析一下多个系统之间，为什么无法同步登录状态？</p><ol><li>前端的 Token 无法在多个系统下共享。</li><li>后端的 Session 无法在多个系统间共享。</li></ol><p>所以单点登录第一招，就是对症下药：</p><ol><li>使用 共享Cookie 来解决 Token 共享问题。</li><li>使用 Redis 来解决 Session 共享问题。</li></ol><p>所谓共享Cookie，就是主域名Cookie在二级域名下的共享，举个例子：写在父域名stp.com下的Cookie，在s1.stp.com、s2.stp.com等子域名都是可以共享访问的。<br><img src="/img/content/login/cookie-sso.gif" alt="cookie-sso.gif"></p><h2 id="URL重定向传播会话"><a href="#URL重定向传播会话" class="headerlink" title="URL重定向传播会话"></a>URL重定向传播会话</h2><p>如上，我们使用简单的步骤实现了同域下的单点登录，但这种模式有着一个不小的限制：</p><blockquote><p>所有子系统的域名，必须同属一个父级域名</p></blockquote><p>如果我们的子系统在完全不同的域名下，那么可以使用URL重定向传播会话。</p><p><img src="/img/content/login/url-sso.gif" alt="url-sso.gif"><br>1.用户在 子系统 点击 [登录] 按钮。<br>2.用户跳转到子系统登录接口 client1.com/sso/login，并携带 back参数 记录初始页面URL。<br>形如：<a href="http://client1.com/sso/login?back=xxx">http://client1.com/sso/login?back=xxx</a><br>3.子系统检测到此用户尚未登录(前端传过来的token,存储在cookie或者localstorage中，查看sso-Redis是否有token key,无则代表未登录)，再次将其重定向至SSO认证中心，并携带redirect参数记录子系统的登录页URL。<br>形如：<a href="http://server.com/sso/auth?redirect=xxx?back=xxx">http://server.com/sso/auth?redirect=xxx?back=xxx</a><br>4.用户进入了 SSO认证中心 的登录页面，开始登录。<a href="http://server.com/sso/auth?redirect=xxx?back=xxx">http://server.com/sso/auth?redirect=xxx?back=xxx</a><br>5.用户 输入账号密码 并 登录成功，SSO认证中心再次将用户重定向至子系统的登录接口/sso/login，并携带ticket码参数。<br>形如：<a href="http://client1.com/sso/login?back=xxx&ticket=xxxxxxxxx">http://client1.com/sso/login?back=xxx&amp;ticket=xxxxxxxxx</a><br>6.子系统根据 ticket码 从 SSO-Redis 中获取账号id，并在子系统登录此账号会话。<br>7.子系统将用户再次重定向至最初始的 back 页面。</p><p>用户登录client2.com/sso/login，在进行到第5步时，因为server.com cookie保存了token.所以不用再输入。</p><h3 id="前后端分离ticket登录"><a href="#前后端分离ticket登录" class="headerlink" title="前后端分离ticket登录"></a>前后端分离ticket登录</h3><p>前端react：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">20000</span>,<br>&#125;)<br><br>instance.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">post</span>[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] = <span class="hljs-string">&#x27;application/json&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加请求拦截器</span><br><span class="hljs-comment"> */</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;config:&quot;</span>, config)<br>  <span class="hljs-keyword">let</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;satoken&#x27;</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;token:&quot;</span>, token)<br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;satoken&#x27;</span>] = token<br>  &#125;<br>  <span class="hljs-keyword">return</span> config<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>&#125;)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从url中查询到指定名称的参数值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getParam</span>(<span class="hljs-params">name, defaultValue</span>) &#123;<br>  <span class="hljs-keyword">let</span> query = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">let</span> vars = query.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;vars.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">let</span> pair = vars[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>    <span class="hljs-keyword">if</span>(pair[<span class="hljs-number">0</span>] == name)&#123;<br>      <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (defaultValue == <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> :defaultValue);<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">doLogin</span> = (<span class="hljs-params">onlyTicket</span>)=&gt;&#123;<br>  <span class="hljs-keyword">let</span> baseUrl = <span class="hljs-string">&quot;http://server.zzmd.tech:9777&quot;</span><br>  <span class="hljs-keyword">let</span> back = <span class="hljs-title function_">getParam</span>(<span class="hljs-string">&quot;back&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>)<br>  <span class="hljs-keyword">let</span> ticket = <span class="hljs-title function_">getParam</span>(<span class="hljs-string">&quot;ticket&quot;</span>);<br>  <span class="hljs-keyword">if</span>(ticket)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">post</span>(baseUrl+<span class="hljs-string">&#x27;/sso/doLoginByTicket&#x27;</span>,&#123;<span class="hljs-attr">ticket</span>:ticket&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;satoken&quot;</span>, response);<br>      location.<span class="hljs-property">href</span>= <span class="hljs-built_in">decodeURIComponent</span>(back)<br>    &#125;)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>(!onlyTicket)&#123;<br>      <span class="hljs-comment">//重定向到登录中心</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">post</span>(baseUrl+<span class="hljs-string">&#x27;/sso/getSsoAuthUrl&#x27;</span>,&#123;<span class="hljs-attr">clientLoginUrl</span>:location.<span class="hljs-property">href</span>, <span class="hljs-attr">back</span>:location.<span class="hljs-property">href</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;auth url:&quot;</span>,response)<br>        location.<span class="hljs-property">href</span> = response;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加响应拦截器</span><br><span class="hljs-comment"> */</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response:&#x27;</span>, response)<br>  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">success</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功:&#x27;</span>, response)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>)<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;code:&#x27;</span>, response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span>, response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> == <span class="hljs-number">401</span>)<br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> == <span class="hljs-number">401</span>) &#123;<br>      <span class="hljs-title function_">doLogin</span>(<span class="hljs-literal">false</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span>)<br>    &#125;<br><br>  &#125;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败, 请刷新重试&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一封装Get请求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">get</span> = (<span class="hljs-params">url, params = &#123;&#125;, config = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">instance</span>(&#123;<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>      url,<br>      params,<br>      ...config<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(response)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(error)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一封装Post请求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">post</span> = (<span class="hljs-params">url, params = &#123;&#125;, config = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">instance</span>(&#123;<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>      url,<br>      params,<br>      ...config<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(response)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(error)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="Http请求获取会话"><a href="#Http请求获取会话" class="headerlink" title="Http请求获取会话"></a>Http请求获取会话</h2><p>我们先来分析一下，当后端不使用共享 Redis 时，会对架构产生哪些影响：</p><ol><li>Client 端无法直连 Redis 校验 ticket，取出账号id。</li><li>Client 端无法与 Server 端共用一套会话，需要自行维护子会话。</li><li>由于不是一套会话，所以无法“一次注销，全端下线”，需要额外编写代码完成单点注销。</li></ol><p>解决方案：校验ticket不使用共享redis，可以使用http或者rpc调用来进行校验。</p><h2 id="cors跨域"><a href="#cors跨域" class="headerlink" title="cors跨域"></a>cors跨域</h2><p>当客户端与服务端不在同一域中，需要进入跨域处理。<br>CORS 是一个 W3C 标准，全称叫做”跨域资源共享”（Cross-Origin resource sharing）； 在详细介绍 CORS 之前先简单介绍下什么是同源政策，这样才能了解到 CORS 的由来|必要性。</p><h3 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h3><p>“同源政策”是浏览器安全的基石，目前所有浏览器都实行这个政策<br>所谓”同源”，是指以下三个相同:</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><p>举个例子：</p><table><thead><tr><th>当前网址</th><th>被请求页面地址</th><th>是否跨域(不同源)</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://byj.zzmd.tech/page.html">http://byj.zzmd.tech/page.html</a></td><td><a href="http://byj.zzmd.tech/main.html">http://byj.zzmd.tech/main.html</a></td><td>否</td><td>同协议（http）、同域名（byj.zzmd.tech）、同端口（80）</td></tr><tr><td><a href="http://byj.zzmd.tech/page.html">http://byj.zzmd.tech/page.html</a></td><td><a href="https://byj.zzmd.tech/other.html">https://byj.zzmd.tech/other.html</a></td><td>是</td><td>协议不同（http 与 https）</td></tr><tr><td><a href="http://byj.zzmd.tech/page.html">http://byj.zzmd.tech/page.html</a></td><td><a href="http://byj.zzmd.com/page.html">http://byj.zzmd.com/page.html</a></td><td>是</td><td>域名不同,一个tech域名，一个com域名</td></tr><tr><td><a href="http://byj.zzmd.tech/page.html">http://byj.zzmd.tech/page.html</a></td><td><a href="http://byj.zzmd.tech:8090/other.html">http://byj.zzmd.tech:8090/other.html</a></td><td>是</td><td>端口不同（80 与 8090）</td></tr></tbody></table><h3 id="CORS-两类请求"><a href="#CORS-两类请求" class="headerlink" title="CORS 两类请求"></a>CORS 两类请求</h3><p>浏览器将 CORS 请求分为两类：<strong>简单请求</strong>和<strong>非简单请求</strong>。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求：</p><ul><li>请求方法是以下三种类型之一 <ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li>HTTP 头信息不超出以下几种字段 <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type: 只限于 application/x-www-form-urlencoded、multipart/form-data、text/plain 三者之一</li></ul></li></ul><p>凡是不同时满足以上两个条件的就属于非简单请求。<br>如下就是一个 CORS 简单请求：<br><img src="/img/content/login/cors-simple.png" alt="cors-simple.png"></p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段类型是 application/json。<br>非简单请求的 CORS 请求的一大特点，就是会在正式通信前增加一次 HTTP 查询请求，称为<a href="https://link.juejin.cn/?target=https://web.dev/cross-origin-resource-sharing/?utm_source=devtools%23preflight-requests-for-complex-http-calls">“预检”请求</a>（Preflight request）。该”预检”请求的方法为 OPTIONS，”预检”请求的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>如下是一个需要执行预检请求的 HTTP 请求：<br><img src="/img/content/login/cors-not-simple.png" alt="cors-not-simple.png"></p><h2 id="Spring-Boot-解决跨域问题"><a href="#Spring-Boot-解决跨域问题" class="headerlink" title="Spring Boot 解决跨域问题"></a>Spring Boot 解决跨域问题</h2><h3 id="通过-Filter-过滤器手动设置响应头"><a href="#通过-Filter-过滤器手动设置响应头" class="headerlink" title="通过 Filter 过滤器手动设置响应头"></a>通过 Filter 过滤器手动设置响应头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@Component</span><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-meta">@WebFilter(urlPatterns = &#123;&quot;/*&quot;&#125;, filterName = &quot;corsFilter&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>            log.info(<span class="hljs-string">&quot;启动跨域过滤器&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse resp, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>            <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) resp;<br>            <span class="hljs-comment">// 手动设置响应头解决跨域访问</span><br>            response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>            response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;POST, PUT, GET, OPTIONS, DELETE&quot;</span>);<br>            <span class="hljs-comment">// 设置过期时间</span><br>            response.setHeader(<span class="hljs-string">&quot;Access-Control-Max-Age&quot;</span>, <span class="hljs-string">&quot;86400&quot;</span>);<br>            response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;Origin, X-Requested-With, Content-Type, Accept, Authorization, uuid&quot;</span>);<br>            <span class="hljs-comment">// 支持 HTTP 1.1</span><br>            response.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache, no-store, must-revalidate&quot;</span>);<br>            <span class="hljs-comment">// 支持 HTTP 1.0. response.setHeader(&quot;Expires&quot;, &quot;0&quot;);</span><br>            response.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>            <span class="hljs-comment">// 编码</span><br>            response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            chain.doFilter(request, resp);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>            log.info(<span class="hljs-string">&quot;销毁跨域过滤器&quot;</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用-CrossOrigin-注解（局部跨域）"><a href="#使用-CrossOrigin-注解（局部跨域）" class="headerlink" title="使用 @CrossOrigin 注解（局部跨域）"></a>使用 @CrossOrigin 注解（局部跨域）</h3><p>@CrossOrigin 注解源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CrossOrigin &#123;<br>    <br>    <span class="hljs-meta">@AliasFor(&quot;origins&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] origins() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] allowedHeaders() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] exposedHeaders() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    RequestMethod[] methods() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String <span class="hljs-title function_">allowCredentials</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">maxAge</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1L</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用 @CrossOrigin 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin(origins = &quot;*&quot;, allowedHeaders = &quot;*&quot;, maxAge = 86400)</span><br><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>TODO..<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不过通过 @CrossOrigin 注解的源代码注定了它只能针对单个接口进行跨域配置，即局部跨域。虽然它比如上的 Filter 过滤器更简便，但这明显不是我们想要的，实际开发中也很少使用该注解。</p><h3 id="实现-WebMvcConfigurer-接口"><a href="#实现-WebMvcConfigurer-接口" class="headerlink" title="实现 WebMvcConfigurer 接口"></a>实现 WebMvcConfigurer 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>            <span class="hljs-comment">// 表明允许哪些域访问, 简单点可为 *</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:3000&quot;</span>)<br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>            <span class="hljs-comment">// allowCredentials(true): 表示附带身份凭证</span><br>            <span class="hljs-comment">// 一旦使用 allowCredentials(true) 方法，则 allowedOrigins(&quot;*&quot;) 需要指明特定的域，而不能是 *</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                .maxAge(<span class="hljs-number">86400</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上这种方式在没有定义拦截器（Interceptor）的时候，使用起来一切正常，但如果你有一个全局的拦截器，比如检测用户登录的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 从 http 请求头中取出 token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> httpServletRequest.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-comment">// 检查是否登录</span><br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidTokenException</span>(ResultCode.INVALID_TOKEN.getCode(), <span class="hljs-string">&quot;登录信息已过期，请重新登录&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当自定义拦截器返回 <strong>true</strong> 时，一切正常，但是当拦截器抛出异常（或者返回 <strong>false</strong>）时，后续的 CORS 配置将不会生效。</p><h3 id="注入-CorsFilter-过滤器"><a href="#注入-CorsFilter-过滤器" class="headerlink" title="注入 CorsFilter 过滤器"></a>注入 CorsFilter 过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsFilterConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建 CorsConfiguration 对象后添加配置</span><br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        <span class="hljs-comment">// 设置放行哪些原始域</span><br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 放行哪些原始请求头部信息</span><br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 放行哪些请求方法</span><br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-comment">// 添加映射路径</span><br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsConfiguration);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(source);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么过滤器可以避免冲突而拦截器不行呢？<br>因为过滤器依赖于 Servlet 容器，基于函数回调，它可以对几乎所有请求进行过滤。而拦截器是依赖于 Web 框架（如 Spring MVC 框架），基于反射通过 AOP 的方式实现的。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.cn/post/6844903844942446600">前端应该懂的登录态Cookie、Session、Token</a><br><a href="https://juejin.cn/post/7053753080176705573#heading-12">教你四招实现 CORS 跨域资源共享</a></p>]]></content>
    
    
    <categories>
      
      <category>应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cookie</tag>
      
      <tag>Session</tag>
      
      <tag>Token</tag>
      
      <tag>单点登录</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络系统与IO模型</title>
    <link href="/2023/05/10/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/05/10/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>这篇网络系统与IO模型的介绍，主要是基于Linux系统。讲解高并发情况下系统如何处理请求。还是照旧，我们从一个网络请求开始。</p><h1 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>            System.out.println(reader.readLine());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们刚学习Java网络编程时都会练习到的Java Server写法。同时配套的还有一个Client.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>        writer.write(<span class="hljs-string">&quot;Hello,World!&quot;</span>);<br>        writer.close();<br>        socket.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到，服务器端与客户端是通过socket来进行通信的。双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。<br>服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。<br>服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址和端口，绑定这两个的目的是什么？</p><ul><li>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</li></ul><p>绑定完 IP 地址和端口后，就可以调用 listen() 函数进行监听，此时对应 TCP 状态图中的 listen，如果我们要判定服务器中一个网络程序有没有启动，可以通过 netstat 命令查看对应的端口号是否有被监听。<br>服务端进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。<br>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 connect() 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/img/content/netio/TCP3.png" alt="TCP三次握手.png">)<br>TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p><ul><li><p>第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；</p></li><li><p>第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；</p></li><li><p>第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。</p><h2 id="半连接-全连接队列"><a href="#半连接-全连接队列" class="headerlink" title="半连接/全连接队列"></a>半连接/全连接队列</h2><p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p></li><li><p>一个是「还没完全建立」连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；</p></li><li><p>一个是「已经建立」连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态；</p></li></ul><p>当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。<br>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作监听 Socket；</li><li>一个叫作已连接 Socket；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 read() 和 write() 函数来读写数据。</p><h1 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h1><p>上面说到，我们建立了socket连接，通过一个已连接的socket来进行客户端与服务端之间的通信。我们再往底层追踪，计算机是靠网卡来在网络上传输数据的，那么我们从网卡接收数据开始，来描述下socket连接是如何传输数据的。</p><h2 id="网卡数据传输"><a href="#网卡数据传输" class="headerlink" title="网卡数据传输"></a>网卡数据传输</h2><p><img src="/img/content/netio/%E7%BD%91%E5%8D%A1%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE.jpg" alt="网卡接收数据.jpg"></p><p>上图展示了网卡接收数据的过程。</p><ul><li>在 ① 阶段，网卡收到网线传来的数据；</li><li>经过 ② 阶段的硬件电路的传输；</li><li>最终 ③ 阶段将数据写入到内存中的某个地址上。</li></ul><p>其中第3阶段，将数据写入内存中，其中涉及到了DMA技术。我们来详细说明下。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><h3 id="为什么要有-DMA-技术"><a href="#为什么要有-DMA-技术" class="headerlink" title="为什么要有 DMA 技术?"></a>为什么要有 DMA 技术?</h3><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p>下图说明没有DMA时候I/O全过程<br><img src="/img/content/netio/CPUIO%E8%BF%87%E7%A8%8B.png" alt="CPUIO过程.png"><br>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。<br>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。<br>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是直接内存访问（Direct Memory Access） 技术。</p><h3 id="什么是DMA"><a href="#什么是DMA" class="headerlink" title="什么是DMA"></a>什么是DMA</h3><p>什么是 DMA 技术？简单理解就是，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。<br>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。<br>![DMA I_O 过程.webp](/img/content/netio/DMA I_O 过程.webp)<br>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到， CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。<br>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。</p><h2 id="用户空间与内核空间-1"><a href="#用户空间与内核空间-1" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>从DMA过程中我们可以看到，数据是先拷贝到内核空间，再拷贝到用户空间的。那什么是内核空间与用户空间呢?<br>早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，如果程序不稳定常常把系统搞崩溃，比如清除操作系统的内存数据。后来觉得让应用程序随便访问内存太危险了，就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0~Ring3 (和电影分级有点像)，linux 只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。<br>我们知道操作系统采用的是虚拟地址空间，以32位操作系统举例，它的寻址空间为4G(2的32次方)，这里解释二个概念:</p><ol><li>寻址: 是指操作系统能找到的地址范围，32位指的是地址总线的位数，你就想象32位的二进制数，每一位可以是0，可以是1，是不是有2的32次方种可能，2^32次方就是可以访问到的最大内存空间，也就是4G。</li><li>虚拟地址空间：为什么叫虚拟，因为我们内存一共就4G，但操作系统为每一个进程都分配了4G的内存空间，这个内存空间实际是虚拟的，虚拟内存到真实内存有个映射关系。例如X86 cpu采用的段页式地址映射模型。</li></ol><p>操作系统将这4G可访问的内存空间分为二部分，一部分是内核空间，一部分是用户空间。<br>内核空间是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。<br>用户空间是普通应用程序可访问的内存区域。<br>以linux操作系统为例，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>从上文我们知道，一个请求过来，建立一个全连接的socket。服务端加载数据，先将数据加载到内核空间，再由内核拷贝到用户空间，最后通过socket返回。服务端加载数据过程如下。</p><ul><li>JVM向kernel发起system call read()</li><li>操作系统发生上下文切换，由用户态(User mode)切换到内核态(Kernel mode)，把数据读取到Kernel space buffer</li><li>Kernel把数据从Kernel space复制到User space，同时由内核态转为用户态。</li></ul><p>从上面可以看出一个I/O操作，<strong>通常</strong>而言会发生下面的事</p><ol><li>两次上下文切换(User mode 和 Kernel mode之间转换)</li><li>数据在Kernel space 和 User space之间复制</li></ol><p><img src="/img/content/netio/IO%E8%BF%87%E7%A8%8B.jpg" alt="IO过程.png"></p><h2 id="支持更多的请求"><a href="#支持更多的请求" class="headerlink" title="支持更多的请求"></a>支持更多的请求</h2><p>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。<br>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？<br>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：本机IP, 本机端口, 对端IP, 对端端口。<br>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以最大 TCP 连接数 = 客户端 IP 数×客户端端口数。<br>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数约为 2 的 48 次方。<br>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p><ul><li>文件描述符，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li>系统内存，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。<br>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。<br>其中Linux中的IO模型为 blocking I/O</p><h2 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h2><p><img src="/img/content/netio/bio.png" alt="bio.png"><br>上图是blocking I/O发起system call recvfrom()时，进程将一直阻塞等待另一端Socket的数据到来。在这种I/O模型下，我们不得不为每一个Socket都分配一个线程，这会造成很大的资源浪费。<br>Blocking I/O优缺点都非常明显。优点是简单易用，对于本地I/O而言性能很高。缺点是处理网络I/O时，造成进程阻塞空等，浪费资源。<br>注: read() 和 recvfrom()的区别是，前者从文件系统读取数据，后者从socket接收数据。<br>我们上述的例子就属于Blocking I/O，Java网络编程中叫作BIO.我们模拟IO的阻塞过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BlockInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>            System.out.println(<span class="hljs-string">&quot;正在从网络请求数据!等待10s&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.read(b, off, len);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockInputStream</span>(socket.getInputStream())));<br>            System.out.println(reader.readLine());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9989</span>);<br>            <span class="hljs-keyword">if</span> (socket.isConnected()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请求:&quot;</span>+i+<span class="hljs-string">&quot;连接成功!&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;请求:&quot;</span>+i+<span class="hljs-string">&quot;连接不成功!&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>            writer.write(<span class="hljs-string">&quot;请求:&quot;</span>+i+<span class="hljs-string">&quot;正在说:Hello,World!&quot;</span>);<br>            writer.close();<br>            socket.close();<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server</span><br>正在从网络请求数据!等待10s<br>正在从网络请求数据!等待10s<br>请求:<span class="hljs-number">0</span>正在说:Hello,World!<br>正在从网络请求数据!等待10s<br>正在从网络请求数据!等待10s<br>请求:<span class="hljs-number">1</span>正在说:Hello,World!<br><span class="hljs-comment">//Client</span><br>请求:<span class="hljs-number">0</span>连接成功!<br>请求:<span class="hljs-number">1</span>连接成功!<br></code></pre></td></tr></table></figure><p>可以看到，当IO阻塞的时候，请求并大量阻塞住，服务端只能一个一个进行处理。<br>这样的IO模型显然无法满足高并发的需求。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。<br>当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。<br>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。<br>那么，我们可以使用线程池的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。<br><img src="/img/content/netio/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.webp" alt="多线程模型.webp"><br>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。<br>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketHandler</span>(socket)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    Socket socket;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SocketHandler</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockInputStream</span>(<span class="hljs-built_in">this</span>.socket.getInputStream())));<br>            System.out.println(reader.readLine());<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Non-Blocking-I-O"><a href="#Non-Blocking-I-O" class="headerlink" title="Non-Blocking I/O"></a>Non-Blocking I/O</h2><p><img src="/img/content/netio/noblockingIO.png" alt="noblockingIO.png"><br>非阻塞I/O很容易理解。相对于阻塞I/O在那傻傻的等待，非阻塞I/O隔一段时间就发起system call看数据是否就绪(ready)。<br>如果数据就绪，就从kernel space复制到user space，操作数据; 如果还没就绪，kernel会立即返回EWOULDBLOCK这个错误。<br>可能细心的朋友会留意到，这里同样发起system call recvfrom，凭什么在blocking I/O会阻塞，而在这里kernel的数据还没就绪就直接返回EWOULDBLOCK呢？我们看看recvfrom函数定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>这里能看到recvfrom有个参数叫flags，默认情况下阻塞。可以设置flag为非阻塞让kernel在数据未就绪时直接返回。详细见<a href="https://linux.die.net/man/2/recvfrom">recvfrom</a>。<br>Non-blocking I/O的优势在于，进程发起I/O操作时，不会因为数据还没就绪而阻塞，这就是”非阻塞”的含义。<br>但这种I/O模型缺陷过于明显。在本地I/O，kernel读取数据很快，这种模式下多了至少一次system call，而system call是比较消耗cpu的操作。对于Socket而言，大量的system call更是这种模型显得很鸡肋。<br>Java IO中没有直接实现Non-blocking I/O的方法，可以使用 serverSocket.setSoTimeout(100)来进行模拟。</p><h2 id="I-O-Multiplexing"><a href="#I-O-Multiplexing" class="headerlink" title="I/O Multiplexing"></a>I/O Multiplexing</h2><p><img src="/img/content/netio/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="IO多路复用.png"><br>I/O Multiplexing又叫IO多路复用，这是借用了集成电路多路复用中的概念。它优化了非阻塞I/O大量发起system call的问题。<br>上面介绍的I/O模型都是直接发起I/O操作，而I/O Multiplexing首先向kernel发起system call，传入file descriptor和感兴趣的事件(readable、writable等)让kernel监测，当其中一个或多个fd数据就绪，就会返回结果。程序再发起真正的I/O操作recvfrom读取数据。<br>在linux中，有3种system call可以让内核监测file descriptors，分别是select、poll、epoll。<br>我们先看看内核是怎么监测file descriptors的。</p><h3 id="如何通知Socket已准备好"><a href="#如何通知Socket已准备好" class="headerlink" title="如何通知Socket已准备好"></a>如何通知Socket已准备好</h3><p>上面我们说到当网卡接收到数据时，由DMA来存入到内存中。那么数据存入内存中后，怎么通知到socket说数据已准备好了呢。我们来进一步看。<br><img src="/img/content/netio/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.png" alt="网络数据处理.png"><br>首先当数据帧从网线到达网卡上的时候，第一站是网卡的接收队列。网卡在分配给自己的RingBuffer中寻找可用的内存位置，找到后DMA引擎会把数据DMA到网卡之前关联的内存里，这个时候CPU都是无感的。当DMA操作完成以后，网卡会像CPU发起一个硬中断，通知CPU有数据到达。<br>有专门的内核线程 ksoftirqd进行软中断处理。每个 CPU 都会绑定一个 ksoftirqd 内核线程，比如， 2 个 CPU 时，就会有 ksoftirqd/0 和 ksoftirqd/1 这两个内核线程。<br>ksoftirqd内核线程处理软中断的时候，最后会经过网络协议栈处理。发现是 tcp 的包的话就会执行到 tcp_v4_rcv 函数。在 tcp_v4_rcv 中首先根据收到的网络包的 header 里的 source 和 dest 信息来在本机上查询对应的 socket。找到以后，直接进入接收的主体函数 tcp_v4_do_rcv 。tcp_v4_do_rcv进入 tcp_rcv_established 函数中进行处理 ESTABLISH 状态下的包。在 tcp_rcv_established 中通过调用 tcp_queue_rcv 函数中完成了将接收数据放到 socket 的接收队列上。<strong>调用 tcp_queue_rcv 接收完成之后，接着再调用 sk_data_ready 来唤醒在socket上等待的用户进程</strong>。 这又是一个函数指针。 回想上面我们在 创建 socket 流程里执行到的 sock_init_data 函数。它是默认的数据就绪处理函数。<br><img src="/img/content/netio/%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.png" alt="软中断处理.png"><br>在 sock_def_readable 中再一次访问到了 sock-&gt;sk_wq 下的wait。<br>总结一下，当有数据帧进入网卡的时候，DMA将数据拷贝到内存，网卡进行硬中断，CPU处理硬中断，发出软中断。内核线程ksoftirqd处理软中断，这时候socket已经可读了。触发下sock下的sock_def_readable事件，sock_def_readable访问sock-&gt;sk_wq进行处理。sk_wq中存的是fd poll添加回调函数，调用回调函数，可以进行一些处理，也可以唤醒调用线程。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。<br>所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。<br><img src="/img/content/netio/select%E8%BF%87%E7%A8%8B.gif" alt="select过程.gif"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>具体参考<a href="http://shengrang.net/2021/12/19/poll-note/">poll 笔记</a>，流程为</p><ol><li>do_select 初始化时，调用 poll_initwait 初始化 poll_wqueues(poll_table)，把 qproc 设置为 __pollwait</li><li>do_select 遍历 fd 时，调用 (*f_op-&gt;poll)(file, retval ? NULL : wait); ，这会调用 tcp_poll，传入的 wait 是 poll_wqueues(poll_table)</li><li>tcp_poll 里会调用 poll_wait(file, sk-&gt;sk_sleep, wait);</li><li>poll_wait 会调用 poll_table 注册的 qproc，即 __pollwait 函数</li><li>执行 __pollwait 函数</li><li>__pollwait 函数可以先看最后两行，初始化等待队列，把当前进程挂到 entry-&gt;wait 上，再把 entry-&gt;wait 挂到 sk-&gt;sk_sleep 这个等待队列上，结束。</li></ol><p>通过上面如何通知socket已准备好，我们知道数据包到达网卡，会经过内核网络协议栈，最终到达对应的 tcp 连接进行处理（ tcp_v4_rcv -&gt; tcp_v4_do_rcv ）。对于处于 ESTABLISHED 状态的连接，如果产生新的可读分组，那么会调用 sk-&gt;sk_data_ready。而 sock_init_data 初始化 sock 时会把 sk_data_ready 指向的函数设置为 sock_def_readable。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sock_def_readable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    read_lock(&amp;sk-&gt;sk_callback_lock);<br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_sleep &amp;&amp; waitqueue_active(sk-&gt;sk_sleep))<br>        wake_up_interruptible(sk-&gt;sk_sleep);<br>    sk_wake_async(sk,<span class="hljs-number">1</span>,POLL_IN);<br>    read_unlock(&amp;sk-&gt;sk_callback_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码也很好懂了，如果 sk_sleep 这个等待队列上有阻塞的进程，那么唤醒它（也就是前面在 do_select 遍历完 fd 之后陷入睡眠的进程）。这个进程被调度之后会重新进入 for(;;) 循环，开启新一轮的 fds 遍历，此时它能够在这个 tcp 连接对应的 fd 上 poll 到事件，从而离开循环，返回到用户态。<br>doSelect第一遍先将当前进程/线程挂载到 sk-&gt;sk_sleep上，当DAM将数据拷贝到socket缓冲区后，CPU发出软中断，sock_def_readable唤醒进程/线程,<br>唤醒进程/线程之后，循环继续，进程/线程查当前 tcp 连接的状态，并查看缓冲区的读写状态来确定是否产生了新的可读 / 可写事件，拼到 mask 里返回，do_select 就是读这个返回值来得知是否发生了事件。<br>select()函数的返回值有3种：若返回值大于0，表示已就绪文件描述符的数量，此种情况下某些文件可读写或有错误信息；若返回值等于0，表示等待超时，没有可读写或错误的文件；若返回值-1，表示出错返回，同时errno将被设置。</p><h4 id="select缺陷"><a href="#select缺陷" class="headerlink" title="select缺陷"></a>select缺陷</h4><p>[1] 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。<br>[2] 能监听端口的数量有限，单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264），首先我们打开Linux的fd_set数据结构的源码我们可以看到，就是一个长度为32的long int类型的数组(要注意，windows的源码和Linux的不一样)。每一位可以代表一个文件描述符，所以fd_set最多表示1024个文件描述符！这里为啥是1024个描述符呢？long int长度是32bit，数组长度是32，32*32=1024！当然我们可以对宏FD_SETSIZE进行修改，然后重新编译内核，但是性能可能会受到影响，一般该数和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认1024个，64位默认2048。<br>[3] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件：由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 通过两个方面，很好解决了 select/poll 的问题。<br>第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。<br>第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。<br><img src="/img/content/netio/epoll.webp" alt="epoll.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>具体实现可以看<a href="https://zhuanlan.zhihu.com/p/361750240">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a>与<a href="https://zhuanlan.zhihu.com/p/393747291">深入理解 Linux 的 epoll 机制</a>。上面我们知道，sock_def_readable回调poll中的回调函数p_poll_callback，在 ep_poll_callback 根据等待任务队列项上的额外的 base 指针可以找到 epitem， 进而也可以找到 eventpoll对象。<br>首先它做的第一件事就是<strong>把自己的 epitem 添加到 epoll 的就绪队列中</strong>。<br>接着它又会查看 eventpoll 对象上的等待队列里是否有等待项（epoll_wait 执行的时候会设置）。<br>如果没执行软中断的事情就做完了。如果有等待项，那就查找到等待项里设置的回调函数。调用 wake_up_locked() =&gt; __wake_up_locked() =&gt; __wake_up_common。在 __wake_up_common里， 调用 curr-&gt;func。 这里的 func 是在 epoll_wait 是传入的 default_wake_function 函数。在default_wake_function 中找到等待队列项里的进程描述符，然后唤醒之。<br><img src="/img/content/netio/epoll%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="epoll整体流程.png"></p><h2 id="Signal-Driven-I-O"><a href="#Signal-Driven-I-O" class="headerlink" title="Signal-Driven I/O"></a>Signal-Driven I/O</h2><p><img src="/img/content/netio/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8.png" alt="信号驱动.png"><br>这种信号驱动的I/O并不常见，从图片可以看到它第一次发起system call不会阻塞进程，kernel的数据就绪后会发送一个signal给进程。进程发起真正的IO操作。</p><h2 id="同步的概念"><a href="#同步的概念" class="headerlink" title="同步的概念"></a>同步的概念</h2><p>上面的Blocking IO,Non-Blocking I/O,I/O Multiplexing都属于同步IO。这里同步的概念主要是指获取数据时，由用户线程调用recvform将数据从内核空间拷贝到用户空间，从内核空间拷贝到用户空间不是由内核自动完成的。其中，Blocing IO是获取数据开始，就一直阻塞。Non-Blocking I/O是不断请求，请求到了再将数据从内核空间拷到用户空间。I/O Multiplexing是内核将数据复制到内核缓冲区【读取文件为pageCache,读取网络数据为socket缓冲区】之后，通知用户线程，用户线程调用recvform将数据从内核空间拷到用户空间。<br><img src="/img/content/netio/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.png" alt="同步异步.png"></p><h2 id="Asynchronous-I-O"><a href="#Asynchronous-I-O" class="headerlink" title="Asynchronous I/O"></a>Asynchronous I/O</h2><p><img src="/img/content/netio/%E5%BC%82%E6%AD%A5IO.png" alt="异步IO.png"></p><h3 id="绕过内核空间向用户空间复制的手段"><a href="#绕过内核空间向用户空间复制的手段" class="headerlink" title="绕过内核空间向用户空间复制的手段"></a>绕过内核空间向用户空间复制的手段</h3><p><img src="/img/content/netio/IO%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D.jpg" alt="IO数据拷贝.jpg"><br>从上文我们知道，同步是用户调用recv_from时，内核将数据从数据空间复制到用户空间。而异步就是用户直接发一个read的请求后就不管了，内核将数据准备好，拷贝到用户空间后再通知用户。但我们知道，之所以要recvfrom来获取数据，主要是当数据已经从网卡拷贝到内核缓冲区的时候，这时候并不知道该往哪个用户空间去拷贝。我们再来看一下recv_from函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数<a href="https://baike.baidu.com/item/buf/1057129?fromModule=lemma_inlink">buf</a>指向的<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/22010756?fromModule=lemma_inlink">内存空间</a>。回到异步上来，要想在没有地址的时候，就能将数据拷贝到用户空间，那么最简单的方法就是去掉内核空间或者共享内核空间与用户空间。上文我们说道，Linux分离内核空间跟用户空间的主要目的在于安全，而实现异步要打破这种设计。只能说是安全与效率之间的平衡。我们先来看绕到内核空间向用户空间复制数据的手段都有哪些。</p><h4 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h4><p>mmap 即 memory map，也就是内存映射。<br>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read、write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：<br><img src="/img/content/netio/mmp%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.png" alt="mmp基础概念.png"><br>mmap 也是一种零拷贝技术，其 I/O 模型如下图所示：<br><img src="/img/content/netio/mmap.jpg" alt="mmap.jpg"></p><h4 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h4><p>直接IO就是在应用层Buffer和磁盘之间直接建立通道。这样在读写数据的时候就能够减少上下文切换次数，同时也能够减少数据拷贝次数，从而提高效率。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>a、应用层直接操作磁盘减少了上下文切换和数据拷贝的开销，速度更快。<br>b、数据直接缓存在应用层，应用能够更加灵活的操作数据。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>a、系统基本不缓存数据，因此应用需要合理的读写数据，否则会导致性能很差。<br>b、所有缓存都由应用层直接控制，增加了应用层的实现复杂度，对开发者能力要求很高。<br>c、O_DIRECT也不能确保数据每次写入的时候同步写入磁盘，因此如果需要数据同步写入磁盘还需要手工设置O_SYNC标识或者手工调用fsync方法。</p><h3 id="linux-AIO"><a href="#linux-AIO" class="headerlink" title="linux AIO"></a>linux AIO</h3><p><img src="/img/content/netio/Linux%E5%8E%9F%E7%94%9FAIO.png" alt="Linux原生AIO.png"><br>Linux 原生 AIO 处理流程：</p><ul><li>当应用程序调用 io_submit 系统调用发起一个异步 IO 操作后，会向内核的 IO 任务队列中添加一个 IO 任务，并且返回成功。</li><li>内核会在后台处理 IO 任务队列中的 IO 任务，然后把处理结果存储在 IO 任务中。</li><li>应用程序可以调用 io_getevents 系统调用来获取异步 IO 的处理结果，如果 IO 操作还没完成，那么返回失败信息，否则会返回 IO 处理结果。</li></ul><p>从上面的流程可以看出，Linux 的异步 IO 操作主要由两个步骤组成：</p><ul><li><ol><li>调用 io_submit 函数发起一个异步 IO 操作。</li></ol></li><li><ol start="2"><li>调用 io_getevents 函数获取异步 IO 的结果。</li></ol></li></ul><p>linux native aio对使用O_DIRECT标识打开的文件会造成如下限制（如果无O_DIRECT标识，在调用io_submit时，会同步完成IO操作）：</p><ul><li>AIO方式读写文件时，无法利用操作系统对文件的缓存，只能从磁盘读写</li><li>读写缓冲区的地址、内容的大小、文件偏移必须是扇区的倍数（通常是512字节）</li></ul><p>io_getevents获取IO结果使用的是Direct IO<br>由于Linux原生AIO使用Direct IO,所以性能比较差。</p><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h3><p>io_uring 为了减少或者摒弃系统调用，采用了用户态与内核态 共享内存 的方式来通信。如下图所示：<br><img src="/img/content/netio/iouring%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="iouring整体流程.png"><br>I/O uring采用mmap来进行内存共享<br>用户进程可以向 共享内存 提交要发起的 I/O 操作，而内核线程可以从 共享内存 中读取 I/O 操作，并且进行相关的 I/O 操作。<br>用户态对共享内存进行读写操作是不需要使用系统调用的，所以不会发生上下文切换的情况。<br>每个 io_uring 实例都有 两个环形队列（ring），在内核和应用程序之间共享：</p><ol><li>提交队列：submission queue (SQ)</li><li>完成队列：completion queue (CQ)</li></ol><p><img src="/img/content/netio/iouring.png" alt="iouring.png"><br>IO_URING的整体流程为：<br><img src="/img/content/netio/iouring_detail.png" alt="iouring_detail.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档:"></a>参考文档:</h1><h2 id="通知socket"><a href="#通知socket" class="headerlink" title="通知socket"></a>通知socket</h2><p><a href="https://zhuanlan.zhihu.com/p/256428917">图解Linux网络包接收过程</a><br><a href="https://zhuanlan.zhihu.com/p/353850099">深入理解高性能网络开发路上的绊脚石 - 同步阻塞网络 IO</a><br><a href="https://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-io/">Socket层实现系列 — I/O事件及其处理函数</a><br><a href="https://zhuanlan.zhihu.com/p/399651675">Linux fd 系列 — socket fd 是什么？</a><br><a href="http://shengrang.net/2021/12/19/poll-note/">poll 笔记</a><br><a href="https://zhuanlan.zhihu.com/p/367591714">深入浅出理解select、poll、epoll的实现</a></p><h2 id="连接的建立-1"><a href="#连接的建立-1" class="headerlink" title="连接的建立"></a>连接的建立</h2><p><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">I/O 多路复用：select/poll/epoll</a></p><h2 id="IO模型-1"><a href="#IO模型-1" class="headerlink" title="IO模型"></a>IO模型</h2><p><a href="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型</a><br><a href="https://zhuanlan.zhihu.com/p/393747291">深入理解 Linux 的 epoll 机制</a><br><a href="https://zhuanlan.zhihu.com/p/361750240">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a><br><a href="https://rebootcat.com/2020/09/26/epoll_cookbook/">Epoll原理深入分析</a><br><a href="https://zhuanlan.zhihu.com/p/364819119">Linux原生异步IO原理与实现（Native AIO）</a><br><a href="https://zhuanlan.zhihu.com/p/380726590">一篇文章带你读懂 io_uring 的接口与实现</a></p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p><a href="https://www.cnblogs.com/sparkdev/p/8410350.html">Linux 内核空间与用户空间</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>异步</tag>
      
      <tag>阻塞</tag>
      
      <tag>非阻塞</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多级分流</title>
    <link href="/2023/01/29/%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81/"/>
    <url>/2023/01/29/%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>随着智能设备的出现，我们正式进入了大数据时代。是个App，都不断的在收集个人的行为与数据。同时，智能设备的出现，使人们的行为发生了很大的变化，大量的线下服务走到线上，比如外卖、叫车、购物等。这么多的数据传输，使我们经常听到一个网站或者服务的QPS有多少多少。比如阿里云公布的2020年双11订单创建峰值是58.3万笔/秒。显然，一台服务器是承受不了同时这么多的访问的。我们就能想到使用多台服务器来同时提供服务。<br>作为一个后端开发，我们知道，一个支撑几万用户的系统架构与一个支撑上千万用户的架构，在成本上来说，完全不是一个量级的。架构变得复杂之后，缓存、队列、网关、监控等非业务功能性的东西，成本也会变得很可观。<br><img src="/img/content/duoji/chengben.jpg" alt="用户规模与开发成本"><br>自然，我们可以想到，如果请求可以尽可能少到达后端，那么后端的成本及复杂度可以大大的减少。成本与稳定性可以达到更有效的保证。<br>以秒杀为例，几百万的人同时在抢几百瓶的茅台，理论上流入到后端有效的流量可能只有几百。当然，我们不会控制的这么精确。<br><img src="/img/content/duoji/miaosha.jpg" alt="秒杀流量"><br>后端流量是如此的，前端也是如此。一个请求从发出到得到响应中间要经过好几层，如果我们可以把流量在不同的级别中进行分流，那么，我们的总体成本将大大的减少。<br><img src="/img/content/duoji/liuliangfengliu.jpeg" alt="流量分流"><br>要知道流量怎么进行分级分流，我们就得知道一个请求的从发出到得到响应，都经历了哪些。通常的当我们在浏览器中输入 <a href="http://www.3world.top/">www.3world.top</a> 时，需要DNS来帮助我们来做域名解析，我们来看域名解析这一步，能帮我们怎么分流。</p><h1 id="DNS-域名解析-分流"><a href="#DNS-域名解析-分流" class="headerlink" title="DNS(域名解析)分流"></a>DNS(域名解析)分流</h1><p>我们开发中经常配置Host，比如我们需要把 <a href="http://www.3world.top/">www.3world.top</a> 映射到本地启动的服务器，那么需要添加一条Host记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1www.3world.top<br></code></pre></td></tr></table></figure><p>这就让我们想象中的DNS是一本厚厚的字典，心想DNS服务要应付那么大的查询流量，还在从这么多的数据中查询出来ip地址，不容易啊。<br>但实际上世界根域名服务器的ZONE文件只有2MB大小，打印都能打印的出来，这就得我们不得不惊叹其巧妙的设计了。</p><h2 id="DNS域名空间结构"><a href="#DNS域名空间结构" class="headerlink" title="DNS域名空间结构"></a>DNS域名空间结构</h2><p>整个互联网的域名空间结构为树结构。我们知道树结构通常来说叶子节点才是数据的主要存储点，非叶子节点主要起索引作用。这里主要有一个树高与节点大小的平衡问题。<br><img src="/img/content/duoji/dns.png" alt="DNS域名空间结构"><br>DNS域名空间结构的根节点为根DNS服务器，在整个Internet上有13组根服务器，注意，这里是13组，不是13台。</p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>根DNS服务器往下的第一级节点称为顶级域名。顶级域名最早的时候分为通用顶级域名(gTLD)和国家地区代码顶级域名(ccTLD)。在<a href="http://www.iana.org/domains/root/db">http://www.iana.org/domains/root/db</a>中可以看到所有的顶级域名。</p><h4 id="通用顶级域名"><a href="#通用顶级域名" class="headerlink" title="通用顶级域名"></a>通用顶级域名</h4><p>通用顶级域名主要有以下几种</p><ul><li>.com 商业组织</li><li>.edu 教育机构</li><li>.gov 政府部门</li><li>.mil 军事部门</li><li>.net 网络基础设施</li><li>.org 非营利性组织</li><li>.int 国际组织<h4 id="国家地区代码顶级域名"><a href="#国家地区代码顶级域名" class="headerlink" title="国家地区代码顶级域名"></a>国家地区代码顶级域名</h4>国家地区代码顶级域名一般取两位国家码，比如中国的cn,香港的hk,美国的us等。<h4 id="新通用顶级域名"><a href="#新通用顶级域名" class="headerlink" title="新通用顶级域名"></a>新通用顶级域名</h4>互联网名称与数字地址分配机构(ICANN)曾于2011年6月的新加坡会议上通过增设新通用顶级域名(New gTLD)的决议，并首次批准通用顶级域名可以使用多种语言字符表示。任何机构和个人都有权在2012年1月至5月向ICANN提交新通用顶级域名的申请。这就诞生了很多新的顶级域名。<br><img src="/img/content/duoji/%E6%96%B0%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D.png" alt="新顶级域名"><h3 id="权威域名服务器"><a href="#权威域名服务器" class="headerlink" title="权威域名服务器"></a>权威域名服务器</h3>顶级域名的往下一个节点都是一个子域，比如3world.top是顶级域top的子域，taobao.com是顶级域com的子域。子域的服务器叫权威域名服务器。每个权威域名服务器可以及一个或者多个区域进行解析。权威域名服务器可以再往下分拆，拆成更细粒度的权威域服务器。直至叶子节点，得到IP地址。<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><img src="/img/content/duoji/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="DNS解析过程"><br>当我们在浏览器中输入 <a href="http://www.3world.top/">www.3world.top</a> 客户端会先检查本地的DNS缓存。<br>本地DNS收到查询请求后，会按照“是否有 <a href="http://www.3world.top/">www.3world.top</a> 的权威服务器”→“是否有3world.top的权威服务器”→“是否有top的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。<br>现在假设本地DNS是全新的，上面不存在任何域名的权威服务器记录，所以当DNS查询请求一直查到根域名服务器之后，它将会得到“top的权威服务器”的地址记录，然后通过“top的权威服务器”，得到“3world.top的权威服务器”的地址记录，以此类推，最后找到能够解释 “<a href="http://www.3world.top”/">www.3world.top”</a> 的权威服务器地址。<br>查询到DNS缓存之后，会缓存到本地DNS中。win7 ~ 11 的系统，默认 Windows DNS 缓存是 86400 秒(24小时)。<br>通过上面所述我们了解了域名怎么得到服务器地址，那怎么通过域名解析到进行分流呢。我们能想到最简单的方法</li></ul><p>1.一个域名解析服务返回多个IP，客户端根据算法选择<br>2.域名解析是个服务器，可以均衡的返回不同的服务器地址。</p><h3 id="DNS解析记录类型"><a href="#DNS解析记录类型" class="headerlink" title="DNS解析记录类型"></a>DNS解析记录类型</h3><p>我们先说一下DNS常用的解析记录类型都有哪些。</p><h4 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h4><p>A（Address）记录是用来指定主机名（或域名）对应的IP地址记录。</p><h4 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h4><p>通常称别名解析，是主机名到主机名的映射。当需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录，最常用到 CNAME的场景包括做CDN、企业邮箱、全局流量管理等。</p><h4 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h4><p>如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录（Name Server）。NS记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。NS记录中的IP即为该DNS服务器的IP地址。大多数域名注册商默认用自己的NS服务器来解析用户的DNS记录。DNS服务器NS记录地址一般以以下的形式出现：ns1.domain.com、ns2.domain.com等。</p><h4 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h4><p>MX（Mail Exchanger）记录是邮件交换记录，主要用于邮箱解析，在邮件系统发送邮件时根据收信人的地址后缀进行邮件服务器的定位。MX记录允许设置一个优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器。<br>MX记录的权重对 Mail 服务非常重要，当发送邮件时，Mail 服务器先对域名进行解析，查找 MX记录。先找权重数最小的服务器（比如说是 10），如果能连通，那么就将服务器发送过去；如果无法连通 MX 记录为 10 的服务器，才将邮件发送到权重更高的 mail 服务器上。<br>多种类型的DNS记录共存关系图如下</p><table><thead><tr><th></th><th>NS</th><th>CNAME</th><th>A</th><th>MX</th></tr></thead><tbody><tr><td>NS</td><td>不限</td><td>不能共存</td><td>不能共存</td><td>不能共存</td></tr><tr><td>CNAME</td><td>不能共存</td><td>不能共存</td><td>不能共存</td><td>不能共存</td></tr><tr><td>A</td><td>不能共存</td><td>不能共存</td><td>不限</td><td>不限</td></tr><tr><td>MX</td><td>不能共存</td><td>不能共存</td><td>不限</td><td>不限</td></tr></tbody></table><p>如下图所示，在已有A记录的情况下，添加NS记录，系统会进行报错。<br><img src="/img/content/duoji/DNS%E8%AE%B0%E5%BD%95%E5%86%B2%E7%AA%81.png" alt="DNS记录冲突"><br>知道DNS解析记录的类型之后，我们来看一下怎么通过DNS解析来实现负载均衡</p><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><h3 id="负载均衡实现方式"><a href="#负载均衡实现方式" class="headerlink" title="负载均衡实现方式"></a>负载均衡实现方式</h3><h4 id="通过A记录方式实现负载均衡"><a href="#通过A记录方式实现负载均衡" class="headerlink" title="通过A记录方式实现负载均衡"></a>通过A记录方式实现负载均衡</h4><table><thead><tr><th>主机记录</th><th>记录类型</th><th>线路类型</th><th>记录值</th><th>TTL</th></tr></thead><tbody><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.1</td><td>600</td></tr><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.2</td><td>600</td></tr><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.3</td><td>600</td></tr><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.4</td><td>600</td></tr></tbody></table><p>同一个域名配置多个IP地址，解析返回得到的 IP 地址是轮询随机得到的 IP 地址，这样，本地DNS服务器会向客户端返回多个IP地址作为域名的查询结果，并且这些IP地址的排列顺序是轮换的。客户端一般会选择首个IP地址进行访问。<br>通过A记录方式实现负载均衡不会根据服务器负载和运行状况进行分配。</p><h4 id="通过CNAME方式实现负载均衡"><a href="#通过CNAME方式实现负载均衡" class="headerlink" title="通过CNAME方式实现负载均衡"></a>通过CNAME方式实现负载均衡</h4><p>我们知道顶级域名有多个，当网站做大的时候，我们通常会把多个项级域名都买下来，指向同一个网站。比如<br><a href="http://www.taobao.com/">www.taobao.com</a><br><a href="http://www.taobao.cn/">www.taobao.cn</a><br><a href="http://www.taobao.org/">www.taobao.org</a><br>都指向了淘宝网。而我们希望多对外域名统一作一个负载均衡。那么我们可以将多个域名指向同一个CNAME别名，再将CNAME别名指向多个A记录来进行负载均衡。</p><h4 id="负载均衡器作为权威DNS服务器"><a href="#负载均衡器作为权威DNS服务器" class="headerlink" title="负载均衡器作为权威DNS服务器"></a>负载均衡器作为权威DNS服务器</h4><p>我们可以建立DNS服务器，通过godaddy等平台将注册自己的DNS服务器，再将域名映射一个NS记录到自己的DNS服务器。这里，自己的DNS服务器将实现负载均衡功能。</p><h4 id="负载均衡器作为代理DNS服务器"><a href="#负载均衡器作为代理DNS服务器" class="headerlink" title="负载均衡器作为代理DNS服务器"></a>负载均衡器作为代理DNS服务器</h4><p>在这种方式下，负载均衡器被注册为一个域名空间的权威DNS服务器，而真正的权威域名服务器则部署在负载均衡器后面。所有的DNS请求都会先到达负载均衡器，由负载均衡器转发至真正的权威DNS服务器，然后修改权威DNS服务器返回的响应信息，从而实现负载均衡功能。<br>为实现这一过程，首先要将对外公布的权威DNS服务器的地址注册成负载均衡器上的VIP地址。真正的权威DNS服务器正常响应浏览器的DNS请求，返回域名解析结果列表，这个响应会先发送到负载均衡器，而负载均衡器会根据自己的策略选择一个性能最好的服务器IP并修改DNS服务器的应答信息，然后将应答信息转发给客户。负载均衡器只修改需要实现GSLB的域名的DNS查询响应，对其他请求透明转发，这样就不会影响整个域名空间的解析性能。</p><h3 id="DNS负载均衡缺点"><a href="#DNS负载均衡缺点" class="headerlink" title="DNS负载均衡缺点"></a>DNS负载均衡缺点</h3><p>DNS负载均衡有一个很大的缺点就是延时性问题，在做出调度策略改变以后，由于DNS各级节点的缓存并不会及时的在客户端生效，而且DNS负载的调度策略比较简单，无法满足更复杂的业务需求。</p><h1 id="CDN-内容分发网络-分流"><a href="#CDN-内容分发网络-分流" class="headerlink" title="CDN(内容分发网络)分流"></a>CDN(内容分发网络)分流</h1><p>抛却其他影响服务质量的因素，仅从网络传输的角度看，一个互联网系统的速度取决于以下四个因素。</p><ul><li>网站服务器的出口带宽。</li><li>用户客户端的入口带宽。</li><li>从网站到用户经过的不同运营商之间的互联节点的带宽</li><li>从网站到用户的物理链路传输时延</li></ul><p>除了第2用户的入口带宽是由用户换一个更好的宽带才能改善之外，其余三个，我们可以通过构建一个离用户近的，带宽大的服务来实现。这个离用户近、带宽大的服务就是CDN。<br>CDN的工作流程为：<br><img src="/img/content/duoji/cdn.jpeg" alt="CDN工作流程"></p><ol><li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li><li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</li><li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。<h1 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h1>当我们通过dns解析或者cdn解析拿到内容时，如果内容没变化，那么我们希望客户端能尽量的把数据缓存起来。客户端属于最边缘的计算载体，客户端缓存一是加快获取数据的速度，二是减轻CDN与服务器的压力。我们知道，缓存是否能够应用的好，就看缓存有什么样的刷新策略。根据不同的缓存策略，Http缓存可以分为以下几种。<h2 id="状态缓存"><a href="#状态缓存" class="headerlink" title="状态缓存"></a>状态缓存</h2>状态缓存是指不经过服务器，客户端直接根据缓存信息对目标网站的状态判断，以前只有301/Moved Permanently（永久重定向）这一种；后来在RFC6797中增加了HSTS（HTTP Strict Transport Security）机制，用于避免依赖301/302跳转HTTPS时可能产生的降级中间人劫持，这也属于另一种状态缓存。<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><img src="/img/content/duoji/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98.png" alt="客户端强制缓存.png"><br>Expires：http response的响应时间。<br>Cache-control：控制浏览器中页面缓存状态。<br>Last-Modified：浏览器最后一次请求服务端资源修改的日期。<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/content/duoji/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="协商缓存.png"></h2><p>tag/If-None-Match：url实体标签，类似于token，如果没有修改就返回状态码304，不会发送资源。<br>If-Modified-Since：再次请求服务端资源修改的日期，如果没有修改就返回状态码304，不会发送资源。<br>Cache-control设置了max-age与s-maxage值的话，Expires会被忽略，为了保证客户端能够获取到最新资源，建议都定义以上字段。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h2><p>硬件负载均衡是通过专门的硬件设备从而来实现负载均衡功能，比如：交换机、路由器就是一个负载均衡专用的网络设备。<br>目前典型的硬件负载均衡设备有两款：F5 和 A10。<br><strong>硬件负载均衡的优点：</strong></p><ul><li>功能强大：支持各层级负载均衡及全面负载均衡算法；</li><li>性能强大：性能远超常见的软件负载均衡器；</li><li>稳定性高：硬件负载均衡，大规模使用肯定是严格测试过的；</li><li>安全防护：除具备负载均衡功能外，还具备防火墙、防 DDoS 攻击等安全功能；</li></ul><p><strong>硬件负载均衡的缺点：</strong></p><ul><li>价格昂贵；</li><li>可扩展性差；</li><li>调试维护麻烦；<h2 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h2>负载均衡又分为四层负载均衡和七层负载均衡。四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。<br>七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。<h3 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h3>四层负载均衡在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。其中，我们可以修改IP地址，也可以修改MAC地址。四层负载均衡的优点是不对数据进行完全解析，不跟客户端建立连接（握手），请求分发的效率快。缺点是不支持更为灵活的负载均衡方式，比如基于url、session、动静分离等。<br>目前主要有四层转发模式：DR模式、NAT模式、TUNNEL模式、FULLNAT模式。<h4 id="实现模式"><a href="#实现模式" class="headerlink" title="实现模式"></a>实现模式</h4><h5 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h5>DR(Direct Routing, 直接路由模式)，也叫作三角传输，过修改数据包的目的MAC地址来让流量经过二层转发到达应用服务器，这样应用服务器就可以直接将应答发给应用服务器，性能比较好。作法为负载均衡服务器修改请求数据包的目标MAC地址，并且在Real Service服务配置只有自己可见的lo:VIP，实现数据包的接收（自己没有VIP的话，服务并不会接收数据包）。<br><img src="/img/content/duoji/DR.png" alt="DR模式"><br>整个转发的流程为：</li></ul><ol><li>客户端发送请求，源IP：CIP，目标IP：VIP</li><li>LB接收到请求，将数据帧中的目标MAC地址修改为Real Service的MAC 地址，通过调度算法选择转发到那台Real Service。</li><li>Real Service 接收到请求，发现自己有VIP，端口号也匹配。于是接收数据，进行业务处理。并用VIP为IP地址，将响应数据直接发送给客户端。</li></ol><p>DR模式下，LB只接收请求进行转发，响应数据有Real Service直接发送给客户端，降低了LB的压力。但是NAT和DR都需要LB和Real Service处于同一网段，无法将RS部署在不同的机房。</p><h5 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h5><p>NAT(Network Address Translation，网络地址转换)模式通过修改数据包的目的IP地址，让流量到达应用服务器，这样做的好处是数据包的目的IP就是应用服务器的IP，因此不需要再在应用服务器上配置VIP了。缺点是由于这种模式修改了目的IP地址，这样如果应用服务器直接将应答包发给客户端的话，其源IP是应用服务器的IP，客户端就不会正常接收这个应答，因此我们需要让流量继续回到负载均衡，负载均衡将应答包的源IP改回VIP再发到客户端，这样才可以保证正常通信，所以NAT模式要求负载均衡需要以网关的形式存在于网络中。<br>作法为在专用内部网络中，分配一台实现了NAT技术的路由或服务Load Balance Service。这台负载均衡服务器分配了公网IP(VIP, Virtual IP)，所有客户端请求服务都请求此IP。LBS通过不同的算法，将请求数据包的源IP以及目标IP修改，转发到真实服务器（Real Service）上进行业务处理。其具体的步骤可以分为：<br><img src="/img/content/duoji/NAT.png" alt="NAT模式"><br>1、客户端发送请求，源IP为：CIP，目标IP为：VIP<br>2、LBS接收请求，解析数据报IP地址，将源IP修改为：VIP，目录IP修改为：RIP。具体修改为那个目标IP，通过算法的不同进行不同的选择。并将相关信息进行存储（MAP）后发送数据包。<br>3、RS 接收到请求，进行业务处理。并将结果返回给LBS。<br>4、LBS收到相应数据包，根据之前存储的MAP，将对应的SIP改为：VIP，TIP改为：CIP，将数据包发送出去。<br>注意：连接是建立在 客户端 与 Real Service 之间，LBS只是解析数据包IP和端口号，进行修改转发而已。<br>__可以看到通过NAT模式进行负载均衡，所有的请求以及响应都要通过LB服务器，当访问量较大时，LB服务器会成为瓶颈__。</p><h5 id="TUNNEL模式"><a href="#TUNNEL模式" class="headerlink" title="TUNNEL模式"></a>TUNNEL模式</h5><p>TUN思想跟DR类似，在Real Service上配置一个内部可见的lo:VIP地址，LB通过封装或修改数据包信息实现请求的转发。不同于DR模式LB修改MAC地址，为了实现不同网段的Real Service负载，TUN模式通过在原有的数据包外封装一层IP Tunnel ，实现数据的转发。由于封装完 IP Tunnel 后数据包和正常的数据包结构不同，所以Real Service的OS需要支持Tunnel功能。<br><img src="/img/content/duoji/TUN.png" alt="TUNNEL模式"><br>TUN转发的具体流程为：</p><ol><li>客户端发送请求，SIP：CIP；TIP：VIP</li><li>LB接收到请求，在数据包外在封装一层IP Tunnel，其SIP为DIP，TIP为RIP3.</li><li>Real Service接收到请求，根据IP Tunnel 的IP地址判断出是发送给自己的请求，进行后续处理。根据源数据包的IP地址，判断出客户端的地址为CIP，并且VIP也是自己配置的IP，对数据进行业务处理后，通过VIP将响应数据直接发送到客户端。<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h5>LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器。它是一个由章文嵩博士发起的自由软件项目，官方站点是<a href="http://www.linuxvirtualserver.org/">www.linuxvirtualserver.org</a>。现在LVS已经是 Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须要重新编译内核以支持LVS功能模块，但是从Linux2.4内核以后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。<br>LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。<br>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：Linux的门户网站（<a href="http://www.linux.com/">www.linux.com</a>）、向RealPlayer提供音频视频服务而闻名的Real公司（<a href="http://www.real.com/">www.real.com</a>）、全球最大的开源网站（sourceforge.net）等。<br>LVS目前有三种IP负载均衡技术（VS/NAT、VS/TUN和VS/DR）；十种调度算法（rrr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq） <h3 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h3>通常使用的nginx负载均衡技术， 在网络分层中处于应用层（第七层）的，nginx与客户端建立TCP连接（握手），然后再根据请求信息以及本地配置信息，将请求灵活的分发到不同的服务上。nginx这类7层负载均衡的优缺点都很明显。</li></ol><ul><li><p>优点：可以将请求分发到不同的服务上，并且可以根据请求信息进行灵活的代理转发，实现更复杂的负载均衡控制，比如基于url、session、动静分离等；由于请求会通过负载均衡服务器，负载均衡服务器会过滤一些请求（例如：DOS攻击）避免所有请求信息都打到服务器上，保障了服务器的稳定运行。</p></li><li><p>缺点：处于网络分层的最上层，需要对数据进行解析，与客户端建立连接，效率比较低。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br>nginx负载均衡的几种常用方式</p><h5 id="轮循"><a href="#轮循" class="headerlink" title="轮循"></a>轮循</h5><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server 192.168.0.3;<br>    server 192.168.0.7;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h5><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h5><p>在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。<br>我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="fair-三方"><a href="#fair-三方" class="headerlink" title="fair(三方)"></a>fair(三方)</h5><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server server1;<br>    server server2;<br>    fair;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="url-hash-三方"><a href="#url-hash-三方" class="headerlink" title="url_hash(三方)"></a>url_hash(三方)</h5><p>按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server squid1:3128;<br>    server squid2:3128;<br>    hash $request_uri;<br>    hash_method crc32;<br>&#125;<br></code></pre></td></tr></table></figure><p>在需要使用负载均衡的server中增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxy_pass http://backserver/; <br>upstream backserver&#123; <br>    ip_hash; <br>    server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载) <br>    server 127.0.0.1:8080 weight=2; (weight 默认为1.weight越大，负载的权重就越大) <br>    server 127.0.0.1:6060; <br>    server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) <br>&#125; <br></code></pre></td></tr></table></figure><p>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br>fail_timeout:max_fails次失败后，暂停的时间<br>配置实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">user  nobody;</span><br><br>worker_processes  4;<br>events &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最大并发数</span><br>worker_connections  1024;<br>&#125;<br>http&#123;<br>    # 待选服务器列表<br>    upstream myproject&#123;<br>        # ip_hash指令，将同一用户引入同一服务器。<br>        ip_hash;<br>        server 125.219.3.7 fail_timeout=60s;<br>        server 172.31.3.7;<br>    &#125;<br><br>    server&#123;<br>        # 监听端口<br>        listen 80;<br>        # 根目录下<br>        location / &#123;<br>        # 选择哪个服务器列表<br>            proxy_pass http://myproject;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="应用分流"><a href="#应用分流" class="headerlink" title="应用分流"></a>应用分流</h1><p>当开发人员发现系统中某些资源的构建成本比较高，而这些资源又有被重复使用的可能时，会很自然地产生“循环再利用”的想法，将它们放到Map容器中，待下次需要时取出重用，避免重新构建，这种原始朴素的复用就是最基本的缓存。在应用中使用缓存，可以从缓存中取得数据，返回结果。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><h4 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h4><p>Memcached 是一个开源的、高性能的分布式 key/value 内存缓存系统。它以 key/value 键值对的方式存储数据，是一个键值类型的 NoSQL 组件。<br>Memcached 简称 Mc，是一个典型的内存型缓存组件，这就意味着，Mc 一旦重启就会丢失所有的数据。如下图所示，Mc 组件之间相互不通信，完全由 client 对 key 进行 Hash 后分布和协同。Mc 采用多线程处理请求，由一个主线程和任意多个工作线程协作，从而充分利用多核，提升 IO 效率。<br>Mc 的特性。</p></li><li><p>Mc 最大的特性是高性能，单节点压测性能能达到百万级的 QPS。</p></li><li><p>其次因为 Mc 的访问协议很简单，只有 get/set/cas/touch/gat/stats 等有限的几个命令。Mc 的访问协议简单，跟它的存储结构也有关系。</p></li><li><p>Mc 存储结构很简单，只存储简单的 key/value 键值对，而且对 value 直接以二进制方式存储，不识别内部存储结构，所以有限几个指令就可以满足操作需要。</p></li><li><p>Mc 完全基于内存操作，在系统运行期间，在有新 key 写进来时，如果没有空闲内存分配，就会对最不活跃的 key 进行 eviction 剔除操作。</p></li><li><p>最后，Mc 服务节点运行也特别简单，不同 Mc 节点之间互不通信，由 client 自行负责管理数据分布。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis 是一款基于 ANSI C 语言编写的，BSD 许可的，日志型 key-value 存储组件，它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。<br>Redis 是 Remote dictionary server 即远程字典服务的缩写，一个 Redis 实例可以有多个存储数据的字典，客户端可以通过 select 来选择字典即 DB 进行数据存储。<br>同为 key-value 存储组件，Memcached 只能支持二进制字节块这一种数据类型。而 Redis 的数据类型却丰富的多，它具有 8 种核心数据类型，每种数据类型都有一系列操作指令对应。Redis 性能很高，单线程压测可以达到 10~11w 的 QPS。<br>虽然 Redis 所有数据的读写操作，都在内存中进行，但也可以将所有数据进行落盘做持久化。Redis 提供了 2 种持久化方式。</p></li><li><p>快照方式，将某时刻所有数据都写入硬盘的 RDB 文件；</p></li><li><p>追加文件方式，即将所有写命令都以追加的方式写入硬盘的 AOF 文件中。</p></li></ul><p>线上 Redis 一般会同时使用两种方式，通过开启 appendonly 及关联配置项，将写命令及时追加到 AOF 文件，同时在每日流量低峰时，通过 bgsave 保存当时所有内存数据快照。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>本地缓存和应用同属于一个进程，使用不当会影响服务稳定性，所以通常需要考虑更多的因素，例如容量限制、过期策略、淘汰策略、自动刷新等。常用的本地缓存方案有：</p><ul><li>根据HashMap自实现本地缓存</li><li>Guava Cache</li><li>Caffeine</li><li>Encache<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2>如果应用中的请求需要花费的时间比较长，或者一时间接收了大量的请求。我们可以使用消息中间件来进行分流。<br>当前业界比较流行的开源消息中间件包括：ActiveMQ、RabbitMQ、RocketMQ、Kafka、ZeroMQ等，其中应用最为广泛的要数RabbitMQ、RocketMQ、Kafka 这三款。Redis在某种程度上也可以是实现类似 “Queue” 和“ Pub/Sub” 的机制，严格意义上不算消息中间件。<br><img src="/img/content/duoji/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt="消息中间件"> <h1 id="数据库分流"><a href="#数据库分流" class="headerlink" title="数据库分流"></a>数据库分流</h1><h2 id="单表容量"><a href="#单表容量" class="headerlink" title="单表容量"></a>单表容量</h2>在中国互联网技术圈流传着这么一个说法：MySQL 单表数据量大于 2000 万行，性能会明显下降。再后来，阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。对此，有阿里的黄金铁律支撑，所以，很多人设计大数据存储时，多会以此为标准，进行分表操作。<br>我们知道，InnoDB存储引擎最小储存单元——页（Page），一个页的大小是16K。<br>这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数<em>单个叶子节点记录行数。<br>假设一行记录的数据大小为1k，单个叶子节点（页）中的记录数=16K/1K=16。现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170</em>16=18720条这样的数据记录。<br>根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170<em>1170</em>16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。<br><img src="/img/content/duoji/B+Index.png" alt="image.png"><br>对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的可以，所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。<br>设计InnoDB的大佬为了缓存磁盘中的页，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做Buffer Pool（中文名是缓冲池）。那它有多大呢？这个其实看我们机器的配置，最小是5M,但如果你是土豪，你有512G内存，你分配个几百G作为Buffer Pool也可以的。<br>Buffer Pool是一个LRU缓存。从上图我们看到，如果表常用的话，数据在2千万以下，索引页还是很容易被缓存进目录的。所以查询的速度很快。但如果树高再增加一层，就需要21G的内存空间来进行索引，如果内存配置的够大的话，也是可以的。但如果再高一层，需要24T的内存来缓存索引，这个是土豪也不行的吧。<br>事实上，性能最快的肯定是数据都在内存里，2000万涉及到的是索引值是不是都能缓存进内存。而500万更多的是考虑到叶子节点缓存的占用。如果常用的叶子节点数据能够常驻在内存中，那数据应该查询的更快。<h2 id="分库分表策略"><a href="#分库分表策略" class="headerlink" title="分库分表策略"></a>分库分表策略</h2>既然表的容量有限制，那么最好的办法就是分库分表。分库分表有水平与垂直两个策略来说。垂直分表就是按照业务，把一张表分成几个业务表，从而减少单表数量，每个表的字段不一样。水平分表就是把一张表的数据切成多份，存储在不同的表中，每个表的字段一样。<h3 id="水平分库分表策略"><a href="#水平分库分表策略" class="headerlink" title="水平分库分表策略"></a>水平分库分表策略</h3><h4 id="取模分片"><a href="#取模分片" class="headerlink" title="取模分片"></a>取模分片</h4>错误做法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shardByMod</span><span class="hljs-params">(Long userId)</span> &#123; <br>    <span class="hljs-comment">// 对库数量取余结果为库序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> Math.abs(userId % DB_CNT); <br>    <span class="hljs-comment">// 对表数量取余结果为表序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tblIdx</span> <span class="hljs-operator">=</span> Math.abs(userId % TBL_CNT); <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(dbIdx, tblIdx); <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><p>其实稍微思索一下，我们就会发现，以 10 库 100 表为例，如果一个  值对 100 取余为 0，那么它对 10 取余也必然为 0。这就意味着只有 0 库里面的 0 表才可能有数据，而其他库中的 0 表永远为空!如果一个值对100取余为1，对10取余肯定也为1，那么1库1表才可会有数据。类似的我们还能推导到，0 库里面的共 100 张表，只有 10 张表中(个位数为 0 的表序号)才可能有数据。<br>这就带来了非常严重的数据偏斜问题，因为某些表中永远不可能有数据，最大数据偏斜率达到了无穷大。<br>事实上，只要库数量和表数量非互质关系，都会出现某些表中无数据的问题。<br>么是不是只要库数量和表数量互质就可用用这种分库分表方案呢?比如我用 11 库 100 表的方案，是不是就合理了呢?<br>答案是否定的，我们除了要考虑数据偏斜的问题，还需要考虑可持续性扩容的问题，一般这种 Hash 分库分表的方案后期的扩容方式都是通过翻倍扩容法，那 11 库翻倍后，和 100 又不再互质。<br>当然，如果分库数和分表数不仅互质，而且分表数为奇数(例如 10 库 101 表)，则理论上可以使用该方案，但是我想大部分人可能都会觉得使用奇数的分表数比较奇怪吧。<br>正确做法：<br>一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shardByMod</span><span class="hljs-params">(Long userId)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">slot</span> <span class="hljs-operator">=</span> DB_CNT*TBL_CNT;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(userId%slot); <br>&#125; <br></code></pre></td></tr></table></figure><p>将库与表取合标个序号，直接用序号取模。<br>二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shardByMod</span><span class="hljs-params">(Long userId)</span> &#123; <br>    <span class="hljs-comment">// 对库数量取余结果为库序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> Math.abs(userId/DB_CNT); <br>    <span class="hljs-comment">// 对表数量取余结果为表序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tblIdx</span> <span class="hljs-operator">=</span> Math.abs(dbIdx % TBL_CNT); <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(dbIdx, tblIdx); <br>&#125; <br></code></pre></td></tr></table></figure><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>实现起来比较简单。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>扩容数据需要迁移<br>不利于范围扫描查询操作</p><h4 id="Range范围分库分表"><a href="#Range范围分库分表" class="headerlink" title="Range范围分库分表"></a>Range范围分库分表</h4><p>顾名思义，该方案根据数据范围划分数据的存放位置。<br>举个最简单例子，我们可以把订单表按照年份为单位，每年的数据存放在单独的库(或者表)中。<br>如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">rangeShardByYear</span><span class="hljs-params">(String orderId)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> Integer.parseInt(orderId.substring(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)); <br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;t_order_&quot;</span> + year; <br>&#125; <br></code></pre></td></tr></table></figure><p>通过数据的范围进行分库分表，该方案是最朴实的一种分库方案，它也可以和其他分库分表方案灵活结合使用。<br>时下非常流行的分布式数据库：TiDB 数据库，针对 TiKV 中数据的打散，也是基于 Range 的方式进行，将不同范围内的[StartKey，EndKey)分配到不同的 Region 上。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>集群扩容后，指定新的范围落在新节点即可，无需进行数据迁移。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li><p>最明显的就是数据热点问题，例如上面案例中的订单表，很明显当前年度所在的库表属于热点数据，需要承载大部分的 IO 和计算资源。</p></li><li><p>新库和新表的追加问题。一般我们线上运行的应用程序是没有数据库的建库建表权限的，故我们需要提前将新的库表提前建立，防止线上故障。</p></li><li><p>这点非常容易被遗忘，尤其是稳定跑了几年没有迭代任务，或者人员又交替频繁的模块。</p><h4 id="Hash分库分表"><a href="#Hash分库分表" class="headerlink" title="Hash分库分表"></a>Hash分库分表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shard</span><span class="hljs-params">(String userId)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> userId.hashCode(); <br>    <span class="hljs-comment">// 对库数量取余结果为库序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> Math.abs(hash / DB_CNT); <br>    <span class="hljs-comment">// 对表数量取余结果为表序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tblIdx</span> <span class="hljs-operator">=</span> Math.abs(dbIdx % TBL_CNT); <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(dbIdx, tblIdx); <br>&#125; <br></code></pre></td></tr></table></figure><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>实现起来比较简单。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>扩容数据需要迁移<br>不利于范围扫描查询操作</p><h4 id="融合算法"><a href="#融合算法" class="headerlink" title="融合算法"></a>融合算法</h4><p>这时我们应该意识到，以上介绍的哈希和范围的分片算法并不是非此即彼，二选一的。相反，我们可以灵活地组合它们。<br>例如，我们可以建立一个多级分片策略，该策略在最上层使用哈希算法，而在每个基于哈希的分片单元中，数据将按顺序存储。</p><h2 id="扩容方案"><a href="#扩容方案" class="headerlink" title="扩容方案"></a>扩容方案</h2><h3 id="翻倍扩容法"><a href="#翻倍扩容法" class="headerlink" title="翻倍扩容法"></a>翻倍扩容法</h3><p><img src="/img/content/duoji/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%BF%BB%E5%80%8D%E6%89%A9%E5%AE%B9%E6%96%B9%E6%A1%88.gif" alt="分库分表翻倍扩容方案"><br>具体的流程大致如下：<br>step1：为每个节点都新增从库，开启主从同步进行数据同步。<br>step2：主从同步完成后，对主库进行禁写。<br>此处禁写主要是为了保证数据的正确性。若不进行禁写操作，在以下两个时间窗口期内将出现数据不一致的问题：</p></li><li><p>断开主从后，若主库不禁写，主库若还有数据写入，这部分数据将无法同步到从库中。</p></li><li><p>应用集群识别到分库数翻倍的时间点无法严格一致，在某个时间点可能两台应用使用不同的分库数，运算到不同的库序号，导致错误写入。</p></li></ul><p>step3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。<br>step4：从库升级为集群节点，业务应用识别到新的分库数后，将应用新的路由算法。<br>一般情况下，我们将分库数的配置放到配置中心中，当上述三个步骤完成后，我们修改分库数进行翻倍，应用生效后，应用服务将使用新的配置。<br>这里需要注意的是，业务应用接收到新的配置的时间点不一定一致，所以必定存在一个时间窗口期，该期间部分机器使用原分库数，部分节点使用新分库数。这也正是我们的禁写操作一定要在此步完成后才能放开的原因。<br>step5：确定所有的应用均接受到库总数的配置后，放开原主库的禁写操作，此时应用完全恢复服务。<br>启动离线的定时任务，清除各库中的约一半冗余数据。<br>为了节省磁盘的使用率，我们可以选择离线定时任务清除冗余的数据。也可以在业务初期表结构设计的时候，将索引键的 Hash 值存为一个字段。</p><h3 id="一致性Hash扩容"><a href="#一致性Hash扩容" class="headerlink" title="一致性Hash扩容"></a>一致性Hash扩容</h3><h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><ol><li>我们把节点通过hash后，映射到一个范围是[0，2^32]的环上</li></ol><p><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E6%9C%BA%E5%99%A8.png" alt="一致性hash机器"><br>2.把数据也通过hash的方式映射到环上<br><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E6%95%B0%E6%8D%AE.png" alt="一致性hash数据.png"><br>3.因为节点越多，它们在环上的分布就越均匀，使用虚拟节点还可以降低节点之间的负载差异<br><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png" alt="一致性hash虚拟节点.png"></p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>主要步骤如下：</p><ul><li>step1：针对需要扩容的数据库节点增加从节点，开启主从同步进行数据同步。</li><li>step2：完成主从同步后，对原主库进行禁写。此处原因和翻倍扩容法类似，需要保证新的从库和原来主库中数据的一致性。</li><li>step3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。</li><li>step4：修改一致性 Hash 范围的配置，并使应用服务重新读取并生效。</li><li>step5：确定所有的应用均接受到新的一致性 Hash 范围配置后，放开原主库的禁写操作，此时应用完全恢复服务。</li></ul><p>启动离线的定时任务，清除冗余数据。<br>可以看到，该方案和翻倍扩容法的方案比较类似，但是它更加灵活，可以根据当前集群每个节点的压力情况选择性扩容，而无需整个集群同时翻倍进行扩容。<br><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E6%89%A9%E5%AE%B9.jpg" alt="一致性hash扩容.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>负载均衡</tag>
      
      <tag>CDN</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD与EDA-核心逻辑提炼方法论</title>
    <link href="/2022/11/28/DDD%E4%B8%8EEDA-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E6%8F%90%E7%82%BC%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <url>/2022/11/28/DDD%E4%B8%8EEDA-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E6%8F%90%E7%82%BC%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>在【<a href="http://3world.top/2022/11/17/DDD%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/">DDD与应用架构</a>】一文中我们说过，应用架构的存在就是为了把一团混沌的代码变得有秩序，好管理。我们保持最核心逻辑不变，就可以保持系统的稳定与发展。领域驱动设计的作者Eric Evans 说：“为了使领域模型成为有价值的资产，必须整齐地梳理出模型的真正核心，并完全根据这个核心来创建应用程序的功能”。那么问题来了，我们要怎么梳理出模型的真正核心呢？Eric是这么说的:</p><blockquote><p>“对模型进行提炼。找到CORE DOMAIN并提供一种易于区分的方法把它与那些起辅助作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩CORE DOMAIN。<br>让最有才能的人来开发CORE DOMAIN，并据此要求进行相应的招聘。在CORE DOMAIN中努力开发能够确保实现系统蓝图的深层模型和柔性设计。仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的CORE。”<br>摘录来自<br>领域驱动设计：软件核心复杂性应对之道<br>[美] 埃里克 埃文斯（Eric Evans）</p></blockquote><p>这里我必需提一下Eric说的上下文，避免造成误会。Eric说这段话是说大部分优秀的开发人员都去进行基础设施建设了，而能力差的那些常常会去设计数据库，无休止的进行CURD。我个人比较赞同这种观点。领域设计可能需要大家在观念上有所转变，现在大多数开发都属于业务开发，业务开发最重要的不是说对一些基础设施了解的有什么深入，而是应该对你所属的行业了解到一定程度，能够刻画你所属的行业的核心业务逻辑。这里不是说搞明白基础设施不重要，而是现有的软件开发基础设施已经比较完善，借助于分布式，中间件，很多公司的开发人员都能构建一个比较可靠的秒杀系统了，高并发、大流量这些前些年听起来很酷炫的技能现在可能随处可见。而业务人员未来的竞争力可能会在于对某种垂直行业的认知，而这些认知，能帮助你成为Eric文中有才能的人。当然，成为真正有才能的人，可能还需要了解一些方法论，帮助你更好的刻画领域。</p><h1 id="看待问题的角度"><a href="#看待问题的角度" class="headerlink" title="看待问题的角度"></a>看待问题的角度</h1><p>场景一：<br>西风公司的数据智能部门需要对公司楼下的早餐店进分析，想看看公司在餐饮行业有没有机会。于是派了公司的两个数据大佬西哥与风哥去调研。<br>一天之后，西风与风哥分别分享了自己的调查情况。<br><strong>西哥的调研报告</strong></p><blockquote><p>5:30AM  早餐店门打开了<br>6:00AM   包子蒸好了<br>6:10AM    豆浆做好了<br>6:30AM    包子出售了10个，豆浆出售了20个。支付宝收到金额35元，支付收到金额25元。<br>。。。。</p></blockquote><p><strong>风哥的调研报告</strong></p><blockquote><p>老板与老板娘两个人一大早打开了早餐店，并且开始蒸包子，做豆浆。做蒸包子的时候，老板娘又去门口把今天包子与豆浆的易拉宝上。易拉宝上记录着今天早餐店的优惠价格。<br>早的时候，大部分都是楼旁边小区的居民出来买，居民们大多时候都是慢慢悠悠的走过来，包子豆浆一块买，老人家一般会自带盆，让老板把早餐装盆里，有些还会坐在店里吃。快到上班的时候，很多白领会跑着过来，快速的选择已经打包好的组合套餐，拎着就往楼上跑。。。</p></blockquote><p>场景二：<br>小西与小风都是艾薇儿的忠实粉丝，一天，小西与小风同时收到艾薇儿的新歌海报推送。<br>小风一看艾薇儿出新歌了，立马打开音乐播放器，听了起来。<br>小西则看着海报，艾薇儿把头发染成了蓝色，身穿黑红相间的卫衣，身上挂着一把吉它，右手指向前方。<br>“不愧是女神，还是这么酷这么朋克”，小西慢慢的欣赏着海报。</p><p>以上的两个场景可能我们中的大部分都经历过，一千个读者就一千个哈姆雷特，每个人看待世界的角度都是不同的。因此，我们想要提炼出core domain,首先我们要先明确一个点，我们站在哪个角度看待问题的。</p><h2 id="时间维度"><a href="#时间维度" class="headerlink" title="时间维度"></a>时间维度</h2><p>即使有理论去说明我们可以穿越时间，但毕竟都没实现过。所以我们可以这么认为，时间是最稳定的东西。任何事务肯定会在时间的长河上留下足迹，并且一旦留下足迹，肯定是一成不变的。<br>我们按时间的维度来描述事情，一般会说，某时某刻发生了什么事。这里的【事】我们可以理解为事件，某时某刻一个什么事件发生了。比如场景二中，小风收到艾薇儿的新歌海报推送，就是那个时刻，【艾薇儿发新歌】这个事件发生了。<br>那么，我们站在时间的维度上，只要在一个完整的业务周期内把这个时间线内的所有事件描述出来，就能通过事件来驱动整个业务的运行。EDA，Event Driven Architecture，事件驱动架构，描述的就是这个。驱动，英语单词Driven。我们平常说驱动，一般用在汽车发动机上，有一台发动机，加上一些组件，就能让汽车跑起来。我理解的驱动就是一个核心，加上一些组件，保证业务的运行。EDA这里事件就是核心，以事件为核心，加上一些组件，比如事件的发送方、事件的接收者，事件的响应方法等，从而保证业务的运行。</p><h2 id="空间维度"><a href="#空间维度" class="headerlink" title="空间维度"></a>空间维度</h2><p>更多的时候，我们看待问题会更加的感性一些，谁谁谁在什么地方干了什么事，而并不在意时间。英语单词(Party-Place-Thing),取首字母PPT,来说明谁在什么地方干了什么事。在业务需求描述中，只要发现领域概念与人、组织机构、地点或物品相关，我们就就可以识别其为 PPT 对象。比如场景一中风哥的调研报告，老板、老板娘两个店铺拥有者在店里打开了门，在店里蒸了包子等。<br>DDD(Domain Driven Design)，领域驱动设计，如EDA一样，这里是以领域为核心的。而领域，常常是跟某个领域方面的专家交流，在于专家的交流中抽象出来的模型。空间维度，我们更适合使用DDD来进行领域设计。<br><img src="/img/content/eda/domainDriven.png" alt="领域驱动设计"></p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>上面我们介绍的时间维度与空间维度来提炼出核心逻辑，那我们怎么选择呢。<br>我们看到，时间在企业应用中最大的用处是可追溯，假设说你的应用场景中追溯是比较重要的，如果缺少对某个东西的记录，就会影响到商业的运营和管理，或者引起法律上的纠纷。那么，你应该从时间角度来进行切入。比如笔者现在从事的财务与会计工作，财务上的每一笔账都要往前追溯，以满足审计的需要，这样，通过以时间维度构建出来的事件，可以追溯到每个费用的发生情况。再加上cqrs中的命令的话，可以更往前追溯到系统中的操作情况。<br>另外，如果你的应用并没有追溯的需求，或者是只有偶尔有追溯的需求，大部分时间业务都是在执行自己本身的工作，那可能从空间上描述更为合适。如笔者之前从事的天猫工作台有一个功能，小二需要商家关于商品售卖的信息，会给商家下发一个Excel模板，让商家填写之后提交。看似跟时间事件相关，商家某时某刻填了完了Excel上传，会发生一个Excel上传事件，小二根据Excel上传事件来进行运营操作。但事实上，小二并不关心商家什么时候上传了表格，商家实在太多了，要是一个提交后就要操作，那得累死小二。小二只是在截止日之前，去看一下哪些商家没提交，没提交的去提醒一下而已，至于商家到底是1号还是2号提交，3点还是5点提交，小二根本不关心。这种情况下，我们更应该把精力聚焦在小二与商家本身空间上的操作，比如小二发表格、合并表格、分析。<br><img src="/img/content/eda/woqudouyao.png" alt="我全都要.png"><br>另外，不管从时间维度还是空间维度，都是一个切入点，从时间维度进来，找到相关事件之后，还是要从间上找到对应的PPT,使事件可以在PPT中流转。从空间上PPT进行建模，可以通过时间上的事件发生，来理清PPT建模中的联系。</p><h1 id="目的性"><a href="#目的性" class="headerlink" title="目的性"></a>目的性</h1><p>DDD可以很大，也可以很小。上面我们知道了怎么从哪个角度切入来提炼核心逻辑，接下我们要看一下我们要解决的问题到底是什么。我们根据开发的功能大小及重要程序可以将业务系统分为两个，一个为企业经营问题，比如电商公司，交易履约系统及涉及到企业经营性的问题。而运营提出来的操作工作台则经常处理业务功能问题。</p><h2 id="企业经营问题"><a href="#企业经营问题" class="headerlink" title="企业经营问题"></a>企业经营问题</h2><p>涉及到企业经营问题系统的核心模型往往需要保持稳定性，需要慎重，不断打磨好模型，再进行实现。一个业务开发，涉及到企业经营问题系统开发，肯定要了解公司的业务，应该需要与公司的各个部门沟通好各个部分细节，集合各个部门之力，画出公司业务的全链路图，并在全链路图上抽象出模型，模型要得到相关部门的认可。</p><h2 id="业务功能问题"><a href="#业务功能问题" class="headerlink" title="业务功能问题"></a>业务功能问题</h2><p>更多的时候我们接触的是业务功能的开发。你可能接收到的就是一个prd。笔者认为，功能再小，也是可以尝试DDD的，这时候的业务系统的模型不必要非要保持稳定性。DDD并不是为了完美主义者而生。行动起来，不断去迭代它。不要以为会了DDD就能解决一切问题了，DDD只是一种思想，你不随着这种思想去行动的话，一切都不会有什么改变。反之，一开始你基于认知建造了一个很粗糙的模型。可以根据你对业务的不断了解不断调整，把一个很粗糙的模型塑造成你负责的业务系统稳定模型，大家持着对某个领域的统一认知。</p><h1 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h1><p>我们开始领域建模行动了，不管是开发关乎企业经营的应用还是做一个小功能，根据做事的方式，大概可以根据以下两种行动方式。</p><h2 id="有才能的人"><a href="#有才能的人" class="headerlink" title="有才能的人"></a>有才能的人</h2><p>这里的有才能可以基本上需要具备两个特质，社牛与敏锐的分析能力。社牛可以保证你跟领域专家搞好关系，不管是一起抽个烟、还是一起喝杯咖啡，都很有助于你了解业务。敏锐的分析能力可以让你与领域专家沟通的时候可以找到哪些信息是有用的，哪些信息是无用的。<br>如果你具备了这两个特质，那就通过与领域专家进行充分交流，把每个领域专家的说出的核心步骤连接起来。再通过核心步骤提炼出核心领域模型。这里最两个重要的词</p><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>建模的时候需要与领域方面的专家进行充分交流。领域方面的专家可以是熟悉业务的产品，熟悉业务的运营等。并且两者沟通需处于同一个频道。开发需要了解业务的专用术语，业务要明白开发画的图的意思。<br>我认为，业务与开发沟通模型的时候不要拘泥于UML图等等，只要是大家都看得懂的草图，那就是好的。</p><h3 id="共同"><a href="#共同" class="headerlink" title="共同"></a>共同</h3><p>与领域专家沟通，并且要共同建模，这里共同的意思时要在沟通的时候同时建模。最好在讨论的时候可以把草图画好，大家可以达到统一理解。</p><h2 id="EventStorming"><a href="#EventStorming" class="headerlink" title="EventStorming"></a>EventStorming</h2><p>如果你不是一个很有才能的人，那么你可以试试EventStorming(事件风暴)。相比于一个人去了解各个业务，EventStorming工作模式更需要你当一个主持人。把相关业务方拉在一起，提供一个开会的环境。<br>像这样<br><img src="/img/content/eda/eventstormingLocation.png" alt="eventstorming位置.png"><br>然后大家准备一些有各种颜色的便利贴，每个颜色都有各自的意义，无法互相替代。我们需要以下颜色的便利贴：<br>橘色（正方形）：Event 事件<br>蓝色（正方形）：Command 命令<br>紫色（长方形）: Policy/Process 商业政策/流程<br>黄色（小张长方形）:Actor 角色<br>黄色（长方形）:Aggregate 聚合<br>粉红色（长方形）：System 外部系统<br>红色（正方形）:Hotspot 热点<br>红色（小张长方形）:Problem 疑问<br>绿色（小张长方形）:Opportunity 机会<br>经色（正方形）：Read Model 资料读取模型<br>白色（大张正方形）：Uset Interface 使用者介面<br>再准备一些签字笔，计时器等。<br>最后组织大家对某个问题进行讨论，用便利贴组成整个事件的脉落。<br><img src="/img/content/eda/bianlitie.png" alt="便利贴互动模式.png"><br>最后对整个会议进行整理，从而提炼出核心模型。<br>关于EventStorming,可以看一下eventstorming.com 官网的那本作者Alberto Brandolini自己写的《Introducing EventStorming》。</p><h1 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h1><p>上文接怎么提炼核心逻辑方法论，下面我们讲讲具体实施的方案。</p><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p><img src="/img/content/eda/babieta.png" alt="巴别塔"><br>《圣经·旧约·创世纪》第11章中记录了“巴别塔”的故事。</p><blockquote><p>当时地上的人们都说同一种语言，人们离开东方之后，来到了示拿之地，在那里，人们想法设法烧砖希望能建造一座城和一座高耸入云的塔来传播自己的名声，以免他们被分散到世界各地，上帝来到人间后看到这座塔，说一群只说一种语言的人以后便没有他们做不成的事了，于是上帝将他们的语言打乱，这样他们就互相听不懂对方在说什么了，还把他们分散到了世界各地，这座城市也停止了修建。</p></blockquote><p>一群只说一种语言的人以后便没有他们做不成的事了，在任何时候，大家都会有这样的认识。同样，在任何时候，都会出现语言不同的情况。项目开发也是一样，一个公司不同项目或者不同部门，大家的语言及理解可能都会不一致。为了使事情事半功倍，就要求我们在一个小的范围内语言保持一致。然后有一个统一大局的人，把这个范围内的语言连接在一起，形成整体视图。DDD中小的范围界定有一个名称，叫BoundedContext,限定上下文。</p><h3 id="BoundedContext-限定上下文"><a href="#BoundedContext-限定上下文" class="headerlink" title="BoundedContext(限定上下文)"></a>BoundedContext(限定上下文)</h3><p>Eric在领域驱动设计一书是这样说是限定上下文的：</p><blockquote><p>“任何大型项目都会存在多个模型。而当基于不同模型的代码被组合到一起后，软件就会出现bug、变得不可靠和难以理解。团队成员之间的沟通变得混乱。人们往往弄不清楚一个模型不应该在哪个上下文中使用”<br>模型混乱的问题最终会在代码不能正常运行时暴露出来，但问题的根源却在于团队的组织方式和成员的交流方法。因此，为了澄清模型的上下文，我们既要注意项目，也要注意它的最终产品（代码、数据库模式等）。<br>“一个模型只在一个上下文中使用。”</p></blockquote><p>限定上下文，我理解下来就是能够实施统一语言的一个范围。所谓上下文，就是保持理解的一致。比如利润，在财务系统中利润包含成本、收入、计算方法等，是个很重要的Entity。而在商品系统中，它只是商品的一个属性，商品只需要利润的一个总值而已。这里我们所说利润在财务与商品两个上下文中有不同的含义。<br>再说一下限定上下文与微服务。限定上下文是对于领域的划分，在一个限定上下文大家对模型的理解一致就行。而微服务更多是对应用的拆分。多个微服务应用，可以在一个限定上下文里面，比如财务域限定上下文，里面可以有结算服务、计费服务等。<br>再者就是模块与限定上下文的区分，限定上下文就不说了，模块更多的时指一下命令空间，不管是应用代码中的模块，还是业务上的模块，都是给代码或者业务加上一个空间范围。<br><img src="/img/content/eda/boundedcontext.png" alt="image.png"><br>不同的Bounded Context是通过Context Map来连接起来的，大多数情况下，开发只关心自己的那个域，都在自己的Bounded Context中进行开发，Context Map使不同的上下文中连接起来，形成整体的视图，一个公司的管理人员可以通过整体视图来把握来整体的业务模型。</p><h3 id="Entity-实体-ValueObject-值对象"><a href="#Entity-实体-ValueObject-值对象" class="headerlink" title="Entity(实体)/ValueObject(值对象)"></a>Entity(实体)/ValueObject(值对象)</h3><p>实体与值对象网上有很多描述，这里就不过多的描述了。通常在不进行EventStorming时，我的做法往往是在与业务人员交流时，把业务人员提到的名词都给写下来，包含这些名词的属性与行为。这些名词可以是一个人、一座城市、一辆汽车、一张彩票或一次银行交易。然后再看一下出现的名词中，哪些名词所产生的实例是独一无一的，是随着时间的不同而不断变化状态的，就是实体。哪些名词是用一下就不再关心的，只是用来帮助实体完成行为的，那就是值对象。实体与值对象没有绝对的，在不同场景中有不同的解释。<br>比如说公司跟供应商之间产生了一个采购单，采购单上记录了公司的名称与供应商的名称。<br>在结算系统中，公司要与供应商算账。那么公司与供应商就是实体，采购单只是用来表示一下账有多少。用采购单算完账之后，公司与供应商还要有协商、付款等操作。这里的采购单就是值对象。<br>在计费系统中，我们需要知道根据每个采购单来算出采购的总额，这里突显的是采购这个词，公司与供应商只是用来计算的辅助项，算完这个之后，我们还要计算一下每个SKU的费用，计算一下不同账期下的抵扣费用等。这里采购单就是一个实体，公司、供应商就是值对象。</p><h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>我们抽象出来的实体可能会有很多个，物以类聚，人以群分。我们可以通过对实体的组合分类，帮我们更好的理清逻辑。<br>这里引用领域驱动中Eric对聚合的定义:</p><blockquote><p>“AGGREGATE就是一组相关对象的集合，我们把它作为数据修改的单元。每个AGGREGATE都有一个根（root）和一个边界（boundary）。边界定义了AGGREGATE的内部都有什么。根则是AGGREGATE所包含的一个特定ENTITY。对AGGREGATE而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的其他ENTITY都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY之外看不到其他对象”</p></blockquote><p>我觉得Eric已经定义的比较清楚了，我一般都是看一个对象依赖于别一个对象，它们的生命周期都一致，则可以合并成一个聚合。<br>如订单系统中的订单与订单明细，我们一般只会通过订单，来查看订单明细。当订单废弃的时候，订单明细往往也跟着废弃。这时候，我们可以认为，订单与订单明细是一个聚合。<br>在平时我们做业务功能而不是影响企业经营功能的项目建模时，我甚至觉得前期大家把一个Entity当成一个聚合也没啥不好。一是一个业务功能你抽象出来的Entity不会太多，而是做业务功能是模型是不稳定的，你可以通过后期不断的迭代来进行聚合的再抽象。前期一个Entity一个聚合可以帮助你降低建模的门槛。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>现在，我们已经抽象出来项目的Entity了，也分好聚合了。但是Entity与聚合表示是的实体的具体行为，而现实世界中有很多社交类的行为我们是无法安到Entity上的。<br>假设我们现在在做一个转账功能，我们抽象出一个Account(账户)的Entity。这个Account的有转出，转入的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferInto</span><span class="hljs-params">(Money money)</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferOut</span><span class="hljs-params">(Money money)</span>&#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们做一个转账功能，就是贷方账户转出钱，借方账户转入钱。然而，我们如果把账户中加入一个转账的功能，那么，借方账户与贷户账户行业会发生互相依赖的情况。<br>像这样，把一个由多个实体行为组成社交类行为，我们可以把它放到一个Service中，这里的Service与Entity一样，一般都是代表着现实世界中具体的含义。<br>比如，我们定义一个转账的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FundsTransferService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account creditor, Account debtor, Money money)</span>&#123;<br>        creditor.transferOut(money);<br>        debtor.transferInto(money);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，有一些全局性的规则发生的时候，我们也会在服务中进行实现，比如每个月的27号，银行通常会进行系统维护，这时候不允许转账。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FundsTransferService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account creditor, Account debtor, Money money)</span>&#123;<br>        <span class="hljs-keyword">if</span>(DateUtils.getDays(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) == <span class="hljs-number">28</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;系统在维护中,转账失败!&quot;</span>);<br>        &#125;<br>        creditor.transferOut(money);<br>        debtor.transferInto(money);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>好了，现在我们已经讲完了DDD的主要知识点，关于Factory、Repository等概念，大家可以看一下Eric的领域驱动设计，我也会在下一文DDD的具体实现案例中来进行说明。</p><h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><p>EDA(事件驱动架构)主要是由事件以核心，通过事件的发送、订阅来运行系统。<br>我认为事件是一个标准，当我们可以在一个系统中建立一个标准并且可以接受最终一致性的时候，我们通常可以认为这个系统与其它相关的系统是解耦的。<br><img src="/img/content/eda/eda.png" alt="事件驱动架构"><br>光从作法来看，EDA与传统架构的区别主要在于将传统架构处理数据库变更或者DDD中处理模型的变更转化成一个个标准的事件，至于事件的消费、事件的追溯则有具体的服务完成。<br>关于EDA更深一步的说明可以看笔者的上一篇文章【<a href="http://www.3world.top/2022/11/17/CQRS%E4%B8%8EEvent%20Sourcing/">CQRS与Event Sourcing</a>】</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>Event Sourcing</tag>
      
      <tag>DDD</tag>
      
      <tag>事件驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CQRS与Event Sourcing</title>
    <link href="/2022/11/17/CQRS%E4%B8%8EEvent%20Sourcing/"/>
    <url>/2022/11/17/CQRS%E4%B8%8EEvent%20Sourcing/</url>
    
    <content type="html"><![CDATA[<h1 id="Event-Souring"><a href="#Event-Souring" class="headerlink" title="Event Souring"></a>Event Souring</h1><h2 id="采购单不简单"><a href="#采购单不简单" class="headerlink" title="采购单不简单"></a>采购单不简单</h2><p>小吴是一个公司的资深SRM开发，精通三层架构，代码写的贼六。有天，小吴收到业务小张的一个需求，实现一个发货逻辑。小吴一想，简单，不就是接收到一个请求，然后处理请求，将处理后的业务数据持久化一下么。于是坑哧坑哧…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrderService</span> &#123;<br><br>    PurchaseOrderMapper purchaseOrderMapper;<br><br>    <span class="hljs-keyword">public</span> PurchaseOrder <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">PurchaseOrder</span> <span class="hljs-variable">po</span> <span class="hljs-operator">=</span> purchaseOrderMapper.get(<span class="hljs-number">123</span>);<br>        po.changeStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        purchaseOrderMapper.update(po);<br>        <span class="hljs-keyword">return</span> po;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，一个很常见的业务代码，逻辑上来看并没有什么问题。最重的是，格式还好看，完美！<br>代码上线了，跑了一段时间。<br>业务小张提了一个需求，他们发现一个采购单的状态不对，想知道3天前订单是一个什么状态。<br>这时候小吴就有点懵了，好像。。。。没有打日志<br>于是跟小张道了个歉，并且坑哧坑哧的补上一个日志。。。<br>代码上线了，跑了一段时间。<br>业务小张又来了，叫帮忙查一下3个月前某时某分某秒订单是什么状态，小吴熟练的登上一个机器，看了一下，糟糕，日志只保留1个月，查了一下中间还有小伙伴把日志的格式给改了，而且不知道改过几版。。。<br>于是小吴给跟小张又道了个歉…<br>吸收了教训，小吴心想，那把日志存到数据库吧，后面直接在数据库里查。。。心想这回没问题了吧<br>代码上线了，跑了一段时间。<br>业务小张又来了，叫帮忙查一下5个月前某时某分某秒这个订单是什么价格，糟糕，好像没打价格变更的日志。。。。小吴一下又懵了，再看下代码，造成订单变更的代码太分散了，而且开发人员不一样，日志总是打不全。<br>不管怎么样，先道歉吧，于是小吴很熟练的给小张道了个歉。<br>怎么办呢，小吴想起来前段时间学习了DDD，于是花了大半个月实现了DDD,这下好了，订单状态变更的方法全在PurchaseOrder这个Entity里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> &#123;<br><br>    PurchaseOrderRepo purchaseOrderRepo;<br>    <br>    LogRepo logRepo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        purchaseOrderRepo.updateStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;ship&quot;</span>,<span class="hljs-string">&quot;已发货&quot;</span>))；<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">negotiated</span><span class="hljs-params">(BigDecimal price)</span>&#123;<br>        purchaseOrderRepo.changePrice(prices);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;negotiated&quot;</span>,price))；<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>看起来没啥大问题了，表里所有的方法都加上日志了，想看啥时候的价格，查一下日志。想看啥时候的价格，查一下日志。小吴心里得意了。<br>但是，业务小张又来了。<br>业务小丁跟供应商那边谈崩了，供应商要求把三个月前某时某分某秒状态为未付款的采购单价格改到该订单两个月前某时某分某秒的价格，再加个三折。这。。。<br>好吧，道歉已经没啥用了，做，肯定能做！<br>于是小吴直接写个脚本改数据库，查下日志，把某时刻状态为未付款的采购单找出来。再查下日志，找到这些订单两个月的价格，然后mapping一下，修改价格。。。<br>好不容易做完了，业务方小张又来了，这回不光价格了，采购数量，优惠返回，账期通通给我改了。。。<br>于是小吴又双叒叕的道歉了。。<br>经历了这几件事，小吴就想，有没有什么办法，可以追溯状态的变更。</p><h2 id="采购单与账单的故事"><a href="#采购单与账单的故事" class="headerlink" title="采购单与账单的故事"></a>采购单与账单的故事</h2><p>还没等想好，业务小张又来了，让在采购单修改成发货状态的时候，同时生成一个账单。财务要算账。<br>小吴心想，这简单，等等，简单？总感觉有坑，但又不知道是什么坑。不管了，不想道歉就先干吧。<br>于是坑哧坑哧的又加了代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> &#123;<br><br>    PurchaseOrderRepo purchaseOrderRepo;<br><br>    BillFactory billFactory;<br>    <br>    LogRepo logRepo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        purchaseOrderRepo.updateStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;ship&quot;</span>,<span class="hljs-string">&quot;已发货&quot;</span>))；<br>        <span class="hljs-type">Bill</span> <span class="hljs-variable">bill</span> <span class="hljs-operator">=</span> billFactory.createBill(<span class="hljs-built_in">this</span>);<br>        bill.save();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">negotiated</span><span class="hljs-params">(BigDecimal price)</span>&#123;<br>        purchaseOrderRepo.changePrice(price);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;negotiated&quot;</span>,price))；<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>刚上线没多久，业务小张又来了，财务同学说账单来了，他收不到消息。<br>果然，坑来了，于是小吴又加上了代码，测试，发布，上线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> &#123;<br><br>    PurchaseOrderRepo purchaseOrderRepo;<br><br>    BillFactory billFactory;<br>    <br>    LogRepo logRepo;<br><br>    NoticeService noticeService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        purchaseOrderRepo.updateStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;ship&quot;</span>,<span class="hljs-string">&quot;已发货&quot;</span>))；<br>        <span class="hljs-type">Bill</span> <span class="hljs-variable">bill</span> <span class="hljs-operator">=</span> billFactory.createBill(<span class="hljs-built_in">this</span>);<br>        bill.save();<br>        noticeService.notice(<span class="hljs-string">&#x27;财务&#x27;</span>,<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">negotiated</span><span class="hljs-params">(BigDecimal price)</span>&#123;<br>        purchaseOrderRepo.changePrice(price);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;negotiated&quot;</span>,price))；<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>刚加完，业务小张又来了。。。<br>小吴本能的脑袋里飘来两个字：耦合。<br>于是小吴又想，能不能在通知状态的时候进行解耦呢。<br>好了，现在小吴的问题有3个了：<br>1.可以追溯状态的变更<br>2.通知状态的变更<br>3.解耦</p><h2 id="办法总是有的"><a href="#办法总是有的" class="headerlink" title="办法总是有的"></a>办法总是有的</h2><h3 id="追溯状态的变更"><a href="#追溯状态的变更" class="headerlink" title="追溯状态的变更"></a>追溯状态的变更</h3><p>先来第一个问题 ，追溯状态的变更，刚才我们说的日志我们记录下来了，如果我们可以像mysql的binlog同步一亲，通过重刷一下日志，就能把对象恢复到当时所有的状态。是不是就可能解决问题。<br>怎么把日志重新刷，简单来说就是日志规范化。我们给日志定一个格式，我们姑且叫这个格式的日志为事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> String eventId;<br>    <span class="hljs-keyword">private</span> String eventType;<br>    <span class="hljs-keyword">private</span> String eventTopic;<br>    <span class="hljs-keyword">private</span> T data;<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们的Aggregate通过处理Event来变更自己的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以看到，当一个Aggregate产生一个Event,又通过消费这个Event来改变状态。这样做是不是多此一举呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        apply(shipEvent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        purchaseOrderRepo.updateStatus(((ShipEvent)event).getData().getStatus());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里就回到我们刚才说通过回刷事件来重溯状态的目的了。像上面，PurchaseOrder的ship方法可以里面可以有很多逻辑，比如调用发个钉钉消息通知一下物流人员，比如调用一个供应商的服务。如果我们改变状态跟ship（也就是业务逻辑）耦合在一起，那么重刷状态的时候就相当于多跑了一遍业务逻辑。</p><h3 id="通知状态的变更"><a href="#通知状态的变更" class="headerlink" title="通知状态的变更"></a>通知状态的变更</h3><p>再来说一下通知事件。常用的通知事件就是观察者模式。通过定义EventHandler来处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    List&lt;EventHandler&gt; handlerList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        <span class="hljs-keyword">for</span>(EventHandler handler:handlerList)&#123;<br>            handler.handle(shipEvent);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>正如上面小吴所遇到的问题，这时候，PurchaseOrder本身、账单系统、通知系统都作为一个事件处理者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    List&lt;EventHandler&gt; handlerList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        <span class="hljs-keyword">for</span>(EventHandler handler:handlerList)&#123;<br>            handler.handle(shipEvent);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        purchaseOrderRepo.updateStatus(((ShipEvent)event).getData().getStatus());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bill</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-type">Bill</span> <span class="hljs-variable">bill</span> <span class="hljs-operator">=</span> billFactory.createBill(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//发出账单创建事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    NoticeService noticeService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        noticeService.notice(<span class="hljs-string">&#x27;财务&#x27;</span>,event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>好了，现在剩下最后一个问题了，解耦，在单体系统中，我们通过观察者模式来进行一个弱依赖，是可以被接受的。毕竟账单与采购单的逻辑都比较稳定，且通过观察者模式实现，修改了账单与采购单本身的逻辑并不会对另外一个有影响。<br>但我们注意到，上述的代码还有一个不太谐的地方，那就是Notice。我们很少在一个业务形态系统中抽象出来一个Notice实体，通知并不是业务系统的主要逻辑，只是为了方便交流而已。我们通常会把通知独立出来一个系统。我们知道，观察者模式在一个单体应用中要实现统一接口。怎么办呢？我们可以引入事件总线。<br>事件总线负责发布命令，事件的处理者不仅仅是单体应用中的其它对象，事件总线还可以通过消息中间件，或者RPC调用，将命令传播至其它服务，使其它服务来同样来进行事件的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">private</span> EventBus eventBus;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        eventBus.send(shipEvent);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>好了，解决了小吴所留下的三个问题。我们也就引入了一个新的概念，Event Sourcing(事件溯源)。<br>我们可以把Event Souring简单的理解为以下两点:<br>1.事件是不变的，以追加方式记录事件，形成事件日志<br>2.聚合的每次状态变化，都是一个事件的发生。聚合的状态变化是通过事件来更新。</p><blockquote><p>事件溯源有几个重要的好处。例如，它保留了聚合的历史记录，这对于实现审计和监管的功能非常有帮助。它可靠地发布领域事件，这在微服务架构中特别有用。</p></blockquote><p>小吴解决了这几个问题，业务上碰到的问题再也难不倒他了。<br>要把采购单回溯到哪个状态，新建一个聚合实例，把事件重刷。<br>要查询采购单某时候的价格，新建一个聚合实例，把事件重刷。<br>业务小张又来了，业务小张又回去了。小吴很得意，又有点失落，不道歉还不习惯了。。。<br>既然有点失落，小吴就想想目前做的事情，想到，既我采购单都是要回到某个时候的状态，现在不也是某个时候么，那么现在的状态是不是也是可以通过事件来刷回来。这样不是业务在页面上想查什么时候的状态就查什么时候的，底层一套逻辑就搞定了。<br>说干就干。<br>小吴不把采购单保留在数据库了，每次启动的时候，把所有采购单命令重新刷一次。当需要把某个采购单回复到某个时候的状态时，把当前状态清空，重刷采购单命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventRestore</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br>    <br>    <span class="hljs-keyword">private</span> EventBus eventBus;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Event&gt; events = eventStore.queryAll();<br>        <span class="hljs-keyword">for</span> (Event event: events)&#123;<br>            <span class="hljs-comment">//false控制所有事件只刷本地的</span><br>            eventBus.send(event,<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrderService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PurchaseOrderFactory purchaseOrderFactory;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">public</span> PurchaseOrder <span class="hljs-title function_">queryPoByTime</span><span class="hljs-params">(Long poId,Date queryTime)</span>&#123;<br>        <span class="hljs-type">PurchaseOrder</span> <span class="hljs-variable">purchaseOrder</span> <span class="hljs-operator">=</span> purchaseOrderFactory.get(poId);<br>        List&lt;Event&gt; eventList = eventStore.listBy(queryTime,poId);<br>        eventList.stream().forEach(event-&gt;purchaseOrder.apply(event));<br>        <span class="hljs-keyword">return</span> purchaseOrder;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>小吴上网一查，找到一个牛逼哄哄的名词，In Memory。确实很Memory嘛。<br>但是光Memory可能还不行。渐渐的小吴发现，系统里面有一些采购单，从1月份到10月份状态，状态一直变，价格一直在变更。造成每个重刷采购单都要花上好几秒的时间。嗯，这是一个大V采购单。怎么办呢。<br>没想到办法，小吴决定去找了业务小张聊聊，聊聊，说不就聊出。。。灵感来了。<br>小张很厚道，完全没有业务甲方爸爸的觉悟，跟小吴解释说，这个订单是一个长期订单，一开始给供应商定了一个预估的大量采购单，供应商一批一批给，价格也随时发生变化。但是业务上只关心三个月内的情况。<br>三个月内，那不是前几个月的订单状态都白刷了。。。<br>灵感来了，小吴回去坑哧坑哧，给订单建了一个三个月前的快照，每次刷的时候，都从这个时候开始刷。完美！世界一下子又美好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrderService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PurchaseOrderFactory purchaseOrderFactory;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">private</span> SnapshotRepository snapshotRepo;<br><br>    <span class="hljs-keyword">public</span> PurchaseOrder <span class="hljs-title function_">queryPoByTime</span><span class="hljs-params">(Long poId,Date queryTime)</span>&#123;<br>        <span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> snapshotRepo.snapshotOf(poId);<br>        <span class="hljs-type">PurchaseOrder</span> <span class="hljs-variable">purchaseOrder</span> <span class="hljs-operator">=</span> snapshot.rebuildTo(PurchaseOrder.getClass());<br>        List&lt;Event&gt; eventList = eventStore.listBy(queryTime,poId);<br>        eventList.stream().forEach(event-&gt;purchaseOrder.apply(event));<br>        <span class="hljs-keyword">return</span> purchaseOrder;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>事件是一成不变的。快照可以加快事件的重刷速度。</p><h1 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h1><h2 id="业务飞速发展"><a href="#业务飞速发展" class="headerlink" title="业务飞速发展"></a>业务飞速发展</h2><p>系统上线了一段时间，小吴的得意劲也差不多过了，业务小张也好久没来找他了，正感到无聊，系统突然间报警了，系统负载太高。<br>小吴看了一下，公司这段时候业务高速发展，不仅采购单大大的增加，业务查询量也大大增长。看了一下系统，采购单修改平均20的qps,高的时候能到100。 采购单查询平均300的qps，高的时候能到2000多。主要是业务那边来了几十个分析大师，需要实时对订单进行分析。业务那边也增加了很多人，实时跟进。<br>小吴敏锐的觉查到，查询应该与修改分开。不能互相影响。于是上网查了一下，找到了一个专有名词，CQRS,Command and Query Responsibility Segregation。</p><p><img src="/img/content/cqrs/cqrs.png" alt="CQRS"><br>先不管Command Bus，小吴发现，事件这部分他已经做完了。于是乎，小吴重新部署了一个应用，原来的那个专门负责接收请求，进行更新，小吴叫这个应用为应用A。新部署的应用负责查询,叫应用R。应用A与应用R共用一个事件存储来回刷事件。应用A部署了两台服务器，应用B部署了5台。互不影响。Perfect。</p><h2 id="业务想看的更多"><a href="#业务想看的更多" class="headerlink" title="业务想看的更多"></a>业务想看的更多</h2><p>业务小张又来了，说现在大家要跟进的事情太多，能不能把当前的采购单与账单，发货单的信息集中在一起，形成一个报表。<br>小吴心想，刷一下采购单的状态，刷一下发货单的状态，刷一下账单的状态，mapping。做的事情有点多啊，性能能不能跟上。于上问小张是要看这些单据上的所有信息么，当然不是，主要是价格信息还要仓库信息，要看到商品的最低价、最高价、移动加权平均价及到达的仓库。<br>于上小吴本能的想到，那就重建一个模型，将三个单据的价格整合在一起，接收三个单据的事件，计算价格、汇总到达仓库。将计算的数据存储起来，供业务查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PuchaseFinanceAnalysicDTO</span> &#123;<br><br>    <span class="hljs-keyword">private</span> BigDecimal maxPurchasePrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal minPurchasePrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal avgPurchasePrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal maxBillPrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal minBillPrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal avgBillPrice;<br><br>    <span class="hljs-keyword">private</span> String arriveWh;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>小吴Get到了两个个新技能：<br>1.查询模型不必遵循DDD业务逻辑，业务爸爸想要啥，给啥！<br>2.不同的系统，可以通过消费不同的事件，得到自己关注的业务信息。</p><h2 id="业务想要在手机上操作"><a href="#业务想要在手机上操作" class="headerlink" title="业务想要在手机上操作"></a>业务想要在手机上操作</h2><p>业务小张说现在大家都要出去跑业务，电脑不能一直带在身边，能不能加一个手机操作页面。<br>客户端开发人员说，手机那边一直都是用TCP长连接来与后端通信。<br>小吴想起来前两天学的六边形架构，心想，传进来的参数是不是可以统一，不管是手机还是电脑，TCP还是HTTP,将传进来的报文Adapt成一个格式不就好了。<br>CQRS那个Command就很好用。<br>于是乎，小吴将修改业务抽象出来了一个个Command，并且吸收了Event的灵感，添加了CommandBus，Command可以通过CommandBus发到单体应用中，还可以通过CommandBus发往其它应用。这样，当后面业务再发展，采购单进来的qps太高，就可以将处理采购单请求与处理采购单逻辑分开，变成两个应用。处理采购单请求的应用只要负责将采购单转化成标准的Command就行了。而且，测试也可以能过命令行直接发一个Command就行，学以致用！Perfect!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> String bizCode;<br><br>    <span class="hljs-keyword">private</span> T content;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>像之前讲六边形架构一样，CQRS的核心在于首尾的标准化。抽离出来的命令与事件最好不要改变。这样可以保证核心领域的业务逻辑不变。<br>Event Sourcing讲的是Event的溯源，但有时候，溯源是要到Command的，所以有时候，我们也需要把Command存储起来，比如笔者后面要讲的业采一体系统设计。<br>什么，你们不关心，想看小吴与小张后面的故事，额。。。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Event Sourcing</tag>
      
      <tag>DDD</tag>
      
      <tag>事件驱动</tag>
      
      <tag>CQRS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD与应用架构</title>
    <link href="/2022/11/17/DDD%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/11/17/DDD%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>架构这一词，英文单词为Architecture。Architecture在计算机体系中解释为架构，在建筑领域中理解为结构。因此，理解计算机的架构，我们可以从建筑学中的结构出发。<br><img src="/img/content/ddd/house.png" alt="房屋结构图"><br>上图是一张房子的结构图。从图中我们可以看到，房子的结构主要是说明这个房子有什么东西，这些东西应该在什么位置，怎么样整合起来整体更好看，更耐用。<br>同样，我认为架构跟结构是一个道理的。网上大家对架构是这么定义的：架构是“以组件、组件之间的关系、组件与环境之间的关系为内容的某一系统的基本组织结构，以及指导上述内容设计与演化的原则。说白了就是说明你所描述的东西有什么组成，以什么方式组成。</p><h2 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h2><p>我们通常所说的业务架构。就是描绘一个业务有哪些东西，这些东西怎么排列,以什么样的关系组成起来。<br><img src="/img/content/ddd/alizhongtai.png" alt="阿里中台架构图"></p><h2 id="组织架构"><a href="#组织架构" class="headerlink" title="组织架构"></a>组织架构</h2><p>组织架构，就是说明组织里面有哪些部门，部门的层级关系是什么样的。或者是组织间人与人之间的关系是什么样的。<br><img src="/img/content/ddd/shaoyehewo.png" alt="少爷和我"></p><h2 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h2><p>应用架构，其实就是说明一个应用里面有哪些部分，各个部分如何排列，如何依赖。<br>比如我们最经典的三层架构<br><img src="/img/content/ddd/thirdlayer.png" alt="三层架构"></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>框架，顾名思义，我觉得就是把一件事框在一定范围内，按照一定规范行事。框架是一种约束。<br>大家都遵守一种规范，在一个约束下干活。这样才能事半功倍。<br>框架，在是一种约束的情况下，也是一种工具。所谓工具，就是生产力。框架会提供一些方法、方式使你的生产力太幅度提高。从而使项目更快的完成。<br>比如spring框架<br>spring框架遵守了mvc的规范，让大家在这个规范约束下统一的行动。比如数据库接为Controller，业务处理为Service。大家统一行动，大大减少了沟通成本。<br>同时，spring的AOP,IOC大大提高了生产力，开发者只要会实现AOP或者IOC，会编写简单的业务代码，就可以实现一套可运行的程序。</p><h1 id="服务应用架构的演进"><a href="#服务应用架构的演进" class="headerlink" title="服务应用架构的演进"></a>服务应用架构的演进</h1><p>我们知道，当一个项目或者一件事都只有一个人在做的时候，再混乱都能整出一些条理出来。但多人开发一个项目或者是多人做一件事的时候，混乱就开始了，人越多，就越混乱，通常我们叫它熵增。而如之前所说，架构就是要确定一件事情里面有哪些东西，这些东西该如何整合来解决某个问题。说白了就是提出某种规范，大家都遵守这种规范，事情就会变得井然有序。但我们知道软件开发与建筑不一样的是，建筑不管前期设计过多少遍结构，只要定下来，建造完成之后基本上就不会动了。而软件开发在需求确定之后，随着业务变化，还是会不断的修改，不断的迭代。<br><img src="/img/content/ddd/nostop.png" alt="程序员没有天"><br>我认为，应用架构的产生是为了推动软件开发的，那它最起码要解决两个问题:<br>1.怎么确定规范使一团杂乱的事情变得有序。<br>2.当修改产生的时候，怎么样才能花最小的代价应付改动。</p><h2 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h2><p>早的时候，我们开发一套Java Web程序，直接创建一个项目。一个servlet的service方法就把所有的逻辑处理了。service方法好几千行，各种逻辑夹杂在其中。开发人员要想修改一个逻辑，往往要找半天。改完了还不知道修改的逻辑会不会影响到其它地方。测试也很麻烦，修改过一处地方，往往就要将所有功能重新测试一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OmnipotentServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 此处省略几千行代码</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是心很累！<br>是的，所有软件开发人员都觉得很累。<br>如我们之前所说，我们要定义一种架构，规范，使这几千行变得有序，且能最小化改动。<br>那规范怎么建立呢。分层是一种很好的方法。<br>Frank Buschmann 等人著的《面向模式的软件架构》第一卷《模式系统》第二章中提出了层的概念，该模式参考了 ISO 对 TCP/IP 协议的分层。书中是这样描述层的:</p><blockquote><p>层(layer)体系结构模式有助于构建这样的应用：它能被分解成子任务组，其中每个子任务组处于一个特定的抽象层次上。</p></blockquote><p><img src="/img/content/ddd/luan.png" alt="混乱到有序.png"></p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>在计算机本身的架构中或者网络的架构中，可以看到：到处都有分层的例子。当用分层的观点来考虑系统时，可以将各个子系统想像成按照“多层蛋糕”的形式来组织，每一层都依托在其下层之上。在这种组织方式下，上层使用了下层定义的各种服务，而下层对上层一无所知。另外，每一层对自己的上层隐藏其下层的细节。<br>比如ISO/OSI七层协议模型。<br><img src="/img/content/ddd/iso.png" alt="ISO七层协议.png"><br>我们看7层协议，从上到下，越上层越靠近用户，越下层越靠近设备。<br>我们知道一个网站功能大概可以概括成这样，用户浏览页面-&gt;点击页面上的某个功能-&gt;页面上给于反馈。<br>对于开发来说，就是接收到一个请求-&gt;处理事件-&gt;存储信息-&gt;查询信息-&gt;返回请求。<br>Martin Fowler在企业应用架构模式一书中提出了应用开发架构基本上可以分为三层。</p><ul><li>处理请求与返回请求都是最靠近用户那一层的两个子任务组，它们两个可以放到一层。</li><li>处理事件是一个子任务组，可以放到一层。</li><li>存储信息与查询信息都是最接近于存储底层的，可以放到一层。</li></ul><p><img src="/img/content/ddd/thirdlayer.png" alt="又是三层架构"><br>我认为，三层架构在水平层面对一个服务的功能进行了比较粗的颗粒度的区分。更初的两层架构往往是把处理请求与返回请求放到一层，认为与用户交互相关。处理事件与存储信息、查询信息放到一层，认为是机器处理。<br>我们来看三层架构这样区分之后，带来的效果。</p><h3 id="三层架构的效果"><a href="#三层架构的效果" class="headerlink" title="三层架构的效果"></a>三层架构的效果</h3><h4 id="用户展示层"><a href="#用户展示层" class="headerlink" title="用户展示层"></a>用户展示层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinanceInfoController</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> OrganizationService organizationService;<br>    <br>    <span class="hljs-keyword">private</span> FinanceService financeService;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/queryFinanceInfo.json&quot;)</span><br>    <span class="hljs-keyword">public</span> FinanceInfo <span class="hljs-title function_">queryFinanceInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String orgNo)</span>&#123;<br>        <span class="hljs-type">Organization</span> <span class="hljs-variable">org</span> <span class="hljs-operator">=</span> organizationService.get(orgNo);<br>        <span class="hljs-type">Finance</span> <span class="hljs-variable">finance</span> <span class="hljs-operator">=</span> financeService.get(orgNo);<br>        <span class="hljs-type">FinanceInfo</span> <span class="hljs-variable">financeInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinanceInfo</span>(org, finance);<br>        <span class="hljs-keyword">return</span> financeInfo;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，展示层专注于处理用户的请求。如果这时候页面发生了改变，我们可以将返回的FinanceInfo进行修改，而Service的业务处理可以不做修改。</p><h4 id="业务逻辑层。"><a href="#业务逻辑层。" class="headerlink" title="业务逻辑层。"></a>业务逻辑层。</h4><p>我们可以看业务按一定规则分层几个Service，一个业务逻辑或以分散到各个Service中，如果要修改某个业务，我们可以只修改到对应的Service.</p><h4 id="数据访问层。"><a href="#数据访问层。" class="headerlink" title="数据访问层。"></a>数据访问层。</h4><p>三层结构相对于两层结构，是把业务处理与数据访问分隔开来。<br>个人认为早些时候，分开的价值不大。一是早些时候数据库比较固定，一个公司一旦使用了某个数据库，基本上就不会再改变了。而是原来的软件设计是从设计往往是先设计表结构，然后基于表结构来进行开发。数据库的结构变动往往伴随着业务逻辑的变动。之所以分开，我觉得更多是人员安排上的需求。你可以让一个不了解业务的但精通SQL的开发来专注于写DAO层，而让精通于业务的开通更聚焦于写业务逻辑。然而，从毕业到现在，全栈工程师见得多了，但专职于写DAO的工程师还真没见过。</p><h3 id="三层架构的不足"><a href="#三层架构的不足" class="headerlink" title="三层架构的不足"></a>三层架构的不足</h3><p>三层架构已经流行了很长一段时间，虽然设计的初衷是美好的，所有的业务逻辑都有不同的Service来实现，Controller只负责聚合。但是在大多数情况下，开发是不怎么懂业务的，他们每天做的事情，是由产品把prd出出来，然后将prd翻译成代码。而这就造成了很多Service的混乱。混乱的情况大概会有这么几种</p><h4 id="一个Service打天下"><a href="#一个Service打天下" class="headerlink" title="一个Service打天下"></a>一个Service打天下</h4><p>我上面写到的FinanceService一样，看名字，就是跟财务相关的所有业务都在这个Service中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinanceService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取收入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">getRevenue</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取成本项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bizNo</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;Cost&gt; <span class="hljs-title function_">queryCost</span><span class="hljs-params">(List&lt;String&gt; bizNo)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新成本项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bizNo</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cost</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Cost <span class="hljs-title function_">updateCost</span><span class="hljs-params">(String bizNo, Cost cost)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 省略其余几十个方法</span><br><span class="hljs-comment">     */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多个Service代表同一个意思"><a href="#多个Service代表同一个意思" class="headerlink" title="多个Service代表同一个意思"></a>多个Service代表同一个意思</h4><p>要么就是每次产品迭代的时候，根据当时的需求来新建一个Service,比如<br>FinanceCostService<br>FinanceCostProfitService<br>FinanceCostAnaliticService<br>这三个Service分别是三个不同的开发写的，第一个接到的需求是要处理公司的成本。第二个接到的需求是需要给老板一个可以看到成本项与利润的报表，开发一看，成本数据库表知道在哪了，简单，建一个Service，写一个Mapper，返回，搞定。第三个开发接到的是运营的需求，需要对成本项按照一定规则进行分析，得到分析结果。开发一看，成本数据库表知道在哪了，简单，建一个Service，写一个Mapper，返回，搞定。</p><h4 id="多个Service都在更新同一个对象"><a href="#多个Service都在更新同一个对象" class="headerlink" title="多个Service都在更新同一个对象"></a>多个Service都在更新同一个对象</h4><p>还是拿上面一个例子<br>如有两个Service:<br>FinancePoService:财务采购单据Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinancePoService</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PurchaseOrderMapper purchaseOrderMapper;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePurchaseOrderStatus</span><span class="hljs-params">(String poNo,<span class="hljs-type">int</span> status)</span>&#123;<br>        purchaseOrderMapper.updateSatus(poNo, status);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>PoCustomerService:采购单据客服Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PoCustomerService</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PurchaseOrderMapper purchaseOrderMapper;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePurchaseOrderStatusByPoNo</span><span class="hljs-params">(String poNo,<span class="hljs-type">int</span> status)</span>&#123;<br>        purchaseOrderMapper.updateSatus(poNo, status);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>两个Service都在更新一个采购单据状态。这时候，我们如果发现一个采购单据发生问题，我们就很难发现问题究竟出现在哪里。更有甚者，分别有几个不同的controller或者service分别调用这两个不同的service.这就更混乱了。</p><h3 id="三层架构往后发展"><a href="#三层架构往后发展" class="headerlink" title="三层架构往后发展"></a>三层架构往后发展</h3><p>从上面几个例子我们可以看到，三层架构解决了一部分问题，但究其根本，Service还是还过于庞大了，而且没有规范。你可以说是因为写代码的人水平不高，才造成的上面几个问题。但是在软件开发过程中，总是会有各式各样的开发人员。你不可能指望每个人的水平都很高，即使水平都很高，每个人的想法也会不一样。既然原因是Service过于庞大，那我们应该想一下怎么样把Service拆分。<br>刚才说到，很多开发人员不懂业务，所以不知道怎么设计Service才是合理的。这就造成了Service中核心逻辑与其它业务逻辑混合在一块，纠缠在一起，如果我们可以把Service中的核心逻辑都摘出来，单独放在一个地方，整个架构如下图所示<br><img src="/img/content/ddd/fourlayer.png" alt="核心逻辑层架构.png"><br>可以看到，不管业务逻辑怎么改变，我们的核心逻辑是稳定的。只要不涉及到核心逻辑的改变，那么我们就可以大致的认为，当前业务是安全的。<br>那么怎么把核心逻辑提取出来了，这就需要对业务有一定的了解了。我们接下的介绍的DDD就与此有关。</p><h2 id="DDD-领域驱动"><a href="#DDD-领域驱动" class="headerlink" title="DDD(领域驱动)"></a>DDD(领域驱动)</h2><p>领域驱动设计（Domain Driven Design, DDD）是由Eric Evans提出的软件系统设计的面象对象建模方式。它不是一种架构，也不是一个框架。我认为它是一种思维方式，一种思想。帮助开发人员怎么样才能更好的处理好复杂的软件项目开发。<br><img src="/img/content/ddd/ddd.png" alt="领域驱动开发流程.png"><br>前文我们说过，三层架构的主要问题在于，开发一般是不懂业务的，拿一个需求来做一个需求，多次迭代之后就容易造成混乱。在领域设计就是建立了一种思维方式，让我们了解怎么样才能更好的把核心逻辑提炼出来。<br>这里不太过多的介绍DDD,后面再详细说明。我们理解简单理解DDD的主题思想是需要开发团队与某个领域方面的专家进入业务上的沟通，并互相理解对方的语言，开发团队要了解领域内的术语，领域专家要大概懂开发团队是怎么画图的。互相沟通，进而不断迭代测试，实现核心逻辑。</p><h3 id="领域驱动经典四层分层架构"><a href="#领域驱动经典四层分层架构" class="headerlink" title="领域驱动经典四层分层架构"></a>领域驱动经典四层分层架构</h3><p>Eric在领域驱动设计一书中在提出了一个四层分层架构。<br><img src="/img/content/ddd/domain4.png" alt="领域驱动四层架构.png"><br>书中对这四层的职责是这样描述的</p><table><thead><tr><th>User Interface Layer</th><th>负责向用户显示信息和解释用户指令，这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人</th></tr></thead><tbody><tr><td>Application Layer</td><td>定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题，这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。</td></tr><tr><td>应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们相互协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度。</td><td></td></tr><tr><td>Domain Layer</td><td>负责表达业务概念，业务状态信息及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的。但是反映业务状态的是由本层控制并且使用的。领域层是业务软件的核心</td></tr><tr><td>Infrastructure Layer</td><td>为上面各层提供通用的技术行为，为应用层传送消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式。</td></tr></tbody></table><p>个人认为，Eric提出的四层架构，本质上来说就是利用DDD思想将三层架构中的核心逻辑抽来，形成domain Layer。其它的与三层架构的驱别不大。</p><h3 id="六边形架构-Hexagonal-Archetecture"><a href="#六边形架构-Hexagonal-Archetecture" class="headerlink" title="六边形架构-Hexagonal Archetecture"></a>六边形架构-Hexagonal Archetecture</h3><p>这里把六边形架构放在DDD目录下，并不是因为六边形架构跟DDD绑定起来，而是DDD结合六边形架构，可以达到更好的效果。<br>六边形架构是由Alistair Cockburn在2005年提出的，这里我们还是借助于三层架构与四层架构来说明一下。<br>三层架构与四层架构理论上是可以把表示层与业务层分开的，但也会出现一些开发是会把一些业务代码直接写在controller层，跳过业务层或者领域层。或者说开发在原本应该在领域层或者业务层实现代码写到数据源层。这就又造成了一种混乱，业务逻辑与表现层或者数据源层紧紧耦合在一起，与架构设计的初衷相违背了。大多数的第一反应还是说这是开发的水平问题。但我觉得这是一种开发方式的问题。还是那句话，开发人员水平有好有差，架构就是要说明出一个应用中存在哪些东西，怎么组合，同时，也要规范不同的做事方式来达到架构设计的初衷。我们先来看一下六边形架构。<br><img src="/img/content/ddd/six.gif" alt="六边形架构"><br>假设我们现在把开发方式改成不需要管外部输出什么了，也不用管要把数据存成什么格式。只专注于业务逻辑的开发。我们开发一个应用，需要什么的数据进来，就规范出一个对象参数。我们需要什么数据出去，就规范出一个返回对象。<br>这样，我们不受表现层与数据源层的影响了，所有实现在应用中的都是业务逻辑。<br>最后，我们把应用与表示层、数据源层对接。有几个客户端，我们用几个适配器将客户端的数据转换成应用的数据格式。有几中数据源层，我们用几个适配器将应用的数据格式转换数据源所需要的格式。我理解这就是六边形架构的思想。<br>没有表示层与数据源层开发听起来是不是与DDD有点像，DDD的核心也是与领域专家交流，形成一个的核心的业务逻辑。<br><img src="/img/content/ddd/sixdomain.png" alt="六边形架构.png"><br>我们再回到六边形架构，六边形架构将三层架构中的表示层与数据源层看成是同一种。六边形架构不是跟有几条边没有关系，你愿意的话，也可以画一个八边形叫八边形架构。六边形讲的是一个对称的概念。分层有高低之分，左右代表在同一层，没有高低之分。这里的对称说的是不管是输入还是输出，在六边形架构里是同一个概念。<br>三层架构与六边形架构主要的区别，还在于说表示层与数据源层是不是对称、平等的问题。<br>Martin Fowler在企业应用架构模式一书的2010版中对该区别作了说明：</p><blockquote><p>“然而，我认为这种非对称性是有益的。因为，为别人提供服务的接口与使用别人服务的接口存在较大的差别，需要明确区分。这就是表现层和数据源层相对于核心的本质差别。表现层是系统对外提供服务的外部接口，不管外面是复杂的人类还是一个简单的远端程序。数据源层是系统使用外部服务的接口。这样区分的好处是：客户的不同将改变你对服务的看法。”</p></blockquote><p>Martin所说的客户的不同将改变你对服务的看法，我的理解是，我们一般会在数据源层进行一些事务处理、连接池处理，在对外提供服务的外部接口一般不存这些问题。所以分开更合适。<br>我们再来看六边形架构，个人认为只在应用程序产生的结果存储起来(这里的存储是在应用层)，而通过不同的适配器再传导出去，这样的应用一般不需要数据强一致性，那么六边形架构更合适，因为这时的输入输出并没有什么更多的区别。<br>如果数据需要实时影响到结果，如调用接口进行数据存储并确认，那么，三层架构更为合适。</p><h3 id="洋葱架构-Onion-Architecture"><a href="#洋葱架构-Onion-Architecture" class="headerlink" title="洋葱架构-Onion Architecture"></a>洋葱架构-Onion Architecture</h3><p><img src="/img/content/ddd/yangcong.webp" alt="洋葱架构"><br>洋葱架构是Jeffrey Palermo在08年提出来的，与六边形架构有着大致相同的思路。他们的区别是，一个是圆形，一个是六边形，都很对称，哈哈。。。，我们看到，不管是圆还是六边形，封闭的架构图一般都意味着外层把里层包裹起来，只能是外层依赖于里层，里层不能依赖于外层。<br>六边形架构提出的时候并没有考虑到领域驱动，洋葱相比于六边形架构，实现了更多Eric领域驱动的内容，即最内层不只是一个Application了，而是分的更细。所以个人认为洋葱架构是六边形架构与领域四层架构的结合体。这里的Domain Service与Domain Model这里就先不过多说明了，后面我们讲DDD的时候再展开。</p><h3 id="DCI架构"><a href="#DCI架构" class="headerlink" title="DCI架构"></a>DCI架构</h3><p>小的时候看灌篮高手，我是一个天才是樱木的口头禅。当他在与晴子练球时说出我是一个天才时，晴子的反应是是的，樱木真是一个天才。而他在球场上比赛时说出我是一个天才时，流川往往会跳出来说：白痴。 在现实世界中，不同的场景，同一件事被理解的角度不一样。我们可以理解为，世界是由不同的场景构造出来的，一个模型只有在一个场景下才会有意义。<br>之前我们说过，我们在三层架构开的时候，常常会因为Service中的方法太多，造成了程序的混乱。那么，创建好一个DDD模型之后，就万无一矢么。举一个例子。我们抽象出来一个人的模型。那么人的固定行为就表现为一个个方法。</p><p>一个人所能做的事情是很多的，当你要把人的所有现实行为都反映到一个对象中去后，你会发现，不知不觉中，你又创建了一个上帝类。<br>Jon Kern认为，“不要试着把对象在现实世界中可以想象到的行为都实现到设计中去。相反，只需要让对象能够合适于应用系统即可。对象能做的，所知的最好是一点不多一点不少。”<br>对此，我们在DDD中通常的做法是在DomainService中描绘出对象在现实数据中可以提供的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeopleService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PeopleFactory peopleFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        people.talk();<br>        people.write();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">date</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">bohu</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        <span class="hljs-type">People</span> <span class="hljs-variable">qiuxiang</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">1</span>);<br>        bohu.talk();<br>        qiuxiang.talk();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此处省略十几个方法</span><br><span class="hljs-comment">     */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，PeopleService将一个人的具体社交行为体现了出来，代表当ApplicationService中接收到一个需求时，我们通过PeopleService来反映，通过组合People的本能行为方法来实现。<br>看起来很完美！<br>但还是那个问题，这里的PeopleService没有一个具体的约束。比如苏炳添，他是一个老师，他教学生跑步的理论课，用讲跟画图就行了。同时，他也是一个教练，他要给学生示范跑步，就得真跑起来。那么我们在PeopleService里写法就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeopleService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PeopleFactory peopleFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRunTheory</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">666</span>);<br>        people.talk();<br>        people.draw();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRunAction</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">666</span>);<br>        people.run();<br>        people.talk();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        people.talk();<br>        people.write();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">date</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">bohu</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        <span class="hljs-type">People</span> <span class="hljs-variable">qiuxiang</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">1</span>);<br>        bohu.talk();<br>        qiuxiang.talk();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此处省略几十个方法</span><br><span class="hljs-comment">     */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>想像一下，当有几十几百个苏炳添这样的对象出现之后，PeopleService。。。又乱了。<br>那我们怎么整理这个乱象。<br>软件设计终究是由人做出的决策，在提出一种设计方法时，若能从人的思维模式着手，就容易找到现实世界与模型世界的结合点。<br>结合上述所说的，我们知道PeopleService缺少一种规范，我们试着来规范一下。<br>像柏拉图的人生终极问题，”我是谁，从哪来，到哪去”。我们描述一个小场景可以用,”做什么，怎么做，具体的步骤”。<br><img src="/img/content/ddd/dci.png" alt="DCI架构"><br>回到刚刚的PeopleService，我们发现，PeopleService里的行为可以抽象出来一个个角色。比如体育课老师是一种角色，教练员是一种角色。代码变成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PhysicalTeacher</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coach</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRun</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PhysicalTeacher</span>,Coach&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRun</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到，由Role代替掉了DomainService,职责更清晰。这样，People的方法更多了，但是具体相应职责的角色，来进行整体的调度，隐藏掉了People直接出去的混乱感，不在Role中需要的有People中不必呈现。整体上来看，Role的引入，把DomainService这一层的混乱给整理了。<br>我们之前说，事件的发生都是在特定的场景下的，比如苏炳添是在训练场里教导学生，在教室里面讲课。同一时间，苏炳添不会既在教室里讲课也在训练场里。这里，我们再引入一个场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Coach coach;<br>    <br>    <span class="hljs-keyword">private</span> Student student;<br>    <br>    <span class="hljs-keyword">private</span> PeopleFactory peopleFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trainTeach</span><span class="hljs-params">()</span>&#123;<br>        coach = peopleFactory.create(<span class="hljs-number">666</span>);<br>        student = peopleFactory.create(<span class="hljs-number">333</span>);<br>        coach.teachRun();<br>        student.run();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上就是DCI架构要表达的内容。<br>DCI 模式认为，在现实世界到对象世界的映射中，构成元素只有三个：数据（Data）、上下文（Context）和交互（Interaction）。<br><img src="/img/content/ddd/dci2.webp" alt="DCI架构"><br>关于DCI的理论与场景驱动我们另外开一个篇幅来说明，这里就不具全的讨论了。</p><h3 id="整洁架构-Clean-Architecture"><a href="#整洁架构-Clean-Architecture" class="headerlink" title="整洁架构(Clean Architecture)"></a>整洁架构(Clean Architecture)</h3><p><img src="/img/content/CleanArchetecture.png" alt="image.png"><br>整洁架构是由Robert C. Martin在2012年的提出的，把前面所说的六边形架构、DCI架构、洋葱架构做了一个总结,Martin认为这些架构都具有以下几个特点。<br>他们都有同样的目标，隔离关注点。他们都通过将软件分层来达到隔离。每个都至少有一层业务规则，另一层作为接口。<br>每个这些架构产出的系统都是：</p><ol><li>独立的框架。架构不依赖一些存在类库的特性。这样你可以像工具一样使用这种框架，而不需要让你的系统受到它的约束条件。</li><li>可测试。业务规则可以脱离UI，数据库，web服务器或其他外部元素进行测试。</li><li>独立的UI。UI可以很容易的更换，系统的其他部分不需要变更。例如，Web UI可以被换成控制台UI，不需要变更业务规则。</li><li>独立的数据库。你可以交换Oracle或SQL Server，用于Mongo，BigTable，CouchDB或其他的东西。你的业务规则不与数据库绑定。</li><li>独立的外部代理。实际你的业务规则并不知道关于外部世界的任何事情。</li></ol><p>这里主要是想说明两个点，Martin这里画的4个圈，不是代表整洁架构就分为四层，这里的圈只是代表外层依赖于内层。比如你可以在Use Case层与Entities层中间再加一层，DomanService层。你要是觉得还可以再拆分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>应用架构的存在，是了使一个应用的代码从混乱变得有序。尤其在多人参与开发的情况下，人数越多，熵越大。整洁有序的架构可以缓解熵增，但阻止不了，绝大部分的软件开发经过一段时间之后，都很难保持整洁。以上介绍了几个架构，提供了一些拆分应用的思路，但应用架构不是固定的，要根据自己业务，选择适合自己的最好。不要太拘泥于多一层少一层，其实并没有啥关系，只要你能通过某样形式组织好你的业务代码，使其可以最小化修改，测试，我觉得都是一个好的架构。<br>另外，国内有很多人在这些架构之后根据自己做的业务情况发展出了很多架构，我们看这些架构的时候，重要的是看他们应用于什么场景，能不能帮助很好的管理好你的应用。不要把一些高大上的图或者名字迷惑，本质上，应用架构没那么复杂。你要愿意的话，也可以画一个圆形两层架构，西瓜架构，外一层，里一层。。。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>六边形架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
