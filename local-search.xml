<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络系统与IO模型</title>
    <link href="/2023/05/10/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/05/10/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F%E4%B8%8EIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>这篇网络系统与IO模型的介绍，主要是基于Linux系统。讲解高并发情况下系统如何处理请求。还是照旧，我们从一个网络请求开始。</p><h1 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>            System.out.println(reader.readLine());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们刚学习Java网络编程时都会练习到的Java Server写法。同时配套的还有一个Client.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>        writer.write(<span class="hljs-string">&quot;Hello,World!&quot;</span>);<br>        writer.close();<br>        socket.close();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到，服务器端与客户端是通过socket来进行通信的。双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。<br>服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样的。<br>服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址和端口，绑定这两个的目的是什么？</p><ul><li>绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。</li><li>绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；</li></ul><p>绑定完 IP 地址和端口后，就可以调用 listen() 函数进行监听，此时对应 TCP 状态图中的 listen，如果我们要判定服务器中一个网络程序有没有启动，可以通过 netstat 命令查看对应的端口号是否有被监听。<br>服务端进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。<br>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 connect() 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/img/content/netio/TCP3.png" alt="TCP三次握手.png">)<br>TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p><ul><li><p>第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；</p></li><li><p>第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；</p></li><li><p>第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。</p><h2 id="半连接-全连接队列"><a href="#半连接-全连接队列" class="headerlink" title="半连接/全连接队列"></a>半连接/全连接队列</h2><p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p></li><li><p>一个是「还没完全建立」连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；</p></li><li><p>一个是「已经建立」连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态；</p></li></ul><p>当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。<br>注意，监听的 Socket 和真正用来传数据的 Socket 是两个：</p><ul><li>一个叫作监听 Socket；</li><li>一个叫作已连接 Socket；</li></ul><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 read() 和 write() 函数来读写数据。</p><h1 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h1><p>上面说到，我们建立了socket连接，通过一个已连接的socket来进行客户端与服务端之间的通信。我们再往底层追踪，计算机是靠网卡来在网络上传输数据的，那么我们从网卡接收数据开始，来描述下socket连接是如何传输数据的。</p><h2 id="网卡数据传输"><a href="#网卡数据传输" class="headerlink" title="网卡数据传输"></a>网卡数据传输</h2><p><img src="/img/content/netio/%E7%BD%91%E5%8D%A1%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE.jpg" alt="网卡接收数据.jpg"></p><p>上图展示了网卡接收数据的过程。</p><ul><li>在 ① 阶段，网卡收到网线传来的数据；</li><li>经过 ② 阶段的硬件电路的传输；</li><li>最终 ③ 阶段将数据写入到内存中的某个地址上。</li></ul><p>其中第3阶段，将数据写入内存中，其中涉及到了DMA技术。我们来详细说明下。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><h3 id="为什么要有-DMA-技术"><a href="#为什么要有-DMA-技术" class="headerlink" title="为什么要有 DMA 技术?"></a>为什么要有 DMA 技术?</h3><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p>下图说明没有DMA时候I/O全过程<br><img src="/img/content/netio/CPUIO%E8%BF%87%E7%A8%8B.png" alt="CPUIO过程.png"><br>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。<br>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。<br>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是直接内存访问（Direct Memory Access） 技术。</p><h3 id="什么是DMA"><a href="#什么是DMA" class="headerlink" title="什么是DMA"></a>什么是DMA</h3><p>什么是 DMA 技术？简单理解就是，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。<br>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。<br>![DMA I_O 过程.webp](/img/content/netio/DMA I_O 过程.webp)<br>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到， CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。<br>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。</p><h2 id="用户空间与内核空间-1"><a href="#用户空间与内核空间-1" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>从DMA过程中我们可以看到，数据是先拷贝到内核空间，再拷贝到用户空间的。那什么是内核空间与用户空间呢?<br>早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，如果程序不稳定常常把系统搞崩溃，比如清除操作系统的内存数据。后来觉得让应用程序随便访问内存太危险了，就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0~Ring3 (和电影分级有点像)，linux 只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。<br>我们知道操作系统采用的是虚拟地址空间，以32位操作系统举例，它的寻址空间为4G(2的32次方)，这里解释二个概念:</p><ol><li>寻址: 是指操作系统能找到的地址范围，32位指的是地址总线的位数，你就想象32位的二进制数，每一位可以是0，可以是1，是不是有2的32次方种可能，2^32次方就是可以访问到的最大内存空间，也就是4G。</li><li>虚拟地址空间：为什么叫虚拟，因为我们内存一共就4G，但操作系统为每一个进程都分配了4G的内存空间，这个内存空间实际是虚拟的，虚拟内存到真实内存有个映射关系。例如X86 cpu采用的段页式地址映射模型。</li></ol><p>操作系统将这4G可访问的内存空间分为二部分，一部分是内核空间，一部分是用户空间。<br>内核空间是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。<br>用户空间是普通应用程序可访问的内存区域。<br>以linux操作系统为例，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>从上文我们知道，一个请求过来，建立一个全连接的socket。服务端加载数据，先将数据加载到内核空间，再由内核拷贝到用户空间，最后通过socket返回。服务端加载数据过程如下。</p><ul><li>JVM向kernel发起system call read()</li><li>操作系统发生上下文切换，由用户态(User mode)切换到内核态(Kernel mode)，把数据读取到Kernel space buffer</li><li>Kernel把数据从Kernel space复制到User space，同时由内核态转为用户态。</li></ul><p>从上面可以看出一个I/O操作，<strong>通常</strong>而言会发生下面的事</p><ol><li>两次上下文切换(User mode 和 Kernel mode之间转换)</li><li>数据在Kernel space 和 User space之间复制</li></ol><p><img src="/img/content/netio/IO%E8%BF%87%E7%A8%8B.jpg" alt="IO过程.png"></p><h2 id="支持更多的请求"><a href="#支持更多的请求" class="headerlink" title="支持更多的请求"></a>支持更多的请求</h2><p>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。<br>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？<br>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：本机IP, 本机端口, 对端IP, 对端端口。<br>服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以最大 TCP 连接数 = 客户端 IP 数×客户端端口数。<br>对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数约为 2 的 48 次方。<br>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p><ul><li>文件描述符，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</li><li>系统内存，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；</li></ul><p>从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。<br>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。<br>其中Linux中的IO模型为 blocking I/O</p><h2 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h2><p><img src="/img/content/netio/bio.png" alt="bio.png"><br>上图是blocking I/O发起system call recvfrom()时，进程将一直阻塞等待另一端Socket的数据到来。在这种I/O模型下，我们不得不为每一个Socket都分配一个线程，这会造成很大的资源浪费。<br>Blocking I/O优缺点都非常明显。优点是简单易用，对于本地I/O而言性能很高。缺点是处理网络I/O时，造成进程阻塞空等，浪费资源。<br>注: read() 和 recvfrom()的区别是，前者从文件系统读取数据，后者从socket接收数据。<br>我们上述的例子就属于Blocking I/O，Java网络编程中叫作BIO.我们模拟IO的阻塞过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FilterInputStream</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">BlockInputStream</span><span class="hljs-params">(InputStream in)</span> &#123;<br>        <span class="hljs-built_in">super</span>(in);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>            System.out.println(<span class="hljs-string">&quot;正在从网络请求数据!等待10s&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.read(b, off, len);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockInputStream</span>(socket.getInputStream())));<br>            System.out.println(reader.readLine());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9989</span>);<br>            <span class="hljs-keyword">if</span> (socket.isConnected()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请求:&quot;</span>+i+<span class="hljs-string">&quot;连接成功!&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;请求:&quot;</span>+i+<span class="hljs-string">&quot;连接不成功!&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>            writer.write(<span class="hljs-string">&quot;请求:&quot;</span>+i+<span class="hljs-string">&quot;正在说:Hello,World!&quot;</span>);<br>            writer.close();<br>            socket.close();<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server</span><br>正在从网络请求数据!等待10s<br>正在从网络请求数据!等待10s<br>请求:<span class="hljs-number">0</span>正在说:Hello,World!<br>正在从网络请求数据!等待10s<br>正在从网络请求数据!等待10s<br>请求:<span class="hljs-number">1</span>正在说:Hello,World!<br><span class="hljs-comment">//Client</span><br>请求:<span class="hljs-number">0</span>连接成功!<br>请求:<span class="hljs-number">1</span>连接成功!<br></code></pre></td></tr></table></figure><p>可以看到，当IO阻塞的时候，请求并大量阻塞住，服务端只能一个一个进行处理。<br>这样的IO模型显然无法满足高并发的需求。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。<br>当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。<br>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。<br>那么，我们可以使用线程池的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。<br><img src="/img/content/netio/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.webp" alt="多线程模型.webp"><br>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。<br>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9989</span>);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketHandler</span>(socket)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    Socket socket;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SocketHandler</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockInputStream</span>(<span class="hljs-built_in">this</span>.socket.getInputStream())));<br>            System.out.println(reader.readLine());<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Non-Blocking-I-O"><a href="#Non-Blocking-I-O" class="headerlink" title="Non-Blocking I/O"></a>Non-Blocking I/O</h2><p><img src="/img/content/netio/noblockingIO.png" alt="noblockingIO.png"><br>非阻塞I/O很容易理解。相对于阻塞I/O在那傻傻的等待，非阻塞I/O隔一段时间就发起system call看数据是否就绪(ready)。<br>如果数据就绪，就从kernel space复制到user space，操作数据; 如果还没就绪，kernel会立即返回EWOULDBLOCK这个错误。<br>可能细心的朋友会留意到，这里同样发起system call recvfrom，凭什么在blocking I/O会阻塞，而在这里kernel的数据还没就绪就直接返回EWOULDBLOCK呢？我们看看recvfrom函数定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>这里能看到recvfrom有个参数叫flags，默认情况下阻塞。可以设置flag为非阻塞让kernel在数据未就绪时直接返回。详细见<a href="https://linux.die.net/man/2/recvfrom">recvfrom</a>。<br>Non-blocking I/O的优势在于，进程发起I/O操作时，不会因为数据还没就绪而阻塞，这就是”非阻塞”的含义。<br>但这种I/O模型缺陷过于明显。在本地I/O，kernel读取数据很快，这种模式下多了至少一次system call，而system call是比较消耗cpu的操作。对于Socket而言，大量的system call更是这种模型显得很鸡肋。<br>Java IO中没有直接实现Non-blocking I/O的方法，可以使用 serverSocket.setSoTimeout(100)来进行模拟。</p><h2 id="I-O-Multiplexing"><a href="#I-O-Multiplexing" class="headerlink" title="I/O Multiplexing"></a>I/O Multiplexing</h2><p><img src="/img/content/netio/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="IO多路复用.png"><br>I/O Multiplexing又叫IO多路复用，这是借用了集成电路多路复用中的概念。它优化了非阻塞I/O大量发起system call的问题。<br>上面介绍的I/O模型都是直接发起I/O操作，而I/O Multiplexing首先向kernel发起system call，传入file descriptor和感兴趣的事件(readable、writable等)让kernel监测，当其中一个或多个fd数据就绪，就会返回结果。程序再发起真正的I/O操作recvfrom读取数据。<br>在linux中，有3种system call可以让内核监测file descriptors，分别是select、poll、epoll。<br>我们先看看内核是怎么监测file descriptors的。</p><h3 id="如何通知Socket已准备好"><a href="#如何通知Socket已准备好" class="headerlink" title="如何通知Socket已准备好"></a>如何通知Socket已准备好</h3><p>上面我们说到当网卡接收到数据时，由DMA来存入到内存中。那么数据存入内存中后，怎么通知到socket说数据已准备好了呢。我们来进一步看。<br><img src="/img/content/netio/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.png" alt="网络数据处理.png"><br>首先当数据帧从网线到达网卡上的时候，第一站是网卡的接收队列。网卡在分配给自己的RingBuffer中寻找可用的内存位置，找到后DMA引擎会把数据DMA到网卡之前关联的内存里，这个时候CPU都是无感的。当DMA操作完成以后，网卡会像CPU发起一个硬中断，通知CPU有数据到达。<br>有专门的内核线程 ksoftirqd进行软中断处理。每个 CPU 都会绑定一个 ksoftirqd 内核线程，比如， 2 个 CPU 时，就会有 ksoftirqd/0 和 ksoftirqd/1 这两个内核线程。<br>ksoftirqd内核线程处理软中断的时候，最后会经过网络协议栈处理。发现是 tcp 的包的话就会执行到 tcp_v4_rcv 函数。在 tcp_v4_rcv 中首先根据收到的网络包的 header 里的 source 和 dest 信息来在本机上查询对应的 socket。找到以后，直接进入接收的主体函数 tcp_v4_do_rcv 。tcp_v4_do_rcv进入 tcp_rcv_established 函数中进行处理 ESTABLISH 状态下的包。在 tcp_rcv_established 中通过调用 tcp_queue_rcv 函数中完成了将接收数据放到 socket 的接收队列上。<strong>调用 tcp_queue_rcv 接收完成之后，接着再调用 sk_data_ready 来唤醒在socket上等待的用户进程</strong>。 这又是一个函数指针。 回想上面我们在 创建 socket 流程里执行到的 sock_init_data 函数。它是默认的数据就绪处理函数。<br><img src="/img/content/netio/%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.png" alt="软中断处理.png"><br>在 sock_def_readable 中再一次访问到了 sock-&gt;sk_wq 下的wait。<br>总结一下，当有数据帧进入网卡的时候，DMA将数据拷贝到内存，网卡进行硬中断，CPU处理硬中断，发出软中断。内核线程ksoftirqd处理软中断，这时候socket已经可读了。触发下sock下的sock_def_readable事件，sock_def_readable访问sock-&gt;sk_wq进行处理。sk_wq中存的是fd poll添加回调函数，调用回调函数，可以进行一些处理，也可以唤醒调用线程。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。<br>所以，对于 select 这种方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。<br><img src="/img/content/netio/select%E8%BF%87%E7%A8%8B.gif" alt="select过程.gif"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>具体参考<a href="http://shengrang.net/2021/12/19/poll-note/">poll 笔记</a>，流程为</p><ol><li>do_select 初始化时，调用 poll_initwait 初始化 poll_wqueues(poll_table)，把 qproc 设置为 __pollwait</li><li>do_select 遍历 fd 时，调用 (*f_op-&gt;poll)(file, retval ? NULL : wait); ，这会调用 tcp_poll，传入的 wait 是 poll_wqueues(poll_table)</li><li>tcp_poll 里会调用 poll_wait(file, sk-&gt;sk_sleep, wait);</li><li>poll_wait 会调用 poll_table 注册的 qproc，即 __pollwait 函数</li><li>执行 __pollwait 函数</li><li>__pollwait 函数可以先看最后两行，初始化等待队列，把当前进程挂到 entry-&gt;wait 上，再把 entry-&gt;wait 挂到 sk-&gt;sk_sleep 这个等待队列上，结束。</li></ol><p>通过上面如何通知socket已准备好，我们知道数据包到达网卡，会经过内核网络协议栈，最终到达对应的 tcp 连接进行处理（ tcp_v4_rcv -&gt; tcp_v4_do_rcv ）。对于处于 ESTABLISHED 状态的连接，如果产生新的可读分组，那么会调用 sk-&gt;sk_data_ready。而 sock_init_data 初始化 sock 时会把 sk_data_ready 指向的函数设置为 sock_def_readable。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sock_def_readable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> len)</span><br>&#123;<br>    read_lock(&amp;sk-&gt;sk_callback_lock);<br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_sleep &amp;&amp; waitqueue_active(sk-&gt;sk_sleep))<br>        wake_up_interruptible(sk-&gt;sk_sleep);<br>    sk_wake_async(sk,<span class="hljs-number">1</span>,POLL_IN);<br>    read_unlock(&amp;sk-&gt;sk_callback_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码也很好懂了，如果 sk_sleep 这个等待队列上有阻塞的进程，那么唤醒它（也就是前面在 do_select 遍历完 fd 之后陷入睡眠的进程）。这个进程被调度之后会重新进入 for(;;) 循环，开启新一轮的 fds 遍历，此时它能够在这个 tcp 连接对应的 fd 上 poll 到事件，从而离开循环，返回到用户态。<br>doSelect第一遍先将当前进程/线程挂载到 sk-&gt;sk_sleep上，当DAM将数据拷贝到socket缓冲区后，CPU发出软中断，sock_def_readable唤醒进程/线程,<br>唤醒进程/线程之后，循环继续，进程/线程查当前 tcp 连接的状态，并查看缓冲区的读写状态来确定是否产生了新的可读 / 可写事件，拼到 mask 里返回，do_select 就是读这个返回值来得知是否发生了事件。<br>select()函数的返回值有3种：若返回值大于0，表示已就绪文件描述符的数量，此种情况下某些文件可读写或有错误信息；若返回值等于0，表示等待超时，没有可读写或错误的文件；若返回值-1，表示出错返回，同时errno将被设置。</p><h4 id="select缺陷"><a href="#select缺陷" class="headerlink" title="select缺陷"></a>select缺陷</h4><p>[1] 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。<br>[2] 能监听端口的数量有限，单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264），首先我们打开Linux的fd_set数据结构的源码我们可以看到，就是一个长度为32的long int类型的数组(要注意，windows的源码和Linux的不一样)。每一位可以代表一个文件描述符，所以fd_set最多表示1024个文件描述符！这里为啥是1024个描述符呢？long int长度是32bit，数组长度是32，32*32=1024！当然我们可以对宏FD_SETSIZE进行修改，然后重新编译内核，但是性能可能会受到影响，一般该数和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认1024个，64位默认2048。<br>[3] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件：由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 通过两个方面，很好解决了 select/poll 的问题。<br>第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。<br>第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。<br><img src="/img/content/netio/epoll.webp" alt="epoll.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>具体实现可以看<a href="https://zhuanlan.zhihu.com/p/361750240">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a>与<a href="https://zhuanlan.zhihu.com/p/393747291">深入理解 Linux 的 epoll 机制</a>。上面我们知道，sock_def_readable回调poll中的回调函数p_poll_callback，在 ep_poll_callback 根据等待任务队列项上的额外的 base 指针可以找到 epitem， 进而也可以找到 eventpoll对象。<br>首先它做的第一件事就是<strong>把自己的 epitem 添加到 epoll 的就绪队列中</strong>。<br>接着它又会查看 eventpoll 对象上的等待队列里是否有等待项（epoll_wait 执行的时候会设置）。<br>如果没执行软中断的事情就做完了。如果有等待项，那就查找到等待项里设置的回调函数。调用 wake_up_locked() =&gt; __wake_up_locked() =&gt; __wake_up_common。在 __wake_up_common里， 调用 curr-&gt;func。 这里的 func 是在 epoll_wait 是传入的 default_wake_function 函数。在default_wake_function 中找到等待队列项里的进程描述符，然后唤醒之。<br><img src="/img/content/netio/epoll%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="epoll整体流程.png"></p><h2 id="Signal-Driven-I-O"><a href="#Signal-Driven-I-O" class="headerlink" title="Signal-Driven I/O"></a>Signal-Driven I/O</h2><p><img src="/img/content/netio/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8.png" alt="信号驱动.png"><br>这种信号驱动的I/O并不常见，从图片可以看到它第一次发起system call不会阻塞进程，kernel的数据就绪后会发送一个signal给进程。进程发起真正的IO操作。</p><h2 id="同步的概念"><a href="#同步的概念" class="headerlink" title="同步的概念"></a>同步的概念</h2><p>上面的Blocking IO,Non-Blocking I/O,I/O Multiplexing都属于同步IO。这里同步的概念主要是指获取数据时，由用户线程调用recvform将数据从内核空间拷贝到用户空间，从内核空间拷贝到用户空间不是由内核自动完成的。其中，Blocing IO是获取数据开始，就一直阻塞。Non-Blocking I/O是不断请求，请求到了再将数据从内核空间拷到用户空间。I/O Multiplexing是内核将数据复制到内核缓冲区【读取文件为pageCache,读取网络数据为socket缓冲区】之后，通知用户线程，用户线程调用recvform将数据从内核空间拷到用户空间。<br><img src="/img/content/netio/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.png" alt="同步异步.png"></p><h2 id="Asynchronous-I-O"><a href="#Asynchronous-I-O" class="headerlink" title="Asynchronous I/O"></a>Asynchronous I/O</h2><p><img src="/img/content/netio/%E5%BC%82%E6%AD%A5IO.png" alt="异步IO.png"></p><h3 id="绕过内核空间向用户空间复制的手段"><a href="#绕过内核空间向用户空间复制的手段" class="headerlink" title="绕过内核空间向用户空间复制的手段"></a>绕过内核空间向用户空间复制的手段</h3><p><img src="/img/content/netio/IO%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D.jpg" alt="IO数据拷贝.jpg"><br>从上文我们知道，同步是用户调用recv_from时，内核将数据从数据空间复制到用户空间。而异步就是用户直接发一个read的请求后就不管了，内核将数据准备好，拷贝到用户空间后再通知用户。但我们知道，之所以要recvfrom来获取数据，主要是当数据已经从网卡拷贝到内核缓冲区的时候，这时候并不知道该往哪个用户空间去拷贝。我们再来看一下recv_from函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数<a href="https://baike.baidu.com/item/buf/1057129?fromModule=lemma_inlink">buf</a>指向的<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/22010756?fromModule=lemma_inlink">内存空间</a>。回到异步上来，要想在没有地址的时候，就能将数据拷贝到用户空间，那么最简单的方法就是去掉内核空间或者共享内核空间与用户空间。上文我们说道，Linux分离内核空间跟用户空间的主要目的在于安全，而实现异步要打破这种设计。只能说是安全与效率之间的平衡。我们先来看绕到内核空间向用户空间复制数据的手段都有哪些。</p><h4 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h4><p>mmap 即 memory map，也就是内存映射。<br>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read、write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：<br><img src="/img/content/netio/mmp%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.png" alt="mmp基础概念.png"><br>mmap 也是一种零拷贝技术，其 I/O 模型如下图所示：<br><img src="/img/content/netio/mmap.jpg" alt="mmap.jpg"></p><h4 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h4><p>直接IO就是在应用层Buffer和磁盘之间直接建立通道。这样在读写数据的时候就能够减少上下文切换次数，同时也能够减少数据拷贝次数，从而提高效率。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>a、应用层直接操作磁盘减少了上下文切换和数据拷贝的开销，速度更快。<br>b、数据直接缓存在应用层，应用能够更加灵活的操作数据。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>a、系统基本不缓存数据，因此应用需要合理的读写数据，否则会导致性能很差。<br>b、所有缓存都由应用层直接控制，增加了应用层的实现复杂度，对开发者能力要求很高。<br>c、O_DIRECT也不能确保数据每次写入的时候同步写入磁盘，因此如果需要数据同步写入磁盘还需要手工设置O_SYNC标识或者手工调用fsync方法。</p><h3 id="linux-AIO"><a href="#linux-AIO" class="headerlink" title="linux AIO"></a>linux AIO</h3><p><img src="/img/content/netio/Linux%E5%8E%9F%E7%94%9FAIO.png" alt="Linux原生AIO.png"><br>Linux 原生 AIO 处理流程：</p><ul><li>当应用程序调用 io_submit 系统调用发起一个异步 IO 操作后，会向内核的 IO 任务队列中添加一个 IO 任务，并且返回成功。</li><li>内核会在后台处理 IO 任务队列中的 IO 任务，然后把处理结果存储在 IO 任务中。</li><li>应用程序可以调用 io_getevents 系统调用来获取异步 IO 的处理结果，如果 IO 操作还没完成，那么返回失败信息，否则会返回 IO 处理结果。</li></ul><p>从上面的流程可以看出，Linux 的异步 IO 操作主要由两个步骤组成：</p><ul><li><ol><li>调用 io_submit 函数发起一个异步 IO 操作。</li></ol></li><li><ol start="2"><li>调用 io_getevents 函数获取异步 IO 的结果。</li></ol></li></ul><p>linux native aio对使用O_DIRECT标识打开的文件会造成如下限制（如果无O_DIRECT标识，在调用io_submit时，会同步完成IO操作）：</p><ul><li>AIO方式读写文件时，无法利用操作系统对文件的缓存，只能从磁盘读写</li><li>读写缓冲区的地址、内容的大小、文件偏移必须是扇区的倍数（通常是512字节）</li></ul><p>io_getevents获取IO结果使用的是Direct IO<br>由于Linux原生AIO使用Direct IO,所以性能比较差。</p><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h3><p>io_uring 为了减少或者摒弃系统调用，采用了用户态与内核态 共享内存 的方式来通信。如下图所示：<br><img src="/img/content/netio/iouring%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="iouring整体流程.png"><br>I/O uring采用mmap来进行内存共享<br>用户进程可以向 共享内存 提交要发起的 I/O 操作，而内核线程可以从 共享内存 中读取 I/O 操作，并且进行相关的 I/O 操作。<br>用户态对共享内存进行读写操作是不需要使用系统调用的，所以不会发生上下文切换的情况。<br>每个 io_uring 实例都有 两个环形队列（ring），在内核和应用程序之间共享：</p><ol><li>提交队列：submission queue (SQ)</li><li>完成队列：completion queue (CQ)</li></ol><p><img src="/img/content/netio/iouring.png" alt="iouring.png"><br>IO_URING的整体流程为：<br><img src="/img/content/netio/iouring_detail.png" alt="iouring_detail.png"></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档:"></a>参考文档:</h1><h2 id="通知socket"><a href="#通知socket" class="headerlink" title="通知socket"></a>通知socket</h2><p><a href="https://zhuanlan.zhihu.com/p/256428917">图解Linux网络包接收过程</a><br><a href="https://zhuanlan.zhihu.com/p/353850099">深入理解高性能网络开发路上的绊脚石 - 同步阻塞网络 IO</a><br><a href="https://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-io/">Socket层实现系列 — I/O事件及其处理函数</a><br><a href="https://zhuanlan.zhihu.com/p/399651675">Linux fd 系列 — socket fd 是什么？</a><br><a href="http://shengrang.net/2021/12/19/poll-note/">poll 笔记</a><br><a href="https://zhuanlan.zhihu.com/p/367591714">深入浅出理解select、poll、epoll的实现</a></p><h2 id="连接的建立-1"><a href="#连接的建立-1" class="headerlink" title="连接的建立"></a>连接的建立</h2><p><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html">I/O 多路复用：select/poll/epoll</a></p><h2 id="IO模型-1"><a href="#IO模型-1" class="headerlink" title="IO模型"></a>IO模型</h2><p><a href="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型</a><br><a href="https://zhuanlan.zhihu.com/p/393747291">深入理解 Linux 的 epoll 机制</a><br><a href="https://zhuanlan.zhihu.com/p/361750240">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a><br><a href="https://rebootcat.com/2020/09/26/epoll_cookbook/">Epoll原理深入分析</a><br><a href="https://zhuanlan.zhihu.com/p/364819119">Linux原生异步IO原理与实现（Native AIO）</a><br><a href="https://zhuanlan.zhihu.com/p/380726590">一篇文章带你读懂 io_uring 的接口与实现</a></p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p><a href="https://www.cnblogs.com/sparkdev/p/8410350.html">Linux 内核空间与用户空间</a></p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>异步</tag>
      
      <tag>阻塞</tag>
      
      <tag>非阻塞</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多级分流</title>
    <link href="/2023/01/29/%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81/"/>
    <url>/2023/01/29/%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>随着智能设备的出现，我们正式进入了大数据时代。是个App，都不断的在收集个人的行为与数据。同时，智能设备的出现，使人们的行为发生了很大的变化，大量的线下服务走到线上，比如外卖、叫车、购物等。这么多的数据传输，使我们经常听到一个网站或者服务的QPS有多少多少。比如阿里云公布的2020年双11订单创建峰值是58.3万笔/秒。显然，一台服务器是承受不了同时这么多的访问的。我们就能想到使用多台服务器来同时提供服务。<br>作为一个后端开发，我们知道，一个支撑几万用户的系统架构与一个支撑上千万用户的架构，在成本上来说，完全不是一个量级的。架构变得复杂之后，缓存、队列、网关、监控等非业务功能性的东西，成本也会变得很可观。<br><img src="/img/content/duoji/chengben.jpg" alt="用户规模与开发成本"><br>自然，我们可以想到，如果请求可以尽可能少到达后端，那么后端的成本及复杂度可以大大的减少。成本与稳定性可以达到更有效的保证。<br>以秒杀为例，几百万的人同时在抢几百瓶的茅台，理论上流入到后端有效的流量可能只有几百。当然，我们不会控制的这么精确。<br><img src="/img/content/duoji/miaosha.jpg" alt="秒杀流量"><br>后端流量是如此的，前端也是如此。一个请求从发出到得到响应中间要经过好几层，如果我们可以把流量在不同的级别中进行分流，那么，我们的总体成本将大大的减少。<br><img src="/img/content/duoji/liuliangfengliu.jpeg" alt="流量分流"><br>要知道流量怎么进行分级分流，我们就得知道一个请求的从发出到得到响应，都经历了哪些。通常的当我们在浏览器中输入 <a href="http://www.3world.top/">www.3world.top</a> 时，需要DNS来帮助我们来做域名解析，我们来看域名解析这一步，能帮我们怎么分流。</p><h1 id="DNS-域名解析-分流"><a href="#DNS-域名解析-分流" class="headerlink" title="DNS(域名解析)分流"></a>DNS(域名解析)分流</h1><p>我们开发中经常配置Host，比如我们需要把 <a href="http://www.3world.top/">www.3world.top</a> 映射到本地启动的服务器，那么需要添加一条Host记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1www.3world.top<br></code></pre></td></tr></table></figure><p>这就让我们想象中的DNS是一本厚厚的字典，心想DNS服务要应付那么大的查询流量，还在从这么多的数据中查询出来ip地址，不容易啊。<br>但实际上世界根域名服务器的ZONE文件只有2MB大小，打印都能打印的出来，这就得我们不得不惊叹其巧妙的设计了。</p><h2 id="DNS域名空间结构"><a href="#DNS域名空间结构" class="headerlink" title="DNS域名空间结构"></a>DNS域名空间结构</h2><p>整个互联网的域名空间结构为树结构。我们知道树结构通常来说叶子节点才是数据的主要存储点，非叶子节点主要起索引作用。这里主要有一个树高与节点大小的平衡问题。<br><img src="/img/content/duoji/dns.png" alt="DNS域名空间结构"><br>DNS域名空间结构的根节点为根DNS服务器，在整个Internet上有13组根服务器，注意，这里是13组，不是13台。</p><h3 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h3><p>根DNS服务器往下的第一级节点称为顶级域名。顶级域名最早的时候分为通用顶级域名(gTLD)和国家地区代码顶级域名(ccTLD)。在<a href="http://www.iana.org/domains/root/db">http://www.iana.org/domains/root/db</a>中可以看到所有的顶级域名。</p><h4 id="通用顶级域名"><a href="#通用顶级域名" class="headerlink" title="通用顶级域名"></a>通用顶级域名</h4><p>通用顶级域名主要有以下几种</p><ul><li>.com 商业组织</li><li>.edu 教育机构</li><li>.gov 政府部门</li><li>.mil 军事部门</li><li>.net 网络基础设施</li><li>.org 非营利性组织</li><li>.int 国际组织<h4 id="国家地区代码顶级域名"><a href="#国家地区代码顶级域名" class="headerlink" title="国家地区代码顶级域名"></a>国家地区代码顶级域名</h4>国家地区代码顶级域名一般取两位国家码，比如中国的cn,香港的hk,美国的us等。<h4 id="新通用顶级域名"><a href="#新通用顶级域名" class="headerlink" title="新通用顶级域名"></a>新通用顶级域名</h4>互联网名称与数字地址分配机构(ICANN)曾于2011年6月的新加坡会议上通过增设新通用顶级域名(New gTLD)的决议，并首次批准通用顶级域名可以使用多种语言字符表示。任何机构和个人都有权在2012年1月至5月向ICANN提交新通用顶级域名的申请。这就诞生了很多新的顶级域名。<br><img src="/img/content/duoji/%E6%96%B0%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D.png" alt="新顶级域名"><h3 id="权威域名服务器"><a href="#权威域名服务器" class="headerlink" title="权威域名服务器"></a>权威域名服务器</h3>顶级域名的往下一个节点都是一个子域，比如3world.top是顶级域top的子域，taobao.com是顶级域com的子域。子域的服务器叫权威域名服务器。每个权威域名服务器可以及一个或者多个区域进行解析。权威域名服务器可以再往下分拆，拆成更细粒度的权威域服务器。直至叶子节点，得到IP地址。<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><img src="/img/content/duoji/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="DNS解析过程"><br>当我们在浏览器中输入 <a href="http://www.3world.top/">www.3world.top</a> 客户端会先检查本地的DNS缓存。<br>本地DNS收到查询请求后，会按照“是否有 <a href="http://www.3world.top/">www.3world.top</a> 的权威服务器”→“是否有3world.top的权威服务器”→“是否有top的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。<br>现在假设本地DNS是全新的，上面不存在任何域名的权威服务器记录，所以当DNS查询请求一直查到根域名服务器之后，它将会得到“top的权威服务器”的地址记录，然后通过“top的权威服务器”，得到“3world.top的权威服务器”的地址记录，以此类推，最后找到能够解释 “<a href="http://www.3world.top”/">www.3world.top”</a> 的权威服务器地址。<br>查询到DNS缓存之后，会缓存到本地DNS中。win7 ~ 11 的系统，默认 Windows DNS 缓存是 86400 秒(24小时)。<br>通过上面所述我们了解了域名怎么得到服务器地址，那怎么通过域名解析到进行分流呢。我们能想到最简单的方法</li></ul><p>1.一个域名解析服务返回多个IP，客户端根据算法选择<br>2.域名解析是个服务器，可以均衡的返回不同的服务器地址。</p><h3 id="DNS解析记录类型"><a href="#DNS解析记录类型" class="headerlink" title="DNS解析记录类型"></a>DNS解析记录类型</h3><p>我们先说一下DNS常用的解析记录类型都有哪些。</p><h4 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h4><p>A（Address）记录是用来指定主机名（或域名）对应的IP地址记录。</p><h4 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h4><p>通常称别名解析，是主机名到主机名的映射。当需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录，最常用到 CNAME的场景包括做CDN、企业邮箱、全局流量管理等。</p><h4 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h4><p>如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录（Name Server）。NS记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。NS记录中的IP即为该DNS服务器的IP地址。大多数域名注册商默认用自己的NS服务器来解析用户的DNS记录。DNS服务器NS记录地址一般以以下的形式出现：ns1.domain.com、ns2.domain.com等。</p><h4 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h4><p>MX（Mail Exchanger）记录是邮件交换记录，主要用于邮箱解析，在邮件系统发送邮件时根据收信人的地址后缀进行邮件服务器的定位。MX记录允许设置一个优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器。<br>MX记录的权重对 Mail 服务非常重要，当发送邮件时，Mail 服务器先对域名进行解析，查找 MX记录。先找权重数最小的服务器（比如说是 10），如果能连通，那么就将服务器发送过去；如果无法连通 MX 记录为 10 的服务器，才将邮件发送到权重更高的 mail 服务器上。<br>多种类型的DNS记录共存关系图如下</p><table><thead><tr><th></th><th>NS</th><th>CNAME</th><th>A</th><th>MX</th></tr></thead><tbody><tr><td>NS</td><td>不限</td><td>不能共存</td><td>不能共存</td><td>不能共存</td></tr><tr><td>CNAME</td><td>不能共存</td><td>不能共存</td><td>不能共存</td><td>不能共存</td></tr><tr><td>A</td><td>不能共存</td><td>不能共存</td><td>不限</td><td>不限</td></tr><tr><td>MX</td><td>不能共存</td><td>不能共存</td><td>不限</td><td>不限</td></tr></tbody></table><p>如下图所示，在已有A记录的情况下，添加NS记录，系统会进行报错。<br><img src="/img/content/duoji/DNS%E8%AE%B0%E5%BD%95%E5%86%B2%E7%AA%81.png" alt="DNS记录冲突"><br>知道DNS解析记录的类型之后，我们来看一下怎么通过DNS解析来实现负载均衡</p><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><h3 id="负载均衡实现方式"><a href="#负载均衡实现方式" class="headerlink" title="负载均衡实现方式"></a>负载均衡实现方式</h3><h4 id="通过A记录方式实现负载均衡"><a href="#通过A记录方式实现负载均衡" class="headerlink" title="通过A记录方式实现负载均衡"></a>通过A记录方式实现负载均衡</h4><table><thead><tr><th>主机记录</th><th>记录类型</th><th>线路类型</th><th>记录值</th><th>TTL</th></tr></thead><tbody><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.1</td><td>600</td></tr><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.2</td><td>600</td></tr><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.3</td><td>600</td></tr><tr><td>www</td><td>A</td><td>默认</td><td>200.202.101.4</td><td>600</td></tr></tbody></table><p>同一个域名配置多个IP地址，解析返回得到的 IP 地址是轮询随机得到的 IP 地址，这样，本地DNS服务器会向客户端返回多个IP地址作为域名的查询结果，并且这些IP地址的排列顺序是轮换的。客户端一般会选择首个IP地址进行访问。<br>通过A记录方式实现负载均衡不会根据服务器负载和运行状况进行分配。</p><h4 id="通过CNAME方式实现负载均衡"><a href="#通过CNAME方式实现负载均衡" class="headerlink" title="通过CNAME方式实现负载均衡"></a>通过CNAME方式实现负载均衡</h4><p>我们知道顶级域名有多个，当网站做大的时候，我们通常会把多个项级域名都买下来，指向同一个网站。比如<br><a href="http://www.taobao.com/">www.taobao.com</a><br><a href="http://www.taobao.cn/">www.taobao.cn</a><br><a href="http://www.taobao.org/">www.taobao.org</a><br>都指向了淘宝网。而我们希望多对外域名统一作一个负载均衡。那么我们可以将多个域名指向同一个CNAME别名，再将CNAME别名指向多个A记录来进行负载均衡。</p><h4 id="负载均衡器作为权威DNS服务器"><a href="#负载均衡器作为权威DNS服务器" class="headerlink" title="负载均衡器作为权威DNS服务器"></a>负载均衡器作为权威DNS服务器</h4><p>我们可以建立DNS服务器，通过godaddy等平台将注册自己的DNS服务器，再将域名映射一个NS记录到自己的DNS服务器。这里，自己的DNS服务器将实现负载均衡功能。</p><h4 id="负载均衡器作为代理DNS服务器"><a href="#负载均衡器作为代理DNS服务器" class="headerlink" title="负载均衡器作为代理DNS服务器"></a>负载均衡器作为代理DNS服务器</h4><p>在这种方式下，负载均衡器被注册为一个域名空间的权威DNS服务器，而真正的权威域名服务器则部署在负载均衡器后面。所有的DNS请求都会先到达负载均衡器，由负载均衡器转发至真正的权威DNS服务器，然后修改权威DNS服务器返回的响应信息，从而实现负载均衡功能。<br>为实现这一过程，首先要将对外公布的权威DNS服务器的地址注册成负载均衡器上的VIP地址。真正的权威DNS服务器正常响应浏览器的DNS请求，返回域名解析结果列表，这个响应会先发送到负载均衡器，而负载均衡器会根据自己的策略选择一个性能最好的服务器IP并修改DNS服务器的应答信息，然后将应答信息转发给客户。负载均衡器只修改需要实现GSLB的域名的DNS查询响应，对其他请求透明转发，这样就不会影响整个域名空间的解析性能。</p><h3 id="DNS负载均衡缺点"><a href="#DNS负载均衡缺点" class="headerlink" title="DNS负载均衡缺点"></a>DNS负载均衡缺点</h3><p>DNS负载均衡有一个很大的缺点就是延时性问题，在做出调度策略改变以后，由于DNS各级节点的缓存并不会及时的在客户端生效，而且DNS负载的调度策略比较简单，无法满足更复杂的业务需求。</p><h1 id="CDN-内容分发网络-分流"><a href="#CDN-内容分发网络-分流" class="headerlink" title="CDN(内容分发网络)分流"></a>CDN(内容分发网络)分流</h1><p>抛却其他影响服务质量的因素，仅从网络传输的角度看，一个互联网系统的速度取决于以下四个因素。</p><ul><li>网站服务器的出口带宽。</li><li>用户客户端的入口带宽。</li><li>从网站到用户经过的不同运营商之间的互联节点的带宽</li><li>从网站到用户的物理链路传输时延</li></ul><p>除了第2用户的入口带宽是由用户换一个更好的宽带才能改善之外，其余三个，我们可以通过构建一个离用户近的，带宽大的服务来实现。这个离用户近、带宽大的服务就是CDN。<br>CDN的工作流程为：<br><img src="/img/content/duoji/cdn.jpeg" alt="CDN工作流程"></p><ol><li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li><li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</li><li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</li><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。<h1 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h1>当我们通过dns解析或者cdn解析拿到内容时，如果内容没变化，那么我们希望客户端能尽量的把数据缓存起来。客户端属于最边缘的计算载体，客户端缓存一是加快获取数据的速度，二是减轻CDN与服务器的压力。我们知道，缓存是否能够应用的好，就看缓存有什么样的刷新策略。根据不同的缓存策略，Http缓存可以分为以下几种。<h2 id="状态缓存"><a href="#状态缓存" class="headerlink" title="状态缓存"></a>状态缓存</h2>状态缓存是指不经过服务器，客户端直接根据缓存信息对目标网站的状态判断，以前只有301/Moved Permanently（永久重定向）这一种；后来在RFC6797中增加了HSTS（HTTP Strict Transport Security）机制，用于避免依赖301/302跳转HTTPS时可能产生的降级中间人劫持，这也属于另一种状态缓存。<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><img src="/img/content/duoji/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98.png" alt="客户端强制缓存.png"><br>Expires：http response的响应时间。<br>Cache-control：控制浏览器中页面缓存状态。<br>Last-Modified：浏览器最后一次请求服务端资源修改的日期。<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/content/duoji/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="协商缓存.png"></h2><p>tag/If-None-Match：url实体标签，类似于token，如果没有修改就返回状态码304，不会发送资源。<br>If-Modified-Since：再次请求服务端资源修改的日期，如果没有修改就返回状态码304，不会发送资源。<br>Cache-control设置了max-age与s-maxage值的话，Expires会被忽略，为了保证客户端能够获取到最新资源，建议都定义以上字段。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h2><p>硬件负载均衡是通过专门的硬件设备从而来实现负载均衡功能，比如：交换机、路由器就是一个负载均衡专用的网络设备。<br>目前典型的硬件负载均衡设备有两款：F5 和 A10。<br><strong>硬件负载均衡的优点：</strong></p><ul><li>功能强大：支持各层级负载均衡及全面负载均衡算法；</li><li>性能强大：性能远超常见的软件负载均衡器；</li><li>稳定性高：硬件负载均衡，大规模使用肯定是严格测试过的；</li><li>安全防护：除具备负载均衡功能外，还具备防火墙、防 DDoS 攻击等安全功能；</li></ul><p><strong>硬件负载均衡的缺点：</strong></p><ul><li>价格昂贵；</li><li>可扩展性差；</li><li>调试维护麻烦；<h2 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h2>负载均衡又分为四层负载均衡和七层负载均衡。四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。<br>七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去，因此七层负载均衡的主要工作就是代理。<h3 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h3>四层负载均衡在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。其中，我们可以修改IP地址，也可以修改MAC地址。四层负载均衡的优点是不对数据进行完全解析，不跟客户端建立连接（握手），请求分发的效率快。缺点是不支持更为灵活的负载均衡方式，比如基于url、session、动静分离等。<br>目前主要有四层转发模式：DR模式、NAT模式、TUNNEL模式、FULLNAT模式。<h4 id="实现模式"><a href="#实现模式" class="headerlink" title="实现模式"></a>实现模式</h4><h5 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h5>DR(Direct Routing, 直接路由模式)，也叫作三角传输，过修改数据包的目的MAC地址来让流量经过二层转发到达应用服务器，这样应用服务器就可以直接将应答发给应用服务器，性能比较好。作法为负载均衡服务器修改请求数据包的目标MAC地址，并且在Real Service服务配置只有自己可见的lo:VIP，实现数据包的接收（自己没有VIP的话，服务并不会接收数据包）。<br><img src="/img/content/duoji/DR.png" alt="DR模式"><br>整个转发的流程为：</li></ul><ol><li>客户端发送请求，源IP：CIP，目标IP：VIP</li><li>LB接收到请求，将数据帧中的目标MAC地址修改为Real Service的MAC 地址，通过调度算法选择转发到那台Real Service。</li><li>Real Service 接收到请求，发现自己有VIP，端口号也匹配。于是接收数据，进行业务处理。并用VIP为IP地址，将响应数据直接发送给客户端。</li></ol><p>DR模式下，LB只接收请求进行转发，响应数据有Real Service直接发送给客户端，降低了LB的压力。但是NAT和DR都需要LB和Real Service处于同一网段，无法将RS部署在不同的机房。</p><h5 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h5><p>NAT(Network Address Translation，网络地址转换)模式通过修改数据包的目的IP地址，让流量到达应用服务器，这样做的好处是数据包的目的IP就是应用服务器的IP，因此不需要再在应用服务器上配置VIP了。缺点是由于这种模式修改了目的IP地址，这样如果应用服务器直接将应答包发给客户端的话，其源IP是应用服务器的IP，客户端就不会正常接收这个应答，因此我们需要让流量继续回到负载均衡，负载均衡将应答包的源IP改回VIP再发到客户端，这样才可以保证正常通信，所以NAT模式要求负载均衡需要以网关的形式存在于网络中。<br>作法为在专用内部网络中，分配一台实现了NAT技术的路由或服务Load Balance Service。这台负载均衡服务器分配了公网IP(VIP, Virtual IP)，所有客户端请求服务都请求此IP。LBS通过不同的算法，将请求数据包的源IP以及目标IP修改，转发到真实服务器（Real Service）上进行业务处理。其具体的步骤可以分为：<br><img src="/img/content/duoji/NAT.png" alt="NAT模式"><br>1、客户端发送请求，源IP为：CIP，目标IP为：VIP<br>2、LBS接收请求，解析数据报IP地址，将源IP修改为：VIP，目录IP修改为：RIP。具体修改为那个目标IP，通过算法的不同进行不同的选择。并将相关信息进行存储（MAP）后发送数据包。<br>3、RS 接收到请求，进行业务处理。并将结果返回给LBS。<br>4、LBS收到相应数据包，根据之前存储的MAP，将对应的SIP改为：VIP，TIP改为：CIP，将数据包发送出去。<br>注意：连接是建立在 客户端 与 Real Service 之间，LBS只是解析数据包IP和端口号，进行修改转发而已。<br>__可以看到通过NAT模式进行负载均衡，所有的请求以及响应都要通过LB服务器，当访问量较大时，LB服务器会成为瓶颈__。</p><h5 id="TUNNEL模式"><a href="#TUNNEL模式" class="headerlink" title="TUNNEL模式"></a>TUNNEL模式</h5><p>TUN思想跟DR类似，在Real Service上配置一个内部可见的lo:VIP地址，LB通过封装或修改数据包信息实现请求的转发。不同于DR模式LB修改MAC地址，为了实现不同网段的Real Service负载，TUN模式通过在原有的数据包外封装一层IP Tunnel ，实现数据的转发。由于封装完 IP Tunnel 后数据包和正常的数据包结构不同，所以Real Service的OS需要支持Tunnel功能。<br><img src="/img/content/duoji/TUN.png" alt="TUNNEL模式"><br>TUN转发的具体流程为：</p><ol><li>客户端发送请求，SIP：CIP；TIP：VIP</li><li>LB接收到请求，在数据包外在封装一层IP Tunnel，其SIP为DIP，TIP为RIP3.</li><li>Real Service接收到请求，根据IP Tunnel 的IP地址判断出是发送给自己的请求，进行后续处理。根据源数据包的IP地址，判断出客户端的地址为CIP，并且VIP也是自己配置的IP，对数据进行业务处理后，通过VIP将响应数据直接发送到客户端。<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h5>LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器。它是一个由章文嵩博士发起的自由软件项目，官方站点是<a href="http://www.linuxvirtualserver.org/">www.linuxvirtualserver.org</a>。现在LVS已经是 Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须要重新编译内核以支持LVS功能模块，但是从Linux2.4内核以后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。<br>LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。<br>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：Linux的门户网站（<a href="http://www.linux.com/">www.linux.com</a>）、向RealPlayer提供音频视频服务而闻名的Real公司（<a href="http://www.real.com/">www.real.com</a>）、全球最大的开源网站（sourceforge.net）等。<br>LVS目前有三种IP负载均衡技术（VS/NAT、VS/TUN和VS/DR）；十种调度算法（rrr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq） <h3 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h3>通常使用的nginx负载均衡技术， 在网络分层中处于应用层（第七层）的，nginx与客户端建立TCP连接（握手），然后再根据请求信息以及本地配置信息，将请求灵活的分发到不同的服务上。nginx这类7层负载均衡的优缺点都很明显。</li></ol><ul><li><p>优点：可以将请求分发到不同的服务上，并且可以根据请求信息进行灵活的代理转发，实现更复杂的负载均衡控制，比如基于url、session、动静分离等；由于请求会通过负载均衡服务器，负载均衡服务器会过滤一些请求（例如：DOS攻击）避免所有请求信息都打到服务器上，保障了服务器的稳定运行。</p></li><li><p>缺点：处于网络分层的最上层，需要对数据进行解析，与客户端建立连接，效率比较低。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。<br>nginx负载均衡的几种常用方式</p><h5 id="轮循"><a href="#轮循" class="headerlink" title="轮循"></a>轮循</h5><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server 192.168.0.3;<br>    server 192.168.0.7;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h5><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h5><p>在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。<br>我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="fair-三方"><a href="#fair-三方" class="headerlink" title="fair(三方)"></a>fair(三方)</h5><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server server1;<br>    server server2;<br>    fair;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="url-hash-三方"><a href="#url-hash-三方" class="headerlink" title="url_hash(三方)"></a>url_hash(三方)</h5><p>按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backserver &#123;<br>    server squid1:3128;<br>    server squid2:3128;<br>    hash $request_uri;<br>    hash_method crc32;<br>&#125;<br></code></pre></td></tr></table></figure><p>在需要使用负载均衡的server中增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxy_pass http://backserver/; <br>upstream backserver&#123; <br>    ip_hash; <br>    server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载) <br>    server 127.0.0.1:8080 weight=2; (weight 默认为1.weight越大，负载的权重就越大) <br>    server 127.0.0.1:6060; <br>    server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) <br>&#125; <br></code></pre></td></tr></table></figure><p>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br>fail_timeout:max_fails次失败后，暂停的时间<br>配置实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">user  nobody;</span><br><br>worker_processes  4;<br>events &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最大并发数</span><br>worker_connections  1024;<br>&#125;<br>http&#123;<br>    # 待选服务器列表<br>    upstream myproject&#123;<br>        # ip_hash指令，将同一用户引入同一服务器。<br>        ip_hash;<br>        server 125.219.3.7 fail_timeout=60s;<br>        server 172.31.3.7;<br>    &#125;<br><br>    server&#123;<br>        # 监听端口<br>        listen 80;<br>        # 根目录下<br>        location / &#123;<br>        # 选择哪个服务器列表<br>            proxy_pass http://myproject;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="应用分流"><a href="#应用分流" class="headerlink" title="应用分流"></a>应用分流</h1><p>当开发人员发现系统中某些资源的构建成本比较高，而这些资源又有被重复使用的可能时，会很自然地产生“循环再利用”的想法，将它们放到Map容器中，待下次需要时取出重用，避免重新构建，这种原始朴素的复用就是最基本的缓存。在应用中使用缓存，可以从缓存中取得数据，返回结果。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><h4 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h4><p>Memcached 是一个开源的、高性能的分布式 key/value 内存缓存系统。它以 key/value 键值对的方式存储数据，是一个键值类型的 NoSQL 组件。<br>Memcached 简称 Mc，是一个典型的内存型缓存组件，这就意味着，Mc 一旦重启就会丢失所有的数据。如下图所示，Mc 组件之间相互不通信，完全由 client 对 key 进行 Hash 后分布和协同。Mc 采用多线程处理请求，由一个主线程和任意多个工作线程协作，从而充分利用多核，提升 IO 效率。<br>Mc 的特性。</p></li><li><p>Mc 最大的特性是高性能，单节点压测性能能达到百万级的 QPS。</p></li><li><p>其次因为 Mc 的访问协议很简单，只有 get/set/cas/touch/gat/stats 等有限的几个命令。Mc 的访问协议简单，跟它的存储结构也有关系。</p></li><li><p>Mc 存储结构很简单，只存储简单的 key/value 键值对，而且对 value 直接以二进制方式存储，不识别内部存储结构，所以有限几个指令就可以满足操作需要。</p></li><li><p>Mc 完全基于内存操作，在系统运行期间，在有新 key 写进来时，如果没有空闲内存分配，就会对最不活跃的 key 进行 eviction 剔除操作。</p></li><li><p>最后，Mc 服务节点运行也特别简单，不同 Mc 节点之间互不通信，由 client 自行负责管理数据分布。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis 是一款基于 ANSI C 语言编写的，BSD 许可的，日志型 key-value 存储组件，它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。<br>Redis 是 Remote dictionary server 即远程字典服务的缩写，一个 Redis 实例可以有多个存储数据的字典，客户端可以通过 select 来选择字典即 DB 进行数据存储。<br>同为 key-value 存储组件，Memcached 只能支持二进制字节块这一种数据类型。而 Redis 的数据类型却丰富的多，它具有 8 种核心数据类型，每种数据类型都有一系列操作指令对应。Redis 性能很高，单线程压测可以达到 10~11w 的 QPS。<br>虽然 Redis 所有数据的读写操作，都在内存中进行，但也可以将所有数据进行落盘做持久化。Redis 提供了 2 种持久化方式。</p></li><li><p>快照方式，将某时刻所有数据都写入硬盘的 RDB 文件；</p></li><li><p>追加文件方式，即将所有写命令都以追加的方式写入硬盘的 AOF 文件中。</p></li></ul><p>线上 Redis 一般会同时使用两种方式，通过开启 appendonly 及关联配置项，将写命令及时追加到 AOF 文件，同时在每日流量低峰时，通过 bgsave 保存当时所有内存数据快照。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>本地缓存和应用同属于一个进程，使用不当会影响服务稳定性，所以通常需要考虑更多的因素，例如容量限制、过期策略、淘汰策略、自动刷新等。常用的本地缓存方案有：</p><ul><li>根据HashMap自实现本地缓存</li><li>Guava Cache</li><li>Caffeine</li><li>Encache<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2>如果应用中的请求需要花费的时间比较长，或者一时间接收了大量的请求。我们可以使用消息中间件来进行分流。<br>当前业界比较流行的开源消息中间件包括：ActiveMQ、RabbitMQ、RocketMQ、Kafka、ZeroMQ等，其中应用最为广泛的要数RabbitMQ、RocketMQ、Kafka 这三款。Redis在某种程度上也可以是实现类似 “Queue” 和“ Pub/Sub” 的机制，严格意义上不算消息中间件。<br><img src="/img/content/duoji/%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt="消息中间件"> <h1 id="数据库分流"><a href="#数据库分流" class="headerlink" title="数据库分流"></a>数据库分流</h1><h2 id="单表容量"><a href="#单表容量" class="headerlink" title="单表容量"></a>单表容量</h2>在中国互联网技术圈流传着这么一个说法：MySQL 单表数据量大于 2000 万行，性能会明显下降。再后来，阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。对此，有阿里的黄金铁律支撑，所以，很多人设计大数据存储时，多会以此为标准，进行分表操作。<br>我们知道，InnoDB存储引擎最小储存单元——页（Page），一个页的大小是16K。<br>这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数<em>单个叶子节点记录行数。<br>假设一行记录的数据大小为1k，单个叶子节点（页）中的记录数=16K/1K=16。现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170</em>16=18720条这样的数据记录。<br>根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170<em>1170</em>16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。<br><img src="/img/content/duoji/B+Index.png" alt="image.png"><br>对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的可以，所以InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。<br>设计InnoDB的大佬为了缓存磁盘中的页，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做Buffer Pool（中文名是缓冲池）。那它有多大呢？这个其实看我们机器的配置，最小是5M,但如果你是土豪，你有512G内存，你分配个几百G作为Buffer Pool也可以的。<br>Buffer Pool是一个LRU缓存。从上图我们看到，如果表常用的话，数据在2千万以下，索引页还是很容易被缓存进目录的。所以查询的速度很快。但如果树高再增加一层，就需要21G的内存空间来进行索引，如果内存配置的够大的话，也是可以的。但如果再高一层，需要24T的内存来缓存索引，这个是土豪也不行的吧。<br>事实上，性能最快的肯定是数据都在内存里，2000万涉及到的是索引值是不是都能缓存进内存。而500万更多的是考虑到叶子节点缓存的占用。如果常用的叶子节点数据能够常驻在内存中，那数据应该查询的更快。<h2 id="分库分表策略"><a href="#分库分表策略" class="headerlink" title="分库分表策略"></a>分库分表策略</h2>既然表的容量有限制，那么最好的办法就是分库分表。分库分表有水平与垂直两个策略来说。垂直分表就是按照业务，把一张表分成几个业务表，从而减少单表数量，每个表的字段不一样。水平分表就是把一张表的数据切成多份，存储在不同的表中，每个表的字段一样。<h3 id="水平分库分表策略"><a href="#水平分库分表策略" class="headerlink" title="水平分库分表策略"></a>水平分库分表策略</h3><h4 id="取模分片"><a href="#取模分片" class="headerlink" title="取模分片"></a>取模分片</h4>错误做法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shardByMod</span><span class="hljs-params">(Long userId)</span> &#123; <br>    <span class="hljs-comment">// 对库数量取余结果为库序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> Math.abs(userId % DB_CNT); <br>    <span class="hljs-comment">// 对表数量取余结果为表序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tblIdx</span> <span class="hljs-operator">=</span> Math.abs(userId % TBL_CNT); <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(dbIdx, tblIdx); <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><p>其实稍微思索一下，我们就会发现，以 10 库 100 表为例，如果一个  值对 100 取余为 0，那么它对 10 取余也必然为 0。这就意味着只有 0 库里面的 0 表才可能有数据，而其他库中的 0 表永远为空!如果一个值对100取余为1，对10取余肯定也为1，那么1库1表才可会有数据。类似的我们还能推导到，0 库里面的共 100 张表，只有 10 张表中(个位数为 0 的表序号)才可能有数据。<br>这就带来了非常严重的数据偏斜问题，因为某些表中永远不可能有数据，最大数据偏斜率达到了无穷大。<br>事实上，只要库数量和表数量非互质关系，都会出现某些表中无数据的问题。<br>么是不是只要库数量和表数量互质就可用用这种分库分表方案呢?比如我用 11 库 100 表的方案，是不是就合理了呢?<br>答案是否定的，我们除了要考虑数据偏斜的问题，还需要考虑可持续性扩容的问题，一般这种 Hash 分库分表的方案后期的扩容方式都是通过翻倍扩容法，那 11 库翻倍后，和 100 又不再互质。<br>当然，如果分库数和分表数不仅互质，而且分表数为奇数(例如 10 库 101 表)，则理论上可以使用该方案，但是我想大部分人可能都会觉得使用奇数的分表数比较奇怪吧。<br>正确做法：<br>一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shardByMod</span><span class="hljs-params">(Long userId)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">slot</span> <span class="hljs-operator">=</span> DB_CNT*TBL_CNT;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(userId%slot); <br>&#125; <br></code></pre></td></tr></table></figure><p>将库与表取合标个序号，直接用序号取模。<br>二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shardByMod</span><span class="hljs-params">(Long userId)</span> &#123; <br>    <span class="hljs-comment">// 对库数量取余结果为库序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> Math.abs(userId/DB_CNT); <br>    <span class="hljs-comment">// 对表数量取余结果为表序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tblIdx</span> <span class="hljs-operator">=</span> Math.abs(dbIdx % TBL_CNT); <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(dbIdx, tblIdx); <br>&#125; <br></code></pre></td></tr></table></figure><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>实现起来比较简单。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>扩容数据需要迁移<br>不利于范围扫描查询操作</p><h4 id="Range范围分库分表"><a href="#Range范围分库分表" class="headerlink" title="Range范围分库分表"></a>Range范围分库分表</h4><p>顾名思义，该方案根据数据范围划分数据的存放位置。<br>举个最简单例子，我们可以把订单表按照年份为单位，每年的数据存放在单独的库(或者表)中。<br>如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">rangeShardByYear</span><span class="hljs-params">(String orderId)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> Integer.parseInt(orderId.substring(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)); <br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;t_order_&quot;</span> + year; <br>&#125; <br></code></pre></td></tr></table></figure><p>通过数据的范围进行分库分表，该方案是最朴实的一种分库方案，它也可以和其他分库分表方案灵活结合使用。<br>时下非常流行的分布式数据库：TiDB 数据库，针对 TiKV 中数据的打散，也是基于 Range 的方式进行，将不同范围内的[StartKey，EndKey)分配到不同的 Region 上。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>集群扩容后，指定新的范围落在新节点即可，无需进行数据迁移。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li><p>最明显的就是数据热点问题，例如上面案例中的订单表，很明显当前年度所在的库表属于热点数据，需要承载大部分的 IO 和计算资源。</p></li><li><p>新库和新表的追加问题。一般我们线上运行的应用程序是没有数据库的建库建表权限的，故我们需要提前将新的库表提前建立，防止线上故障。</p></li><li><p>这点非常容易被遗忘，尤其是稳定跑了几年没有迭代任务，或者人员又交替频繁的模块。</p><h4 id="Hash分库分表"><a href="#Hash分库分表" class="headerlink" title="Hash分库分表"></a>Hash分库分表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ShardCfg <span class="hljs-title function_">shard</span><span class="hljs-params">(String userId)</span> &#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> userId.hashCode(); <br>    <span class="hljs-comment">// 对库数量取余结果为库序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dbIdx</span> <span class="hljs-operator">=</span> Math.abs(hash / DB_CNT); <br>    <span class="hljs-comment">// 对表数量取余结果为表序号 </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tblIdx</span> <span class="hljs-operator">=</span> Math.abs(dbIdx % TBL_CNT); <br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardCfg</span>(dbIdx, tblIdx); <br>&#125; <br></code></pre></td></tr></table></figure><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>实现起来比较简单。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>扩容数据需要迁移<br>不利于范围扫描查询操作</p><h4 id="融合算法"><a href="#融合算法" class="headerlink" title="融合算法"></a>融合算法</h4><p>这时我们应该意识到，以上介绍的哈希和范围的分片算法并不是非此即彼，二选一的。相反，我们可以灵活地组合它们。<br>例如，我们可以建立一个多级分片策略，该策略在最上层使用哈希算法，而在每个基于哈希的分片单元中，数据将按顺序存储。</p><h2 id="扩容方案"><a href="#扩容方案" class="headerlink" title="扩容方案"></a>扩容方案</h2><h3 id="翻倍扩容法"><a href="#翻倍扩容法" class="headerlink" title="翻倍扩容法"></a>翻倍扩容法</h3><p><img src="/img/content/duoji/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%BF%BB%E5%80%8D%E6%89%A9%E5%AE%B9%E6%96%B9%E6%A1%88.gif" alt="分库分表翻倍扩容方案"><br>具体的流程大致如下：<br>step1：为每个节点都新增从库，开启主从同步进行数据同步。<br>step2：主从同步完成后，对主库进行禁写。<br>此处禁写主要是为了保证数据的正确性。若不进行禁写操作，在以下两个时间窗口期内将出现数据不一致的问题：</p></li><li><p>断开主从后，若主库不禁写，主库若还有数据写入，这部分数据将无法同步到从库中。</p></li><li><p>应用集群识别到分库数翻倍的时间点无法严格一致，在某个时间点可能两台应用使用不同的分库数，运算到不同的库序号，导致错误写入。</p></li></ul><p>step3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。<br>step4：从库升级为集群节点，业务应用识别到新的分库数后，将应用新的路由算法。<br>一般情况下，我们将分库数的配置放到配置中心中，当上述三个步骤完成后，我们修改分库数进行翻倍，应用生效后，应用服务将使用新的配置。<br>这里需要注意的是，业务应用接收到新的配置的时间点不一定一致，所以必定存在一个时间窗口期，该期间部分机器使用原分库数，部分节点使用新分库数。这也正是我们的禁写操作一定要在此步完成后才能放开的原因。<br>step5：确定所有的应用均接受到库总数的配置后，放开原主库的禁写操作，此时应用完全恢复服务。<br>启动离线的定时任务，清除各库中的约一半冗余数据。<br>为了节省磁盘的使用率，我们可以选择离线定时任务清除冗余的数据。也可以在业务初期表结构设计的时候，将索引键的 Hash 值存为一个字段。</p><h3 id="一致性Hash扩容"><a href="#一致性Hash扩容" class="headerlink" title="一致性Hash扩容"></a>一致性Hash扩容</h3><h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><ol><li>我们把节点通过hash后，映射到一个范围是[0，2^32]的环上</li></ol><p><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E6%9C%BA%E5%99%A8.png" alt="一致性hash机器"><br>2.把数据也通过hash的方式映射到环上<br><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E6%95%B0%E6%8D%AE.png" alt="一致性hash数据.png"><br>3.因为节点越多，它们在环上的分布就越均匀，使用虚拟节点还可以降低节点之间的负载差异<br><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png" alt="一致性hash虚拟节点.png"></p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>主要步骤如下：</p><ul><li>step1：针对需要扩容的数据库节点增加从节点，开启主从同步进行数据同步。</li><li>step2：完成主从同步后，对原主库进行禁写。此处原因和翻倍扩容法类似，需要保证新的从库和原来主库中数据的一致性。</li><li>step3：同步完全完成后，断开主从关系，理论上此时从库和主库有着完全一样的数据集。</li><li>step4：修改一致性 Hash 范围的配置，并使应用服务重新读取并生效。</li><li>step5：确定所有的应用均接受到新的一致性 Hash 范围配置后，放开原主库的禁写操作，此时应用完全恢复服务。</li></ul><p>启动离线的定时任务，清除冗余数据。<br>可以看到，该方案和翻倍扩容法的方案比较类似，但是它更加灵活，可以根据当前集群每个节点的压力情况选择性扩容，而无需整个集群同时翻倍进行扩容。<br><img src="/img/content/duoji/%E4%B8%80%E8%87%B4%E6%80%A7hash%E6%89%A9%E5%AE%B9.jpg" alt="一致性hash扩容.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>负载均衡</tag>
      
      <tag>CDN</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD与EDA-核心逻辑提炼方法论</title>
    <link href="/2022/11/28/DDD%E4%B8%8EEDA-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E6%8F%90%E7%82%BC%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <url>/2022/11/28/DDD%E4%B8%8EEDA-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E6%8F%90%E7%82%BC%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>在【<a href="http://3world.top/2022/11/17/DDD%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/">DDD与应用架构</a>】一文中我们说过，应用架构的存在就是为了把一团混沌的代码变得有秩序，好管理。我们保持最核心逻辑不变，就可以保持系统的稳定与发展。领域驱动设计的作者Eric Evans 说：“为了使领域模型成为有价值的资产，必须整齐地梳理出模型的真正核心，并完全根据这个核心来创建应用程序的功能”。那么问题来了，我们要怎么梳理出模型的真正核心呢？Eric是这么说的:</p><blockquote><p>“对模型进行提炼。找到CORE DOMAIN并提供一种易于区分的方法把它与那些起辅助作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩CORE DOMAIN。<br>让最有才能的人来开发CORE DOMAIN，并据此要求进行相应的招聘。在CORE DOMAIN中努力开发能够确保实现系统蓝图的深层模型和柔性设计。仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的CORE。”<br>摘录来自<br>领域驱动设计：软件核心复杂性应对之道<br>[美] 埃里克 埃文斯（Eric Evans）</p></blockquote><p>这里我必需提一下Eric说的上下文，避免造成误会。Eric说这段话是说大部分优秀的开发人员都去进行基础设施建设了，而能力差的那些常常会去设计数据库，无休止的进行CURD。我个人比较赞同这种观点。领域设计可能需要大家在观念上有所转变，现在大多数开发都属于业务开发，业务开发最重要的不是说对一些基础设施了解的有什么深入，而是应该对你所属的行业了解到一定程度，能够刻画你所属的行业的核心业务逻辑。这里不是说搞明白基础设施不重要，而是现有的软件开发基础设施已经比较完善，借助于分布式，中间件，很多公司的开发人员都能构建一个比较可靠的秒杀系统了，高并发、大流量这些前些年听起来很酷炫的技能现在可能随处可见。而业务人员未来的竞争力可能会在于对某种垂直行业的认知，而这些认知，能帮助你成为Eric文中有才能的人。当然，成为真正有才能的人，可能还需要了解一些方法论，帮助你更好的刻画领域。</p><h1 id="看待问题的角度"><a href="#看待问题的角度" class="headerlink" title="看待问题的角度"></a>看待问题的角度</h1><p>场景一：<br>西风公司的数据智能部门需要对公司楼下的早餐店进分析，想看看公司在餐饮行业有没有机会。于是派了公司的两个数据大佬西哥与风哥去调研。<br>一天之后，西风与风哥分别分享了自己的调查情况。<br><strong>西哥的调研报告</strong></p><blockquote><p>5:30AM  早餐店门打开了<br>6:00AM   包子蒸好了<br>6:10AM    豆浆做好了<br>6:30AM    包子出售了10个，豆浆出售了20个。支付宝收到金额35元，支付收到金额25元。<br>。。。。</p></blockquote><p><strong>风哥的调研报告</strong></p><blockquote><p>老板与老板娘两个人一大早打开了早餐店，并且开始蒸包子，做豆浆。做蒸包子的时候，老板娘又去门口把今天包子与豆浆的易拉宝上。易拉宝上记录着今天早餐店的优惠价格。<br>早的时候，大部分都是楼旁边小区的居民出来买，居民们大多时候都是慢慢悠悠的走过来，包子豆浆一块买，老人家一般会自带盆，让老板把早餐装盆里，有些还会坐在店里吃。快到上班的时候，很多白领会跑着过来，快速的选择已经打包好的组合套餐，拎着就往楼上跑。。。</p></blockquote><p>场景二：<br>小西与小风都是艾薇儿的忠实粉丝，一天，小西与小风同时收到艾薇儿的新歌海报推送。<br>小风一看艾薇儿出新歌了，立马打开音乐播放器，听了起来。<br>小西则看着海报，艾薇儿把头发染成了蓝色，身穿黑红相间的卫衣，身上挂着一把吉它，右手指向前方。<br>“不愧是女神，还是这么酷这么朋克”，小西慢慢的欣赏着海报。</p><p>以上的两个场景可能我们中的大部分都经历过，一千个读者就一千个哈姆雷特，每个人看待世界的角度都是不同的。因此，我们想要提炼出core domain,首先我们要先明确一个点，我们站在哪个角度看待问题的。</p><h2 id="时间维度"><a href="#时间维度" class="headerlink" title="时间维度"></a>时间维度</h2><p>即使有理论去说明我们可以穿越时间，但毕竟都没实现过。所以我们可以这么认为，时间是最稳定的东西。任何事务肯定会在时间的长河上留下足迹，并且一旦留下足迹，肯定是一成不变的。<br>我们按时间的维度来描述事情，一般会说，某时某刻发生了什么事。这里的【事】我们可以理解为事件，某时某刻一个什么事件发生了。比如场景二中，小风收到艾薇儿的新歌海报推送，就是那个时刻，【艾薇儿发新歌】这个事件发生了。<br>那么，我们站在时间的维度上，只要在一个完整的业务周期内把这个时间线内的所有事件描述出来，就能通过事件来驱动整个业务的运行。EDA，Event Driven Architecture，事件驱动架构，描述的就是这个。驱动，英语单词Driven。我们平常说驱动，一般用在汽车发动机上，有一台发动机，加上一些组件，就能让汽车跑起来。我理解的驱动就是一个核心，加上一些组件，保证业务的运行。EDA这里事件就是核心，以事件为核心，加上一些组件，比如事件的发送方、事件的接收者，事件的响应方法等，从而保证业务的运行。</p><h2 id="空间维度"><a href="#空间维度" class="headerlink" title="空间维度"></a>空间维度</h2><p>更多的时候，我们看待问题会更加的感性一些，谁谁谁在什么地方干了什么事，而并不在意时间。英语单词(Party-Place-Thing),取首字母PPT,来说明谁在什么地方干了什么事。在业务需求描述中，只要发现领域概念与人、组织机构、地点或物品相关，我们就就可以识别其为 PPT 对象。比如场景一中风哥的调研报告，老板、老板娘两个店铺拥有者在店里打开了门，在店里蒸了包子等。<br>DDD(Domain Driven Design)，领域驱动设计，如EDA一样，这里是以领域为核心的。而领域，常常是跟某个领域方面的专家交流，在于专家的交流中抽象出来的模型。空间维度，我们更适合使用DDD来进行领域设计。<br><img src="/img/content/eda/domainDriven.png" alt="领域驱动设计"></p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>上面我们介绍的时间维度与空间维度来提炼出核心逻辑，那我们怎么选择呢。<br>我们看到，时间在企业应用中最大的用处是可追溯，假设说你的应用场景中追溯是比较重要的，如果缺少对某个东西的记录，就会影响到商业的运营和管理，或者引起法律上的纠纷。那么，你应该从时间角度来进行切入。比如笔者现在从事的财务与会计工作，财务上的每一笔账都要往前追溯，以满足审计的需要，这样，通过以时间维度构建出来的事件，可以追溯到每个费用的发生情况。再加上cqrs中的命令的话，可以更往前追溯到系统中的操作情况。<br>另外，如果你的应用并没有追溯的需求，或者是只有偶尔有追溯的需求，大部分时间业务都是在执行自己本身的工作，那可能从空间上描述更为合适。如笔者之前从事的天猫工作台有一个功能，小二需要商家关于商品售卖的信息，会给商家下发一个Excel模板，让商家填写之后提交。看似跟时间事件相关，商家某时某刻填了完了Excel上传，会发生一个Excel上传事件，小二根据Excel上传事件来进行运营操作。但事实上，小二并不关心商家什么时候上传了表格，商家实在太多了，要是一个提交后就要操作，那得累死小二。小二只是在截止日之前，去看一下哪些商家没提交，没提交的去提醒一下而已，至于商家到底是1号还是2号提交，3点还是5点提交，小二根本不关心。这种情况下，我们更应该把精力聚焦在小二与商家本身空间上的操作，比如小二发表格、合并表格、分析。<br><img src="/img/content/eda/woqudouyao.png" alt="我全都要.png"><br>另外，不管从时间维度还是空间维度，都是一个切入点，从时间维度进来，找到相关事件之后，还是要从间上找到对应的PPT,使事件可以在PPT中流转。从空间上PPT进行建模，可以通过时间上的事件发生，来理清PPT建模中的联系。</p><h1 id="目的性"><a href="#目的性" class="headerlink" title="目的性"></a>目的性</h1><p>DDD可以很大，也可以很小。上面我们知道了怎么从哪个角度切入来提炼核心逻辑，接下我们要看一下我们要解决的问题到底是什么。我们根据开发的功能大小及重要程序可以将业务系统分为两个，一个为企业经营问题，比如电商公司，交易履约系统及涉及到企业经营性的问题。而运营提出来的操作工作台则经常处理业务功能问题。</p><h2 id="企业经营问题"><a href="#企业经营问题" class="headerlink" title="企业经营问题"></a>企业经营问题</h2><p>涉及到企业经营问题系统的核心模型往往需要保持稳定性，需要慎重，不断打磨好模型，再进行实现。一个业务开发，涉及到企业经营问题系统开发，肯定要了解公司的业务，应该需要与公司的各个部门沟通好各个部分细节，集合各个部门之力，画出公司业务的全链路图，并在全链路图上抽象出模型，模型要得到相关部门的认可。</p><h2 id="业务功能问题"><a href="#业务功能问题" class="headerlink" title="业务功能问题"></a>业务功能问题</h2><p>更多的时候我们接触的是业务功能的开发。你可能接收到的就是一个prd。笔者认为，功能再小，也是可以尝试DDD的，这时候的业务系统的模型不必要非要保持稳定性。DDD并不是为了完美主义者而生。行动起来，不断去迭代它。不要以为会了DDD就能解决一切问题了，DDD只是一种思想，你不随着这种思想去行动的话，一切都不会有什么改变。反之，一开始你基于认知建造了一个很粗糙的模型。可以根据你对业务的不断了解不断调整，把一个很粗糙的模型塑造成你负责的业务系统稳定模型，大家持着对某个领域的统一认知。</p><h1 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h1><p>我们开始领域建模行动了，不管是开发关乎企业经营的应用还是做一个小功能，根据做事的方式，大概可以根据以下两种行动方式。</p><h2 id="有才能的人"><a href="#有才能的人" class="headerlink" title="有才能的人"></a>有才能的人</h2><p>这里的有才能可以基本上需要具备两个特质，社牛与敏锐的分析能力。社牛可以保证你跟领域专家搞好关系，不管是一起抽个烟、还是一起喝杯咖啡，都很有助于你了解业务。敏锐的分析能力可以让你与领域专家沟通的时候可以找到哪些信息是有用的，哪些信息是无用的。<br>如果你具备了这两个特质，那就通过与领域专家进行充分交流，把每个领域专家的说出的核心步骤连接起来。再通过核心步骤提炼出核心领域模型。这里最两个重要的词</p><h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>建模的时候需要与领域方面的专家进行充分交流。领域方面的专家可以是熟悉业务的产品，熟悉业务的运营等。并且两者沟通需处于同一个频道。开发需要了解业务的专用术语，业务要明白开发画的图的意思。<br>我认为，业务与开发沟通模型的时候不要拘泥于UML图等等，只要是大家都看得懂的草图，那就是好的。</p><h3 id="共同"><a href="#共同" class="headerlink" title="共同"></a>共同</h3><p>与领域专家沟通，并且要共同建模，这里共同的意思时要在沟通的时候同时建模。最好在讨论的时候可以把草图画好，大家可以达到统一理解。</p><h2 id="EventStorming"><a href="#EventStorming" class="headerlink" title="EventStorming"></a>EventStorming</h2><p>如果你不是一个很有才能的人，那么你可以试试EventStorming(事件风暴)。相比于一个人去了解各个业务，EventStorming工作模式更需要你当一个主持人。把相关业务方拉在一起，提供一个开会的环境。<br>像这样<br><img src="/img/content/eda/eventstormingLocation.png" alt="eventstorming位置.png"><br>然后大家准备一些有各种颜色的便利贴，每个颜色都有各自的意义，无法互相替代。我们需要以下颜色的便利贴：<br>橘色（正方形）：Event 事件<br>蓝色（正方形）：Command 命令<br>紫色（长方形）: Policy/Process 商业政策/流程<br>黄色（小张长方形）:Actor 角色<br>黄色（长方形）:Aggregate 聚合<br>粉红色（长方形）：System 外部系统<br>红色（正方形）:Hotspot 热点<br>红色（小张长方形）:Problem 疑问<br>绿色（小张长方形）:Opportunity 机会<br>经色（正方形）：Read Model 资料读取模型<br>白色（大张正方形）：Uset Interface 使用者介面<br>再准备一些签字笔，计时器等。<br>最后组织大家对某个问题进行讨论，用便利贴组成整个事件的脉落。<br><img src="/img/content/eda/bianlitie.png" alt="便利贴互动模式.png"><br>最后对整个会议进行整理，从而提炼出核心模型。<br>关于EventStorming,可以看一下eventstorming.com 官网的那本作者Alberto Brandolini自己写的《Introducing EventStorming》。</p><h1 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h1><p>上文接怎么提炼核心逻辑方法论，下面我们讲讲具体实施的方案。</p><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p><img src="/img/content/eda/babieta.png" alt="巴别塔"><br>《圣经·旧约·创世纪》第11章中记录了“巴别塔”的故事。</p><blockquote><p>当时地上的人们都说同一种语言，人们离开东方之后，来到了示拿之地，在那里，人们想法设法烧砖希望能建造一座城和一座高耸入云的塔来传播自己的名声，以免他们被分散到世界各地，上帝来到人间后看到这座塔，说一群只说一种语言的人以后便没有他们做不成的事了，于是上帝将他们的语言打乱，这样他们就互相听不懂对方在说什么了，还把他们分散到了世界各地，这座城市也停止了修建。</p></blockquote><p>一群只说一种语言的人以后便没有他们做不成的事了，在任何时候，大家都会有这样的认识。同样，在任何时候，都会出现语言不同的情况。项目开发也是一样，一个公司不同项目或者不同部门，大家的语言及理解可能都会不一致。为了使事情事半功倍，就要求我们在一个小的范围内语言保持一致。然后有一个统一大局的人，把这个范围内的语言连接在一起，形成整体视图。DDD中小的范围界定有一个名称，叫BoundedContext,限定上下文。</p><h3 id="BoundedContext-限定上下文"><a href="#BoundedContext-限定上下文" class="headerlink" title="BoundedContext(限定上下文)"></a>BoundedContext(限定上下文)</h3><p>Eric在领域驱动设计一书是这样说是限定上下文的：</p><blockquote><p>“任何大型项目都会存在多个模型。而当基于不同模型的代码被组合到一起后，软件就会出现bug、变得不可靠和难以理解。团队成员之间的沟通变得混乱。人们往往弄不清楚一个模型不应该在哪个上下文中使用”<br>模型混乱的问题最终会在代码不能正常运行时暴露出来，但问题的根源却在于团队的组织方式和成员的交流方法。因此，为了澄清模型的上下文，我们既要注意项目，也要注意它的最终产品（代码、数据库模式等）。<br>“一个模型只在一个上下文中使用。”</p></blockquote><p>限定上下文，我理解下来就是能够实施统一语言的一个范围。所谓上下文，就是保持理解的一致。比如利润，在财务系统中利润包含成本、收入、计算方法等，是个很重要的Entity。而在商品系统中，它只是商品的一个属性，商品只需要利润的一个总值而已。这里我们所说利润在财务与商品两个上下文中有不同的含义。<br>再说一下限定上下文与微服务。限定上下文是对于领域的划分，在一个限定上下文大家对模型的理解一致就行。而微服务更多是对应用的拆分。多个微服务应用，可以在一个限定上下文里面，比如财务域限定上下文，里面可以有结算服务、计费服务等。<br>再者就是模块与限定上下文的区分，限定上下文就不说了，模块更多的时指一下命令空间，不管是应用代码中的模块，还是业务上的模块，都是给代码或者业务加上一个空间范围。<br><img src="/img/content/eda/boundedcontext.png" alt="image.png"><br>不同的Bounded Context是通过Context Map来连接起来的，大多数情况下，开发只关心自己的那个域，都在自己的Bounded Context中进行开发，Context Map使不同的上下文中连接起来，形成整体的视图，一个公司的管理人员可以通过整体视图来把握来整体的业务模型。</p><h3 id="Entity-实体-ValueObject-值对象"><a href="#Entity-实体-ValueObject-值对象" class="headerlink" title="Entity(实体)/ValueObject(值对象)"></a>Entity(实体)/ValueObject(值对象)</h3><p>实体与值对象网上有很多描述，这里就不过多的描述了。通常在不进行EventStorming时，我的做法往往是在与业务人员交流时，把业务人员提到的名词都给写下来，包含这些名词的属性与行为。这些名词可以是一个人、一座城市、一辆汽车、一张彩票或一次银行交易。然后再看一下出现的名词中，哪些名词所产生的实例是独一无一的，是随着时间的不同而不断变化状态的，就是实体。哪些名词是用一下就不再关心的，只是用来帮助实体完成行为的，那就是值对象。实体与值对象没有绝对的，在不同场景中有不同的解释。<br>比如说公司跟供应商之间产生了一个采购单，采购单上记录了公司的名称与供应商的名称。<br>在结算系统中，公司要与供应商算账。那么公司与供应商就是实体，采购单只是用来表示一下账有多少。用采购单算完账之后，公司与供应商还要有协商、付款等操作。这里的采购单就是值对象。<br>在计费系统中，我们需要知道根据每个采购单来算出采购的总额，这里突显的是采购这个词，公司与供应商只是用来计算的辅助项，算完这个之后，我们还要计算一下每个SKU的费用，计算一下不同账期下的抵扣费用等。这里采购单就是一个实体，公司、供应商就是值对象。</p><h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>我们抽象出来的实体可能会有很多个，物以类聚，人以群分。我们可以通过对实体的组合分类，帮我们更好的理清逻辑。<br>这里引用领域驱动中Eric对聚合的定义:</p><blockquote><p>“AGGREGATE就是一组相关对象的集合，我们把它作为数据修改的单元。每个AGGREGATE都有一个根（root）和一个边界（boundary）。边界定义了AGGREGATE的内部都有什么。根则是AGGREGATE所包含的一个特定ENTITY。对AGGREGATE而言，外部对象只可以引用根，而边界内部的对象之间则可以互相引用。除根以外的其他ENTITY都有本地标识，但这些标识只在AGGREGATE内部才需要加以区别，因为外部对象除了根ENTITY之外看不到其他对象”</p></blockquote><p>我觉得Eric已经定义的比较清楚了，我一般都是看一个对象依赖于别一个对象，它们的生命周期都一致，则可以合并成一个聚合。<br>如订单系统中的订单与订单明细，我们一般只会通过订单，来查看订单明细。当订单废弃的时候，订单明细往往也跟着废弃。这时候，我们可以认为，订单与订单明细是一个聚合。<br>在平时我们做业务功能而不是影响企业经营功能的项目建模时，我甚至觉得前期大家把一个Entity当成一个聚合也没啥不好。一是一个业务功能你抽象出来的Entity不会太多，而是做业务功能是模型是不稳定的，你可以通过后期不断的迭代来进行聚合的再抽象。前期一个Entity一个聚合可以帮助你降低建模的门槛。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>现在，我们已经抽象出来项目的Entity了，也分好聚合了。但是Entity与聚合表示是的实体的具体行为，而现实世界中有很多社交类的行为我们是无法安到Entity上的。<br>假设我们现在在做一个转账功能，我们抽象出一个Account(账户)的Entity。这个Account的有转出，转入的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferInto</span><span class="hljs-params">(Money money)</span>&#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferOut</span><span class="hljs-params">(Money money)</span>&#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们做一个转账功能，就是贷方账户转出钱，借方账户转入钱。然而，我们如果把账户中加入一个转账的功能，那么，借方账户与贷户账户行业会发生互相依赖的情况。<br>像这样，把一个由多个实体行为组成社交类行为，我们可以把它放到一个Service中，这里的Service与Entity一样，一般都是代表着现实世界中具体的含义。<br>比如，我们定义一个转账的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FundsTransferService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account creditor, Account debtor, Money money)</span>&#123;<br>        creditor.transferOut(money);<br>        debtor.transferInto(money);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，有一些全局性的规则发生的时候，我们也会在服务中进行实现，比如每个月的27号，银行通常会进行系统维护，这时候不允许转账。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FundsTransferService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account creditor, Account debtor, Money money)</span>&#123;<br>        <span class="hljs-keyword">if</span>(DateUtils.getDays(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) == <span class="hljs-number">28</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;系统在维护中,转账失败!&quot;</span>);<br>        &#125;<br>        creditor.transferOut(money);<br>        debtor.transferInto(money);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>好了，现在我们已经讲完了DDD的主要知识点，关于Factory、Repository等概念，大家可以看一下Eric的领域驱动设计，我也会在下一文DDD的具体实现案例中来进行说明。</p><h2 id="EDA"><a href="#EDA" class="headerlink" title="EDA"></a>EDA</h2><p>EDA(事件驱动架构)主要是由事件以核心，通过事件的发送、订阅来运行系统。<br>我认为事件是一个标准，当我们可以在一个系统中建立一个标准并且可以接受最终一致性的时候，我们通常可以认为这个系统与其它相关的系统是解耦的。<br><img src="/img/content/eda/eda.png" alt="事件驱动架构"><br>光从作法来看，EDA与传统架构的区别主要在于将传统架构处理数据库变更或者DDD中处理模型的变更转化成一个个标准的事件，至于事件的消费、事件的追溯则有具体的服务完成。<br>关于EDA更深一步的说明可以看笔者的上一篇文章【<a href="http://www.3world.top/2022/11/17/CQRS%E4%B8%8EEvent%20Sourcing/">CQRS与Event Sourcing</a>】</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>EDA</tag>
      
      <tag>Event Sourcing</tag>
      
      <tag>事件驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CQRS与Event Sourcing</title>
    <link href="/2022/11/17/CQRS%E4%B8%8EEvent%20Sourcing/"/>
    <url>/2022/11/17/CQRS%E4%B8%8EEvent%20Sourcing/</url>
    
    <content type="html"><![CDATA[<h1 id="Event-Souring"><a href="#Event-Souring" class="headerlink" title="Event Souring"></a>Event Souring</h1><h2 id="采购单不简单"><a href="#采购单不简单" class="headerlink" title="采购单不简单"></a>采购单不简单</h2><p>小吴是一个公司的资深SRM开发，精通三层架构，代码写的贼六。有天，小吴收到业务小张的一个需求，实现一个发货逻辑。小吴一想，简单，不就是接收到一个请求，然后处理请求，将处理后的业务数据持久化一下么。于是坑哧坑哧…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrderService</span> &#123;<br><br>    PurchaseOrderMapper purchaseOrderMapper;<br><br>    <span class="hljs-keyword">public</span> PurchaseOrder <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">PurchaseOrder</span> <span class="hljs-variable">po</span> <span class="hljs-operator">=</span> purchaseOrderMapper.get(<span class="hljs-number">123</span>);<br>        po.changeStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        purchaseOrderMapper.update(po);<br>        <span class="hljs-keyword">return</span> po;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，一个很常见的业务代码，逻辑上来看并没有什么问题。最重的是，格式还好看，完美！<br>代码上线了，跑了一段时间。<br>业务小张提了一个需求，他们发现一个采购单的状态不对，想知道3天前订单是一个什么状态。<br>这时候小吴就有点懵了，好像。。。。没有打日志<br>于是跟小张道了个歉，并且坑哧坑哧的补上一个日志。。。<br>代码上线了，跑了一段时间。<br>业务小张又来了，叫帮忙查一下3个月前某时某分某秒订单是什么状态，小吴熟练的登上一个机器，看了一下，糟糕，日志只保留1个月，查了一下中间还有小伙伴把日志的格式给改了，而且不知道改过几版。。。<br>于是小吴给跟小张又道了个歉…<br>吸收了教训，小吴心想，那把日志存到数据库吧，后面直接在数据库里查。。。心想这回没问题了吧<br>代码上线了，跑了一段时间。<br>业务小张又来了，叫帮忙查一下5个月前某时某分某秒这个订单是什么价格，糟糕，好像没打价格变更的日志。。。。小吴一下又懵了，再看下代码，造成订单变更的代码太分散了，而且开发人员不一样，日志总是打不全。<br>不管怎么样，先道歉吧，于是小吴很熟练的给小张道了个歉。<br>怎么办呢，小吴想起来前段时间学习了DDD，于是花了大半个月实现了DDD,这下好了，订单状态变更的方法全在PurchaseOrder这个Entity里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> &#123;<br><br>    PurchaseOrderRepo purchaseOrderRepo;<br>    <br>    LogRepo logRepo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        purchaseOrderRepo.updateStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;ship&quot;</span>,<span class="hljs-string">&quot;已发货&quot;</span>))；<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">negotiated</span><span class="hljs-params">(BigDecimal price)</span>&#123;<br>        purchaseOrderRepo.changePrice(prices);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;negotiated&quot;</span>,price))；<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>看起来没啥大问题了，表里所有的方法都加上日志了，想看啥时候的价格，查一下日志。想看啥时候的价格，查一下日志。小吴心里得意了。<br>但是，业务小张又来了。<br>业务小丁跟供应商那边谈崩了，供应商要求把三个月前某时某分某秒状态为未付款的采购单价格改到该订单两个月前某时某分某秒的价格，再加个三折。这。。。<br>好吧，道歉已经没啥用了，做，肯定能做！<br>于是小吴直接写个脚本改数据库，查下日志，把某时刻状态为未付款的采购单找出来。再查下日志，找到这些订单两个月的价格，然后mapping一下，修改价格。。。<br>好不容易做完了，业务方小张又来了，这回不光价格了，采购数量，优惠返回，账期通通给我改了。。。<br>于是小吴又双叒叕的道歉了。。<br>经历了这几件事，小吴就想，有没有什么办法，可以追溯状态的变更。</p><h2 id="采购单与账单的故事"><a href="#采购单与账单的故事" class="headerlink" title="采购单与账单的故事"></a>采购单与账单的故事</h2><p>还没等想好，业务小张又来了，让在采购单修改成发货状态的时候，同时生成一个账单。财务要算账。<br>小吴心想，这简单，等等，简单？总感觉有坑，但又不知道是什么坑。不管了，不想道歉就先干吧。<br>于是坑哧坑哧的又加了代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> &#123;<br><br>    PurchaseOrderRepo purchaseOrderRepo;<br><br>    BillFactory billFactory;<br>    <br>    LogRepo logRepo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        purchaseOrderRepo.updateStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;ship&quot;</span>,<span class="hljs-string">&quot;已发货&quot;</span>))；<br>        <span class="hljs-type">Bill</span> <span class="hljs-variable">bill</span> <span class="hljs-operator">=</span> billFactory.createBill(<span class="hljs-built_in">this</span>);<br>        bill.save();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">negotiated</span><span class="hljs-params">(BigDecimal price)</span>&#123;<br>        purchaseOrderRepo.changePrice(price);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;negotiated&quot;</span>,price))；<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>刚上线没多久，业务小张又来了，财务同学说账单来了，他收不到消息。<br>果然，坑来了，于是小吴又加上了代码，测试，发布，上线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> &#123;<br><br>    PurchaseOrderRepo purchaseOrderRepo;<br><br>    BillFactory billFactory;<br>    <br>    LogRepo logRepo;<br><br>    NoticeService noticeService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        purchaseOrderRepo.updateStatus(<span class="hljs-string">&quot;已发货&quot;</span>);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;ship&quot;</span>,<span class="hljs-string">&quot;已发货&quot;</span>))；<br>        <span class="hljs-type">Bill</span> <span class="hljs-variable">bill</span> <span class="hljs-operator">=</span> billFactory.createBill(<span class="hljs-built_in">this</span>);<br>        bill.save();<br>        noticeService.notice(<span class="hljs-string">&#x27;财务&#x27;</span>,<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">negotiated</span><span class="hljs-params">(BigDecimal price)</span>&#123;<br>        purchaseOrderRepo.changePrice(price);<br>        logRepo.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;negotiated&quot;</span>,price))；<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>刚加完，业务小张又来了。。。<br>小吴本能的脑袋里飘来两个字：耦合。<br>于是小吴又想，能不能在通知状态的时候进行解耦呢。<br>好了，现在小吴的问题有3个了：<br>1.可以追溯状态的变更<br>2.通知状态的变更<br>3.解耦</p><h2 id="办法总是有的"><a href="#办法总是有的" class="headerlink" title="办法总是有的"></a>办法总是有的</h2><h3 id="追溯状态的变更"><a href="#追溯状态的变更" class="headerlink" title="追溯状态的变更"></a>追溯状态的变更</h3><p>先来第一个问题 ，追溯状态的变更，刚才我们说的日志我们记录下来了，如果我们可以像mysql的binlog同步一亲，通过重刷一下日志，就能把对象恢复到当时所有的状态。是不是就可能解决问题。<br>怎么把日志重新刷，简单来说就是日志规范化。我们给日志定一个格式，我们姑且叫这个格式的日志为事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> String eventId;<br>    <span class="hljs-keyword">private</span> String eventType;<br>    <span class="hljs-keyword">private</span> String eventTopic;<br>    <span class="hljs-keyword">private</span> T data;<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们的Aggregate通过处理Event来变更自己的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以看到，当一个Aggregate产生一个Event,又通过消费这个Event来改变状态。这样做是不是多此一举呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        apply(shipEvent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        purchaseOrderRepo.updateStatus(((ShipEvent)event).getData().getStatus());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里就回到我们刚才说通过回刷事件来重溯状态的目的了。像上面，PurchaseOrder的ship方法可以里面可以有很多逻辑，比如调用发个钉钉消息通知一下物流人员，比如调用一个供应商的服务。如果我们改变状态跟ship（也就是业务逻辑）耦合在一起，那么重刷状态的时候就相当于多跑了一遍业务逻辑。</p><h3 id="通知状态的变更"><a href="#通知状态的变更" class="headerlink" title="通知状态的变更"></a>通知状态的变更</h3><p>再来说一下通知事件。常用的通知事件就是观察者模式。通过定义EventHandler来处理事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    List&lt;EventHandler&gt; handlerList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        <span class="hljs-keyword">for</span>(EventHandler handler:handlerList)&#123;<br>            handler.handle(shipEvent);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>正如上面小吴所遇到的问题，这时候，PurchaseOrder本身、账单系统、通知系统都作为一个事件处理者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    List&lt;EventHandler&gt; handlerList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        <span class="hljs-keyword">for</span>(EventHandler handler:handlerList)&#123;<br>            handler.handle(shipEvent);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        purchaseOrderRepo.updateStatus(((ShipEvent)event).getData().getStatus());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bill</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-type">Bill</span> <span class="hljs-variable">bill</span> <span class="hljs-operator">=</span> billFactory.createBill(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//发出账单创建事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    NoticeService noticeService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(Event event)</span> &#123;<br>        noticeService.notice(<span class="hljs-string">&#x27;财务&#x27;</span>,event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>好了，现在剩下最后一个问题了，解耦，在单体系统中，我们通过观察者模式来进行一个弱依赖，是可以被接受的。毕竟账单与采购单的逻辑都比较稳定，且通过观察者模式实现，修改了账单与采购单本身的逻辑并不会对另外一个有影响。<br>但我们注意到，上述的代码还有一个不太谐的地方，那就是Notice。我们很少在一个业务形态系统中抽象出来一个Notice实体，通知并不是业务系统的主要逻辑，只是为了方便交流而已。我们通常会把通知独立出来一个系统。我们知道，观察者模式在一个单体应用中要实现统一接口。怎么办呢？我们可以引入事件总线。<br>事件总线负责发布命令，事件的处理者不仅仅是单体应用中的其它对象，事件总线还可以通过消息中间件，或者RPC调用，将命令传播至其它服务，使其它服务来同样来进行事件的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">private</span> EventBus eventBus;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ship</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">shipEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShipEvent</span>(<span class="hljs-built_in">this</span>);<br>        eventStore.save(shipEvent);<br>        eventBus.send(shipEvent);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>好了，解决了小吴所留下的三个问题。我们也就引入了一个新的概念，Event Sourcing(事件溯源)。<br>我们可以把Event Souring简单的理解为以下两点:<br>1.事件是不变的，以追加方式记录事件，形成事件日志<br>2.聚合的每次状态变化，都是一个事件的发生。聚合的状态变化是通过事件来更新。</p><blockquote><p>事件溯源有几个重要的好处。例如，它保留了聚合的历史记录，这对于实现审计和监管的功能非常有帮助。它可靠地发布领域事件，这在微服务架构中特别有用。</p></blockquote><p>小吴解决了这几个问题，业务上碰到的问题再也难不倒他了。<br>要把采购单回溯到哪个状态，新建一个聚合实例，把事件重刷。<br>要查询采购单某时候的价格，新建一个聚合实例，把事件重刷。<br>业务小张又来了，业务小张又回去了。小吴很得意，又有点失落，不道歉还不习惯了。。。<br>既然有点失落，小吴就想想目前做的事情，想到，既我采购单都是要回到某个时候的状态，现在不也是某个时候么，那么现在的状态是不是也是可以通过事件来刷回来。这样不是业务在页面上想查什么时候的状态就查什么时候的，底层一套逻辑就搞定了。<br>说干就干。<br>小吴不把采购单保留在数据库了，每次启动的时候，把所有采购单命令重新刷一次。当需要把某个采购单回复到某个时候的状态时，把当前状态清空，重刷采购单命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventRestore</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br>    <br>    <span class="hljs-keyword">private</span> EventBus eventBus;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restore</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Event&gt; events = eventStore.queryAll();<br>        <span class="hljs-keyword">for</span> (Event event: events)&#123;<br>            <span class="hljs-comment">//false控制所有事件只刷本地的</span><br>            eventBus.send(event,<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrderService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PurchaseOrderFactory purchaseOrderFactory;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">public</span> PurchaseOrder <span class="hljs-title function_">queryPoByTime</span><span class="hljs-params">(Long poId,Date queryTime)</span>&#123;<br>        <span class="hljs-type">PurchaseOrder</span> <span class="hljs-variable">purchaseOrder</span> <span class="hljs-operator">=</span> purchaseOrderFactory.get(poId);<br>        List&lt;Event&gt; eventList = eventStore.listBy(queryTime,poId);<br>        eventList.stream().forEach(event-&gt;purchaseOrder.apply(event));<br>        <span class="hljs-keyword">return</span> purchaseOrder;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>小吴上网一查，找到一个牛逼哄哄的名词，In Memory。确实很Memory嘛。<br>但是光Memory可能还不行。渐渐的小吴发现，系统里面有一些采购单，从1月份到10月份状态，状态一直变，价格一直在变更。造成每个重刷采购单都要花上好几秒的时间。嗯，这是一个大V采购单。怎么办呢。<br>没想到办法，小吴决定去找了业务小张聊聊，聊聊，说不就聊出。。。灵感来了。<br>小张很厚道，完全没有业务甲方爸爸的觉悟，跟小吴解释说，这个订单是一个长期订单，一开始给供应商定了一个预估的大量采购单，供应商一批一批给，价格也随时发生变化。但是业务上只关心三个月内的情况。<br>三个月内，那不是前几个月的订单状态都白刷了。。。<br>灵感来了，小吴回去坑哧坑哧，给订单建了一个三个月前的快照，每次刷的时候，都从这个时候开始刷。完美！世界一下子又美好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PurchaseOrderService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PurchaseOrderFactory purchaseOrderFactory;<br><br>    <span class="hljs-keyword">private</span> EventStore eventStore;<br><br>    <span class="hljs-keyword">private</span> SnapshotRepository snapshotRepo;<br><br>    <span class="hljs-keyword">public</span> PurchaseOrder <span class="hljs-title function_">queryPoByTime</span><span class="hljs-params">(Long poId,Date queryTime)</span>&#123;<br>        <span class="hljs-type">Snapshot</span> <span class="hljs-variable">snapshot</span> <span class="hljs-operator">=</span> snapshotRepo.snapshotOf(poId);<br>        <span class="hljs-type">PurchaseOrder</span> <span class="hljs-variable">purchaseOrder</span> <span class="hljs-operator">=</span> snapshot.rebuildTo(PurchaseOrder.getClass());<br>        List&lt;Event&gt; eventList = eventStore.listBy(queryTime,poId);<br>        eventList.stream().forEach(event-&gt;purchaseOrder.apply(event));<br>        <span class="hljs-keyword">return</span> purchaseOrder;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>事件是一成不变的。快照可以加快事件的重刷速度。</p><h1 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h1><h2 id="业务飞速发展"><a href="#业务飞速发展" class="headerlink" title="业务飞速发展"></a>业务飞速发展</h2><p>系统上线了一段时间，小吴的得意劲也差不多过了，业务小张也好久没来找他了，正感到无聊，系统突然间报警了，系统负载太高。<br>小吴看了一下，公司这段时候业务高速发展，不仅采购单大大的增加，业务查询量也大大增长。看了一下系统，采购单修改平均20的qps,高的时候能到100。 采购单查询平均300的qps，高的时候能到2000多。主要是业务那边来了几十个分析大师，需要实时对订单进行分析。业务那边也增加了很多人，实时跟进。<br>小吴敏锐的觉查到，查询应该与修改分开。不能互相影响。于是上网查了一下，找到了一个专有名词，CQRS,Command and Query Responsibility Segregation。</p><p><img src="/img/content/cqrs/cqrs.png" alt="CQRS"><br>先不管Command Bus，小吴发现，事件这部分他已经做完了。于是乎，小吴重新部署了一个应用，原来的那个专门负责接收请求，进行更新，小吴叫这个应用为应用A。新部署的应用负责查询,叫应用R。应用A与应用R共用一个事件存储来回刷事件。应用A部署了两台服务器，应用B部署了5台。互不影响。Perfect。</p><h2 id="业务想看的更多"><a href="#业务想看的更多" class="headerlink" title="业务想看的更多"></a>业务想看的更多</h2><p>业务小张又来了，说现在大家要跟进的事情太多，能不能把当前的采购单与账单，发货单的信息集中在一起，形成一个报表。<br>小吴心想，刷一下采购单的状态，刷一下发货单的状态，刷一下账单的状态，mapping。做的事情有点多啊，性能能不能跟上。于上问小张是要看这些单据上的所有信息么，当然不是，主要是价格信息还要仓库信息，要看到商品的最低价、最高价、移动加权平均价及到达的仓库。<br>于上小吴本能的想到，那就重建一个模型，将三个单据的价格整合在一起，接收三个单据的事件，计算价格、汇总到达仓库。将计算的数据存储起来，供业务查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PuchaseFinanceAnalysicDTO</span> &#123;<br><br>    <span class="hljs-keyword">private</span> BigDecimal maxPurchasePrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal minPurchasePrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal avgPurchasePrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal maxBillPrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal minBillPrice;<br><br>    <span class="hljs-keyword">private</span> BigDecimal avgBillPrice;<br><br>    <span class="hljs-keyword">private</span> String arriveWh;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>小吴Get到了两个个新技能：<br>1.查询模型不必遵循DDD业务逻辑，业务爸爸想要啥，给啥！<br>2.不同的系统，可以通过消费不同的事件，得到自己关注的业务信息。</p><h2 id="业务想要在手机上操作"><a href="#业务想要在手机上操作" class="headerlink" title="业务想要在手机上操作"></a>业务想要在手机上操作</h2><p>业务小张说现在大家都要出去跑业务，电脑不能一直带在身边，能不能加一个手机操作页面。<br>客户端开发人员说，手机那边一直都是用TCP长连接来与后端通信。<br>小吴想起来前两天学的六边形架构，心想，传进来的参数是不是可以统一，不管是手机还是电脑，TCP还是HTTP,将传进来的报文Adapt成一个格式不就好了。<br>CQRS那个Command就很好用。<br>于是乎，小吴将修改业务抽象出来了一个个Command，并且吸收了Event的灵感，添加了CommandBus，Command可以通过CommandBus发到单体应用中，还可以通过CommandBus发往其它应用。这样，当后面业务再发展，采购单进来的qps太高，就可以将处理采购单请求与处理采购单逻辑分开，变成两个应用。处理采购单请求的应用只要负责将采购单转化成标准的Command就行了。而且，测试也可以能过命令行直接发一个Command就行，学以致用！Perfect!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> String bizCode;<br><br>    <span class="hljs-keyword">private</span> T content;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>像之前讲六边形架构一样，CQRS的核心在于首尾的标准化。抽离出来的命令与事件最好不要改变。这样可以保证核心领域的业务逻辑不变。<br>Event Sourcing讲的是Event的溯源，但有时候，溯源是要到Command的，所以有时候，我们也需要把Command存储起来，比如笔者后面要讲的业采一体系统设计。<br>什么，你们不关心，想看小吴与小张后面的故事，额。。。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>Event Sourcing</tag>
      
      <tag>事件驱动</tag>
      
      <tag>CQRS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD与应用架构</title>
    <link href="/2022/11/17/DDD%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/11/17/DDD%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>架构这一词，英文单词为Architecture。Architecture在计算机体系中解释为架构，在建筑领域中理解为结构。因此，理解计算机的架构，我们可以从建筑学中的结构出发。<br><img src="/img/content/ddd/house.png" alt="房屋结构图"><br>上图是一张房子的结构图。从图中我们可以看到，房子的结构主要是说明这个房子有什么东西，这些东西应该在什么位置，怎么样整合起来整体更好看，更耐用。<br>同样，我认为架构跟结构是一个道理的。网上大家对架构是这么定义的：架构是“以组件、组件之间的关系、组件与环境之间的关系为内容的某一系统的基本组织结构，以及指导上述内容设计与演化的原则。说白了就是说明你所描述的东西有什么组成，以什么方式组成。</p><h2 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h2><p>我们通常所说的业务架构。就是描绘一个业务有哪些东西，这些东西怎么排列,以什么样的关系组成起来。<br><img src="/img/content/ddd/alizhongtai.png" alt="阿里中台架构图"></p><h2 id="组织架构"><a href="#组织架构" class="headerlink" title="组织架构"></a>组织架构</h2><p>组织架构，就是说明组织里面有哪些部门，部门的层级关系是什么样的。或者是组织间人与人之间的关系是什么样的。<br><img src="/img/content/ddd/shaoyehewo.png" alt="少爷和我"></p><h2 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h2><p>应用架构，其实就是说明一个应用里面有哪些部分，各个部分如何排列，如何依赖。<br>比如我们最经典的三层架构<br><img src="/img/content/ddd/thirdlayer.png" alt="三层架构"></p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>框架，顾名思义，我觉得就是把一件事框在一定范围内，按照一定规范行事。框架是一种约束。<br>大家都遵守一种规范，在一个约束下干活。这样才能事半功倍。<br>框架，在是一种约束的情况下，也是一种工具。所谓工具，就是生产力。框架会提供一些方法、方式使你的生产力太幅度提高。从而使项目更快的完成。<br>比如spring框架<br>spring框架遵守了mvc的规范，让大家在这个规范约束下统一的行动。比如数据库接为Controller，业务处理为Service。大家统一行动，大大减少了沟通成本。<br>同时，spring的AOP,IOC大大提高了生产力，开发者只要会实现AOP或者IOC，会编写简单的业务代码，就可以实现一套可运行的程序。</p><h1 id="服务应用架构的演进"><a href="#服务应用架构的演进" class="headerlink" title="服务应用架构的演进"></a>服务应用架构的演进</h1><p>我们知道，当一个项目或者一件事都只有一个人在做的时候，再混乱都能整出一些条理出来。但多人开发一个项目或者是多人做一件事的时候，混乱就开始了，人越多，就越混乱，通常我们叫它熵增。而如之前所说，架构就是要确定一件事情里面有哪些东西，这些东西该如何整合来解决某个问题。说白了就是提出某种规范，大家都遵守这种规范，事情就会变得井然有序。但我们知道软件开发与建筑不一样的是，建筑不管前期设计过多少遍结构，只要定下来，建造完成之后基本上就不会动了。而软件开发在需求确定之后，随着业务变化，还是会不断的修改，不断的迭代。<br><img src="/img/content/ddd/nostop.png" alt="程序员没有天"><br>我认为，应用架构的产生是为了推动软件开发的，那它最起码要解决两个问题:<br>1.怎么确定规范使一团杂乱的事情变得有序。<br>2.当修改产生的时候，怎么样才能花最小的代价应付改动。</p><h2 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h2><p>早的时候，我们开发一套Java Web程序，直接创建一个项目。一个servlet的service方法就把所有的逻辑处理了。service方法好几千行，各种逻辑夹杂在其中。开发人员要想修改一个逻辑，往往要找半天。改完了还不知道修改的逻辑会不会影响到其它地方。测试也很麻烦，修改过一处地方，往往就要将所有功能重新测试一遍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OmnipotentServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 此处省略几千行代码</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是心很累！<br>是的，所有软件开发人员都觉得很累。<br>如我们之前所说，我们要定义一种架构，规范，使这几千行变得有序，且能最小化改动。<br>那规范怎么建立呢。分层是一种很好的方法。<br>Frank Buschmann 等人著的《面向模式的软件架构》第一卷《模式系统》第二章中提出了层的概念，该模式参考了 ISO 对 TCP/IP 协议的分层。书中是这样描述层的:</p><blockquote><p>层(layer)体系结构模式有助于构建这样的应用：它能被分解成子任务组，其中每个子任务组处于一个特定的抽象层次上。</p></blockquote><p><img src="/img/content/ddd/luan.png" alt="混乱到有序.png"></p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>在计算机本身的架构中或者网络的架构中，可以看到：到处都有分层的例子。当用分层的观点来考虑系统时，可以将各个子系统想像成按照“多层蛋糕”的形式来组织，每一层都依托在其下层之上。在这种组织方式下，上层使用了下层定义的各种服务，而下层对上层一无所知。另外，每一层对自己的上层隐藏其下层的细节。<br>比如ISO/OSI七层协议模型。<br><img src="/img/content/ddd/iso.png" alt="ISO七层协议.png"><br>我们看7层协议，从上到下，越上层越靠近用户，越下层越靠近设备。<br>我们知道一个网站功能大概可以概括成这样，用户浏览页面-&gt;点击页面上的某个功能-&gt;页面上给于反馈。<br>对于开发来说，就是接收到一个请求-&gt;处理事件-&gt;存储信息-&gt;查询信息-&gt;返回请求。<br>Martin Fowler在企业应用架构模式一书中提出了应用开发架构基本上可以分为三层。</p><ul><li>处理请求与返回请求都是最靠近用户那一层的两个子任务组，它们两个可以放到一层。</li><li>处理事件是一个子任务组，可以放到一层。</li><li>存储信息与查询信息都是最接近于存储底层的，可以放到一层。</li></ul><p><img src="/img/content/ddd/thirdlayer.png" alt="又是三层架构"><br>我认为，三层架构在水平层面对一个服务的功能进行了比较粗的颗粒度的区分。更初的两层架构往往是把处理请求与返回请求放到一层，认为与用户交互相关。处理事件与存储信息、查询信息放到一层，认为是机器处理。<br>我们来看三层架构这样区分之后，带来的效果。</p><h3 id="三层架构的效果"><a href="#三层架构的效果" class="headerlink" title="三层架构的效果"></a>三层架构的效果</h3><h4 id="用户展示层"><a href="#用户展示层" class="headerlink" title="用户展示层"></a>用户展示层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinanceInfoController</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> OrganizationService organizationService;<br>    <br>    <span class="hljs-keyword">private</span> FinanceService financeService;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/queryFinanceInfo.json&quot;)</span><br>    <span class="hljs-keyword">public</span> FinanceInfo <span class="hljs-title function_">queryFinanceInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String orgNo)</span>&#123;<br>        <span class="hljs-type">Organization</span> <span class="hljs-variable">org</span> <span class="hljs-operator">=</span> organizationService.get(orgNo);<br>        <span class="hljs-type">Finance</span> <span class="hljs-variable">finance</span> <span class="hljs-operator">=</span> financeService.get(orgNo);<br>        <span class="hljs-type">FinanceInfo</span> <span class="hljs-variable">financeInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinanceInfo</span>(org, finance);<br>        <span class="hljs-keyword">return</span> financeInfo;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，展示层专注于处理用户的请求。如果这时候页面发生了改变，我们可以将返回的FinanceInfo进行修改，而Service的业务处理可以不做修改。</p><h4 id="业务逻辑层。"><a href="#业务逻辑层。" class="headerlink" title="业务逻辑层。"></a>业务逻辑层。</h4><p>我们可以看业务按一定规则分层几个Service，一个业务逻辑或以分散到各个Service中，如果要修改某个业务，我们可以只修改到对应的Service.</p><h4 id="数据访问层。"><a href="#数据访问层。" class="headerlink" title="数据访问层。"></a>数据访问层。</h4><p>三层结构相对于两层结构，是把业务处理与数据访问分隔开来。<br>个人认为早些时候，分开的价值不大。一是早些时候数据库比较固定，一个公司一旦使用了某个数据库，基本上就不会再改变了。而是原来的软件设计是从设计往往是先设计表结构，然后基于表结构来进行开发。数据库的结构变动往往伴随着业务逻辑的变动。之所以分开，我觉得更多是人员安排上的需求。你可以让一个不了解业务的但精通SQL的开发来专注于写DAO层，而让精通于业务的开通更聚焦于写业务逻辑。然而，从毕业到现在，全栈工程师见得多了，但专职于写DAO的工程师还真没见过。</p><h3 id="三层架构的不足"><a href="#三层架构的不足" class="headerlink" title="三层架构的不足"></a>三层架构的不足</h3><p>三层架构已经流行了很长一段时间，虽然设计的初衷是美好的，所有的业务逻辑都有不同的Service来实现，Controller只负责聚合。但是在大多数情况下，开发是不怎么懂业务的，他们每天做的事情，是由产品把prd出出来，然后将prd翻译成代码。而这就造成了很多Service的混乱。混乱的情况大概会有这么几种</p><h4 id="一个Service打天下"><a href="#一个Service打天下" class="headerlink" title="一个Service打天下"></a>一个Service打天下</h4><p>我上面写到的FinanceService一样，看名字，就是跟财务相关的所有业务都在这个Service中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinanceService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取收入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title function_">getRevenue</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取成本项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bizNo</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;Cost&gt; <span class="hljs-title function_">queryCost</span><span class="hljs-params">(List&lt;String&gt; bizNo)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新成本项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bizNo</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cost</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Cost <span class="hljs-title function_">updateCost</span><span class="hljs-params">(String bizNo, Cost cost)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 省略其余几十个方法</span><br><span class="hljs-comment">     */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多个Service代表同一个意思"><a href="#多个Service代表同一个意思" class="headerlink" title="多个Service代表同一个意思"></a>多个Service代表同一个意思</h4><p>要么就是每次产品迭代的时候，根据当时的需求来新建一个Service,比如<br>FinanceCostService<br>FinanceCostProfitService<br>FinanceCostAnaliticService<br>这三个Service分别是三个不同的开发写的，第一个接到的需求是要处理公司的成本。第二个接到的需求是需要给老板一个可以看到成本项与利润的报表，开发一看，成本数据库表知道在哪了，简单，建一个Service，写一个Mapper，返回，搞定。第三个开发接到的是运营的需求，需要对成本项按照一定规则进行分析，得到分析结果。开发一看，成本数据库表知道在哪了，简单，建一个Service，写一个Mapper，返回，搞定。</p><h4 id="多个Service都在更新同一个对象"><a href="#多个Service都在更新同一个对象" class="headerlink" title="多个Service都在更新同一个对象"></a>多个Service都在更新同一个对象</h4><p>还是拿上面一个例子<br>如有两个Service:<br>FinancePoService:财务采购单据Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinancePoService</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PurchaseOrderMapper purchaseOrderMapper;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePurchaseOrderStatus</span><span class="hljs-params">(String poNo,<span class="hljs-type">int</span> status)</span>&#123;<br>        purchaseOrderMapper.updateSatus(poNo, status);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>PoCustomerService:采购单据客服Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PoCustomerService</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PurchaseOrderMapper purchaseOrderMapper;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updatePurchaseOrderStatusByPoNo</span><span class="hljs-params">(String poNo,<span class="hljs-type">int</span> status)</span>&#123;<br>        purchaseOrderMapper.updateSatus(poNo, status);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>两个Service都在更新一个采购单据状态。这时候，我们如果发现一个采购单据发生问题，我们就很难发现问题究竟出现在哪里。更有甚者，分别有几个不同的controller或者service分别调用这两个不同的service.这就更混乱了。</p><h3 id="三层架构往后发展"><a href="#三层架构往后发展" class="headerlink" title="三层架构往后发展"></a>三层架构往后发展</h3><p>从上面几个例子我们可以看到，三层架构解决了一部分问题，但究其根本，Service还是还过于庞大了，而且没有规范。你可以说是因为写代码的人水平不高，才造成的上面几个问题。但是在软件开发过程中，总是会有各式各样的开发人员。你不可能指望每个人的水平都很高，即使水平都很高，每个人的想法也会不一样。既然原因是Service过于庞大，那我们应该想一下怎么样把Service拆分。<br>刚才说到，很多开发人员不懂业务，所以不知道怎么设计Service才是合理的。这就造成了Service中核心逻辑与其它业务逻辑混合在一块，纠缠在一起，如果我们可以把Service中的核心逻辑都摘出来，单独放在一个地方，整个架构如下图所示<br><img src="/img/content/ddd/fourlayer.png" alt="核心逻辑层架构.png"><br>可以看到，不管业务逻辑怎么改变，我们的核心逻辑是稳定的。只要不涉及到核心逻辑的改变，那么我们就可以大致的认为，当前业务是安全的。<br>那么怎么把核心逻辑提取出来了，这就需要对业务有一定的了解了。我们接下的介绍的DDD就与此有关。</p><h2 id="DDD-领域驱动"><a href="#DDD-领域驱动" class="headerlink" title="DDD(领域驱动)"></a>DDD(领域驱动)</h2><p>领域驱动设计（Domain Driven Design, DDD）是由Eric Evans提出的软件系统设计的面象对象建模方式。它不是一种架构，也不是一个框架。我认为它是一种思维方式，一种思想。帮助开发人员怎么样才能更好的处理好复杂的软件项目开发。<br><img src="/img/content/ddd/ddd.png" alt="领域驱动开发流程.png"><br>前文我们说过，三层架构的主要问题在于，开发一般是不懂业务的，拿一个需求来做一个需求，多次迭代之后就容易造成混乱。在领域设计就是建立了一种思维方式，让我们了解怎么样才能更好的把核心逻辑提炼出来。<br>这里不太过多的介绍DDD,后面再详细说明。我们理解简单理解DDD的主题思想是需要开发团队与某个领域方面的专家进入业务上的沟通，并互相理解对方的语言，开发团队要了解领域内的术语，领域专家要大概懂开发团队是怎么画图的。互相沟通，进而不断迭代测试，实现核心逻辑。</p><h3 id="领域驱动经典四层分层架构"><a href="#领域驱动经典四层分层架构" class="headerlink" title="领域驱动经典四层分层架构"></a>领域驱动经典四层分层架构</h3><p>Eric在领域驱动设计一书中在提出了一个四层分层架构。<br><img src="/img/content/ddd/domain4.png" alt="领域驱动四层架构.png"><br>书中对这四层的职责是这样描述的</p><table><thead><tr><th>User Interface Layer</th><th>负责向用户显示信息和解释用户指令，这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人</th></tr></thead><tbody><tr><td>Application Layer</td><td>定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题，这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。</td></tr><tr><td>应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们相互协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度。</td><td></td></tr><tr><td>Domain Layer</td><td>负责表达业务概念，业务状态信息及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的。但是反映业务状态的是由本层控制并且使用的。领域层是业务软件的核心</td></tr><tr><td>Infrastructure Layer</td><td>为上面各层提供通用的技术行为，为应用层传送消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式。</td></tr></tbody></table><p>个人认为，Eric提出的四层架构，本质上来说就是利用DDD思想将三层架构中的核心逻辑抽来，形成domain Layer。其它的与三层架构的驱别不大。</p><h3 id="六边形架构-Hexagonal-Archetecture"><a href="#六边形架构-Hexagonal-Archetecture" class="headerlink" title="六边形架构-Hexagonal Archetecture"></a>六边形架构-Hexagonal Archetecture</h3><p>这里把六边形架构放在DDD目录下，并不是因为六边形架构跟DDD绑定起来，而是DDD结合六边形架构，可以达到更好的效果。<br>六边形架构是由Alistair Cockburn在2005年提出的，这里我们还是借助于三层架构与四层架构来说明一下。<br>三层架构与四层架构理论上是可以把表示层与业务层分开的，但也会出现一些开发是会把一些业务代码直接写在controller层，跳过业务层或者领域层。或者说开发在原本应该在领域层或者业务层实现代码写到数据源层。这就又造成了一种混乱，业务逻辑与表现层或者数据源层紧紧耦合在一起，与架构设计的初衷相违背了。大多数的第一反应还是说这是开发的水平问题。但我觉得这是一种开发方式的问题。还是那句话，开发人员水平有好有差，架构就是要说明出一个应用中存在哪些东西，怎么组合，同时，也要规范不同的做事方式来达到架构设计的初衷。我们先来看一下六边形架构。<br><img src="/img/content/ddd/six.gif" alt="六边形架构"><br>假设我们现在把开发方式改成不需要管外部输出什么了，也不用管要把数据存成什么格式。只专注于业务逻辑的开发。我们开发一个应用，需要什么的数据进来，就规范出一个对象参数。我们需要什么数据出去，就规范出一个返回对象。<br>这样，我们不受表现层与数据源层的影响了，所有实现在应用中的都是业务逻辑。<br>最后，我们把应用与表示层、数据源层对接。有几个客户端，我们用几个适配器将客户端的数据转换成应用的数据格式。有几中数据源层，我们用几个适配器将应用的数据格式转换数据源所需要的格式。我理解这就是六边形架构的思想。<br>没有表示层与数据源层开发听起来是不是与DDD有点像，DDD的核心也是与领域专家交流，形成一个的核心的业务逻辑。<br><img src="/img/content/ddd/sixdomain.png" alt="六边形架构.png"><br>我们再回到六边形架构，六边形架构将三层架构中的表示层与数据源层看成是同一种。六边形架构不是跟有几条边没有关系，你愿意的话，也可以画一个八边形叫八边形架构。六边形讲的是一个对称的概念。分层有高低之分，左右代表在同一层，没有高低之分。这里的对称说的是不管是输入还是输出，在六边形架构里是同一个概念。<br>三层架构与六边形架构主要的区别，还在于说表示层与数据源层是不是对称、平等的问题。<br>Martin Fowler在企业应用架构模式一书的2010版中对该区别作了说明：</p><blockquote><p>“然而，我认为这种非对称性是有益的。因为，为别人提供服务的接口与使用别人服务的接口存在较大的差别，需要明确区分。这就是表现层和数据源层相对于核心的本质差别。表现层是系统对外提供服务的外部接口，不管外面是复杂的人类还是一个简单的远端程序。数据源层是系统使用外部服务的接口。这样区分的好处是：客户的不同将改变你对服务的看法。”</p></blockquote><p>Martin所说的客户的不同将改变你对服务的看法，我的理解是，我们一般会在数据源层进行一些事务处理、连接池处理，在对外提供服务的外部接口一般不存这些问题。所以分开更合适。<br>我们再来看六边形架构，个人认为只在应用程序产生的结果存储起来(这里的存储是在应用层)，而通过不同的适配器再传导出去，这样的应用一般不需要数据强一致性，那么六边形架构更合适，因为这时的输入输出并没有什么更多的区别。<br>如果数据需要实时影响到结果，如调用接口进行数据存储并确认，那么，三层架构更为合适。</p><h3 id="洋葱架构-Onion-Architecture"><a href="#洋葱架构-Onion-Architecture" class="headerlink" title="洋葱架构-Onion Architecture"></a>洋葱架构-Onion Architecture</h3><p><img src="/img/content/ddd/yangcong.webp" alt="洋葱架构"><br>洋葱架构是Jeffrey Palermo在08年提出来的，与六边形架构有着大致相同的思路。他们的区别是，一个是圆形，一个是六边形，都很对称，哈哈。。。，我们看到，不管是圆还是六边形，封闭的架构图一般都意味着外层把里层包裹起来，只能是外层依赖于里层，里层不能依赖于外层。<br>六边形架构提出的时候并没有考虑到领域驱动，洋葱相比于六边形架构，实现了更多Eric领域驱动的内容，即最内层不只是一个Application了，而是分的更细。所以个人认为洋葱架构是六边形架构与领域四层架构的结合体。这里的Domain Service与Domain Model这里就先不过多说明了，后面我们讲DDD的时候再展开。</p><h3 id="DCI架构"><a href="#DCI架构" class="headerlink" title="DCI架构"></a>DCI架构</h3><p>小的时候看灌篮高手，我是一个天才是樱木的口头禅。当他在与晴子练球时说出我是一个天才时，晴子的反应是是的，樱木真是一个天才。而他在球场上比赛时说出我是一个天才时，流川往往会跳出来说：白痴。 在现实世界中，不同的场景，同一件事被理解的角度不一样。我们可以理解为，世界是由不同的场景构造出来的，一个模型只有在一个场景下才会有意义。<br>之前我们说过，我们在三层架构开的时候，常常会因为Service中的方法太多，造成了程序的混乱。那么，创建好一个DDD模型之后，就万无一矢么。举一个例子。我们抽象出来一个人的模型。那么人的固定行为就表现为一个个方法。</p><p>一个人所能做的事情是很多的，当你要把人的所有现实行为都反映到一个对象中去后，你会发现，不知不觉中，你又创建了一个上帝类。<br>Jon Kern认为，“不要试着把对象在现实世界中可以想象到的行为都实现到设计中去。相反，只需要让对象能够合适于应用系统即可。对象能做的，所知的最好是一点不多一点不少。”<br>对此，我们在DDD中通常的做法是在DomainService中描绘出对象在现实数据中可以提供的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeopleService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PeopleFactory peopleFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        people.talk();<br>        people.write();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">date</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">bohu</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        <span class="hljs-type">People</span> <span class="hljs-variable">qiuxiang</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">1</span>);<br>        bohu.talk();<br>        qiuxiang.talk();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此处省略十几个方法</span><br><span class="hljs-comment">     */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，PeopleService将一个人的具体社交行为体现了出来，代表当ApplicationService中接收到一个需求时，我们通过PeopleService来反映，通过组合People的本能行为方法来实现。<br>看起来很完美！<br>但还是那个问题，这里的PeopleService没有一个具体的约束。比如苏炳添，他是一个老师，他教学生跑步的理论课，用讲跟画图就行了。同时，他也是一个教练，他要给学生示范跑步，就得真跑起来。那么我们在PeopleService里写法就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeopleService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PeopleFactory peopleFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRunTheory</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">666</span>);<br>        people.talk();<br>        people.draw();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRunAction</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">666</span>);<br>        people.run();<br>        people.talk();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        people.talk();<br>        people.write();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">date</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">bohu</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">9527</span>);<br>        <span class="hljs-type">People</span> <span class="hljs-variable">qiuxiang</span> <span class="hljs-operator">=</span> peopleFactory.create(<span class="hljs-number">1</span>);<br>        bohu.talk();<br>        qiuxiang.talk();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此处省略几十个方法</span><br><span class="hljs-comment">     */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>想像一下，当有几十几百个苏炳添这样的对象出现之后，PeopleService。。。又乱了。<br>那我们怎么整理这个乱象。<br>软件设计终究是由人做出的决策，在提出一种设计方法时，若能从人的思维模式着手，就容易找到现实世界与模型世界的结合点。<br>结合上述所说的，我们知道PeopleService缺少一种规范，我们试着来规范一下。<br>像柏拉图的人生终极问题，”我是谁，从哪来，到哪去”。我们描述一个小场景可以用,”做什么，怎么做，具体的步骤”。<br><img src="/img/content/ddd/dci.png" alt="DCI架构"><br>回到刚刚的PeopleService，我们发现，PeopleService里的行为可以抽象出来一个个角色。比如体育课老师是一种角色，教练员是一种角色。代码变成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PhysicalTeacher</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Coach</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRun</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PhysicalTeacher</span>,Coach&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teachRun</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到，由Role代替掉了DomainService,职责更清晰。这样，People的方法更多了，但是具体相应职责的角色，来进行整体的调度，隐藏掉了People直接出去的混乱感，不在Role中需要的有People中不必呈现。整体上来看，Role的引入，把DomainService这一层的混乱给整理了。<br>我们之前说，事件的发生都是在特定的场景下的，比如苏炳添是在训练场里教导学生，在教室里面讲课。同一时间，苏炳添不会既在教室里讲课也在训练场里。这里，我们再引入一个场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Coach coach;<br>    <br>    <span class="hljs-keyword">private</span> Student student;<br>    <br>    <span class="hljs-keyword">private</span> PeopleFactory peopleFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trainTeach</span><span class="hljs-params">()</span>&#123;<br>        coach = peopleFactory.create(<span class="hljs-number">666</span>);<br>        student = peopleFactory.create(<span class="hljs-number">333</span>);<br>        coach.teachRun();<br>        student.run();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上就是DCI架构要表达的内容。<br>DCI 模式认为，在现实世界到对象世界的映射中，构成元素只有三个：数据（Data）、上下文（Context）和交互（Interaction）。<br><img src="/img/content/ddd/dci2.webp" alt="DCI架构"><br>关于DCI的理论与场景驱动我们另外开一个篇幅来说明，这里就不具全的讨论了。</p><h3 id="整洁架构-Clean-Architecture"><a href="#整洁架构-Clean-Architecture" class="headerlink" title="整洁架构(Clean Architecture)"></a>整洁架构(Clean Architecture)</h3><p><img src="/img/content/CleanArchetecture.png" alt="image.png"><br>整洁架构是由Robert C. Martin在2012年的提出的，把前面所说的六边形架构、DCI架构、洋葱架构做了一个总结,Martin认为这些架构都具有以下几个特点。<br>他们都有同样的目标，隔离关注点。他们都通过将软件分层来达到隔离。每个都至少有一层业务规则，另一层作为接口。<br>每个这些架构产出的系统都是：</p><ol><li>独立的框架。架构不依赖一些存在类库的特性。这样你可以像工具一样使用这种框架，而不需要让你的系统受到它的约束条件。</li><li>可测试。业务规则可以脱离UI，数据库，web服务器或其他外部元素进行测试。</li><li>独立的UI。UI可以很容易的更换，系统的其他部分不需要变更。例如，Web UI可以被换成控制台UI，不需要变更业务规则。</li><li>独立的数据库。你可以交换Oracle或SQL Server，用于Mongo，BigTable，CouchDB或其他的东西。你的业务规则不与数据库绑定。</li><li>独立的外部代理。实际你的业务规则并不知道关于外部世界的任何事情。</li></ol><p>这里主要是想说明两个点，Martin这里画的4个圈，不是代表整洁架构就分为四层，这里的圈只是代表外层依赖于内层。比如你可以在Use Case层与Entities层中间再加一层，DomanService层。你要是觉得还可以再拆分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>应用架构的存在，是了使一个应用的代码从混乱变得有序。尤其在多人参与开发的情况下，人数越多，熵越大。整洁有序的架构可以缓解熵增，但阻止不了，绝大部分的软件开发经过一段时间之后，都很难保持整洁。以上介绍了几个架构，提供了一些拆分应用的思路，但应用架构不是固定的，要根据自己业务，选择适合自己的最好。不要太拘泥于多一层少一层，其实并没有啥关系，只要你能通过某样形式组织好你的业务代码，使其可以最小化修改，测试，我觉得都是一个好的架构。<br>另外，国内有很多人在这些架构之后根据自己做的业务情况发展出了很多架构，我们看这些架构的时候，重要的是看他们应用于什么场景，能不能帮助很好的管理好你的应用。不要把一些高大上的图或者名字迷惑，本质上，应用架构没那么复杂。你要愿意的话，也可以画一个圆形两层架构，西瓜架构，外一层，里一层。。。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>六边形架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
